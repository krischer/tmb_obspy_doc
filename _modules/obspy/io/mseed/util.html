<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>obspy.io.mseed.util &#8212; ObsPy Documentation (1.0.3)</title>
    <link rel="stylesheet" href="../../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/font.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/css/base.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript">
  var shiftWindow = function() { scrollBy(0, -70) };
  if (location.hash) shiftWindow();
  window.addEventListener("hashchange", shiftWindow);
</script>

  </head>
  <body>
<div id="wrapper">
<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
<div class="container-fluid">
<div class="navbar-header">
<button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a href="/" class="navbar-brand" title="Home"><span class="icon-obspy"></span>&nbsp;ObsPy</a>
</div>
<div class="navbar-collapse collapse">
<form class="navbar-form navbar-right" role="search" method="get" action="http://docs.obspy.org/search.html">
<div class="form-group">
<input type="text" class="form-control" placeholder="Search Docs" name="q">
</div>
</form>
<ul class="nav navbar-nav navbar-right">
<li><a href="https://github.com/obspy/obspy/" title="GitHub"><span class="icon-github iconx2"></span><span class="hidden-sm">&nbsp;GitHub</span></a></li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Documentation"><span class="glyphicon glyphicon-book iconx2"></span><span class="hidden-sm">&nbsp;Documentation</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Getting&nbsp;Started</li>
<li><a href="https://github.com/obspy/obspy/wiki#installation">Installation</a></li>
<li><a href="https://tutorial.obspy.org/">Tutorial</a></li>
<li><a href="http://gallery.obspy.org/">Gallery</a></li>
<li><a href="https://docs.obspy.org/">API&nbsp;Documentation&nbsp;(latest&nbsp;release)</a></li>
<li><a href="https://docs.obspy.org/master/">API&nbsp;Documentation&nbsp;(current&nbsp;master)</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Mailing&nbsp;Lists"><span class="glyphicon glyphicon-envelope iconx2"></span><span class="hidden-sm">&nbsp;Mailing&nbsp;Lists</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Announcements&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-announcements"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-announcements/"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archive</a></li>
<li class="divider"></li>
<li class="dropdown-header">Users&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-users"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-users"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archives</a></li>
<li><a href="mailto:users@obspy.org"><span class="glyphicon glyphicon-envelope"></span>&nbsp;Post&nbsp;a&nbsp;message</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Developer&nbsp;Resources"><span class="glyphicon glyphicon-cog iconx2"></span><span class="hidden-sm">&nbsp;Developer&nbsp;Resources</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li><a href="https://gitter.im/obspy/obspy">Gitter</a></li>
<li><a href="https://github.com/obspy/obspy/blob/master/.github/CONTRIBUTING.md">How&nbsp;to&nbsp;contribute</a></li>
<li><a href="http://docs.obspy.org/coding_style.html">Coding&nbsp;Style&nbsp;Guide</a></li>
<li><a href="https://github.com/obspy/obspy/releases/">All&nbsp;Releases</a></li>
<li class="divider"></li>
<li class="dropdown-header">Code&nbsp;Analysis</li>
<li><a href="http://docs.obspy.org/master/pep8/index.html">PEP8</a></li>
<li><a href="http://docs.obspy.org/master/coverage/index.html">Python&nbsp;Coverage</a></li>
<li><a href="http://docs.obspy.org/master/c_coverage/index.html">C&nbsp;Coverage</a></li>
<li><a href="https://coveralls.io/r/obspy/obspy?branch=master">Coveralls</a></li>
<li class="divider"></li>
<li class="dropdown-header">Continuous&nbsp;Integration</li>
<li><a href="http://tests.obspy.org/">Test&nbsp;Reports</a></li>
<li><a href="https://travis-ci.org/obspy/obspy/"><span class="icon-travis"></span>&nbsp;Travis&nbsp;CI</a></li>
<li><a href="https://ci.appveyor.com/project/obspy/obspy"><span class="icon-appveyor"></span>&nbsp;AppVeyor</a></li>
</ul>
</li>
</ul>
</div>
</div>
</nav>

<div id="content" class="container">
  
    <div class="breadcrumb pull-right"><a href="../../../../genindex.html" title="General Index"
         accesskey="I">index</a><span style="color: #ccc; padding: 0 5px;">| </span><a href="../../../../py-modindex.html" title="Python Module Index"
         >modules</a>
    </div>
    <ol class="breadcrumb">
        <li><a href="../../../../contents.html">ObsPy Documentation (1.0.3)</a></li>
        <li><a href="../../../index.html" accesskey="U">Module code</a></li> 
    </ol>
  
  <h1>Source code for obspy.io.mseed.util</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Mini-SEED specific utilities.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">future.builtins</span> <span class="k">import</span> <span class="o">*</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">future.utils</span> <span class="k">import</span> <span class="n">native_str</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">ctypes</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="k">import</span> <span class="n">pack</span><span class="p">,</span> <span class="n">unpack</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">UTCDateTime</span>
<span class="kn">from</span> <span class="nn">obspy.core.util</span> <span class="k">import</span> <span class="n">score_at_percentile</span>
<span class="kn">from</span> <span class="nn">obspy.core.util.decorator</span> <span class="k">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">.headers</span> <span class="k">import</span> <span class="p">(</span><span class="n">ENCODINGS</span><span class="p">,</span> <span class="n">ENDIAN</span><span class="p">,</span> <span class="n">FIXED_HEADER_ACTIVITY_FLAGS</span><span class="p">,</span>
                      <span class="n">FIXED_HEADER_DATA_QUAL_FLAGS</span><span class="p">,</span>
                      <span class="n">FIXED_HEADER_IO_CLOCK_FLAGS</span><span class="p">,</span> <span class="n">FRAME</span><span class="p">,</span> <span class="n">HPTMODULUS</span><span class="p">,</span>
                      <span class="n">SAMPLESIZES</span><span class="p">,</span> <span class="n">UNSUPPORTED_ENCODINGS</span><span class="p">,</span> <span class="n">clibmseed</span><span class="p">)</span>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;&#39;getStartAndEndTime&#39; has been renamed to &quot;</span>
            <span class="s2">&quot;&#39;get_start_and_end_time&#39;. Use that instead.&quot;</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="k">def</span> <span class="nf">getStartAndEndTime</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_start_and_end_time</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="get_start_and_end_time"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util.get_start_and_end_time.html#obspy.io.mseed.util.get_start_and_end_time">[docs]</a><span class="k">def</span> <span class="nf">get_start_and_end_time</span><span class="p">(</span><span class="n">file_or_file_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the start and end time of a Mini-SEED file or file-like object.</span>

<span class="sd">    :type file_or_file_object: str or file</span>
<span class="sd">    :param file_or_file_object: Mini-SEED file name or open file-like object</span>
<span class="sd">        containing a Mini-SEED record.</span>
<span class="sd">    :return: tuple (start time of first record, end time of last record)</span>

<span class="sd">    This method will return the start time of the first record and the end time</span>
<span class="sd">    of the last record. Keep in mind that it will not return the correct result</span>
<span class="sd">    if the records in the Mini-SEED file do not have a chronological ordering.</span>

<span class="sd">    The returned end time is the time of the last data sample and not the</span>
<span class="sd">    time that the last sample covers.</span>

<span class="sd">    .. rubric:: Example</span>

<span class="sd">    &gt;&gt;&gt; from obspy.core.util import get_example_file</span>
<span class="sd">    &gt;&gt;&gt; filename = get_example_file(</span>
<span class="sd">    ...     &quot;BW.BGLD.__.EHE.D.2008.001.first_10_records&quot;)</span>
<span class="sd">    &gt;&gt;&gt; get_start_and_end_time(filename)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        (UTCDateTime(2007, 12, 31, 23, 59, 59, 915000),</span>
<span class="sd">        UTCDateTime(2008, 1, 1, 0, 0, 20, 510000))</span>

<span class="sd">    It also works with an open file pointer. The file pointer itself will not</span>
<span class="sd">    be changed.</span>

<span class="sd">    &gt;&gt;&gt; f = open(filename, &#39;rb&#39;)</span>
<span class="sd">    &gt;&gt;&gt; get_start_and_end_time(f)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        (UTCDateTime(2007, 12, 31, 23, 59, 59, 915000),</span>
<span class="sd">        UTCDateTime(2008, 1, 1, 0, 0, 20, 510000))</span>

<span class="sd">    And also with a Mini-SEED file stored in a BytesIO</span>

<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; file_object = io.BytesIO(f.read())</span>
<span class="sd">    &gt;&gt;&gt; get_start_and_end_time(file_object)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        (UTCDateTime(2007, 12, 31, 23, 59, 59, 915000),</span>
<span class="sd">        UTCDateTime(2008, 1, 1, 0, 0, 20, 510000))</span>
<span class="sd">    &gt;&gt;&gt; file_object.close()</span>

<span class="sd">    If the file pointer does not point to the first record, the start time will</span>
<span class="sd">    refer to the record it points to.</span>

<span class="sd">    &gt;&gt;&gt; _ = f.seek(512)</span>
<span class="sd">    &gt;&gt;&gt; get_start_and_end_time(f)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        (UTCDateTime(2008, 1, 1, 0, 0, 1, 975000),</span>
<span class="sd">        UTCDateTime(2008, 1, 1, 0, 0, 20, 510000))</span>

<span class="sd">    The same is valid for a file-like object.</span>

<span class="sd">    &gt;&gt;&gt; file_object = io.BytesIO(f.read())</span>
<span class="sd">    &gt;&gt;&gt; get_start_and_end_time(file_object)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        (UTCDateTime(2008, 1, 1, 0, 0, 1, 975000),</span>
<span class="sd">        UTCDateTime(2008, 1, 1, 0, 0, 20, 510000))</span>
<span class="sd">    &gt;&gt;&gt; f.close()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the starttime of the first record.</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">get_record_information</span><span class="p">(</span><span class="n">file_or_file_object</span><span class="p">)</span>
    <span class="n">starttime</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;starttime&#39;</span><span class="p">]</span>
    <span class="c1"># Get the end time of the last record.</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">get_record_information</span><span class="p">(</span>
        <span class="n">file_or_file_object</span><span class="p">,</span>
        <span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;number_of_records&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;record_length&#39;</span><span class="p">])</span>
    <span class="n">endtime</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;endtime&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span></div>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;&#39;getTimingAndDataQuality&#39; has been renamed to &quot;</span>
            <span class="s2">&quot;&#39;get_timing_and_data_quality&#39;. Use that instead.&quot;</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="k">def</span> <span class="nf">getTimingAndDataQuality</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_timing_and_data_quality</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="get_timing_and_data_quality"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util.get_timing_and_data_quality.html#obspy.io.mseed.util.get_timing_and_data_quality">[docs]</a><span class="k">def</span> <span class="nf">get_timing_and_data_quality</span><span class="p">(</span><span class="n">file_or_file_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts all data quality flags of the given Mini-SEED file and returns</span>
<span class="sd">    statistics about the timing quality if applicable.</span>

<span class="sd">    :type file_or_file_object: str or file</span>
<span class="sd">    :param file_or_file_object: Mini-SEED file name or open file-like object</span>
<span class="sd">        containing a Mini-SEED record.</span>

<span class="sd">    :return: Dictionary with information about the timing quality and the data</span>
<span class="sd">        quality flags.</span>

<span class="sd">    .. rubric:: Data quality</span>

<span class="sd">    This method will count all set data quality flag bits in the fixed section</span>
<span class="sd">    of the data header in a Mini-SEED file and returns the total count for each</span>
<span class="sd">    flag type.</span>

<span class="sd">    ========  =================================================</span>
<span class="sd">    Bit       Description</span>
<span class="sd">    ========  =================================================</span>
<span class="sd">    [Bit 0]   Amplifier saturation detected (station dependent)</span>
<span class="sd">    [Bit 1]   Digitizer clipping detected</span>
<span class="sd">    [Bit 2]   Spikes detected</span>
<span class="sd">    [Bit 3]   Glitches detected</span>
<span class="sd">    [Bit 4]   Missing/padded data present</span>
<span class="sd">    [Bit 5]   Telemetry synchronization error</span>
<span class="sd">    [Bit 6]   A digital filter may be charging</span>
<span class="sd">    [Bit 7]   Time tag is questionable</span>
<span class="sd">    ========  =================================================</span>

<span class="sd">    .. rubric:: Timing quality</span>

<span class="sd">    If the file has a Blockette 1001 statistics about the timing quality will</span>
<span class="sd">    also be returned. See the doctests for more information.</span>

<span class="sd">    This method will read the timing quality in Blockette 1001 for each</span>
<span class="sd">    record in the file if available and return the following statistics:</span>
<span class="sd">    Minima, maxima, average, median and upper and lower quantile.</span>
<span class="sd">    Quantiles are calculated using a integer round outwards policy: lower</span>
<span class="sd">    quantiles are rounded down (probability &lt; 0.5), and upper quantiles</span>
<span class="sd">    (probability &gt; 0.5) are rounded up.</span>
<span class="sd">    This gives no more than the requested probability in the tails, and at</span>
<span class="sd">    least the requested probability in the central area.</span>
<span class="sd">    The median is calculating by either taking the middle value or, with an</span>
<span class="sd">    even numbers of values, the average between the two middle values.</span>

<span class="sd">    .. rubric:: Example</span>

<span class="sd">    &gt;&gt;&gt; from obspy.core.util import get_example_file</span>
<span class="sd">    &gt;&gt;&gt; filename = get_example_file(&quot;qualityflags.mseed&quot;)</span>
<span class="sd">    &gt;&gt;&gt; tq = get_timing_and_data_quality(filename)</span>
<span class="sd">    &gt;&gt;&gt; for k, v in tq.items():</span>
<span class="sd">    ...     print(k, v)</span>
<span class="sd">    data_quality_flags [9, 8, 7, 6, 5, 4, 3, 2]</span>

<span class="sd">    Also works with file pointers and BytesIOs.</span>

<span class="sd">    &gt;&gt;&gt; f = open(filename, &#39;rb&#39;)</span>
<span class="sd">    &gt;&gt;&gt; tq = get_timing_and_data_quality(f)</span>
<span class="sd">    &gt;&gt;&gt; for k, v in tq.items():</span>
<span class="sd">    ...     print(k, v)</span>
<span class="sd">    data_quality_flags [9, 8, 7, 6, 5, 4, 3, 2]</span>

<span class="sd">    &gt;&gt;&gt; import io</span>
<span class="sd">    &gt;&gt;&gt; file_object = io.BytesIO(f.read())</span>
<span class="sd">    &gt;&gt;&gt; f.close()</span>
<span class="sd">    &gt;&gt;&gt; tq = get_timing_and_data_quality(file_object)</span>
<span class="sd">    &gt;&gt;&gt; for k, v in tq.items():</span>
<span class="sd">    ...     print(k, v)</span>
<span class="sd">    data_quality_flags [9, 8, 7, 6, 5, 4, 3, 2]</span>

<span class="sd">    If the file pointer or BytesIO position does not correspond to the first</span>
<span class="sd">    record the omitted records will be skipped.</span>

<span class="sd">    &gt;&gt;&gt; _ = file_object.seek(1024, 1)</span>
<span class="sd">    &gt;&gt;&gt; tq = get_timing_and_data_quality(file_object)</span>
<span class="sd">    &gt;&gt;&gt; for k, v in tq.items():</span>
<span class="sd">    ...     print(k, v)</span>
<span class="sd">    data_quality_flags [8, 8, 7, 6, 5, 4, 3, 2]</span>
<span class="sd">    &gt;&gt;&gt; file_object.close()</span>

<span class="sd">    Reading a file with Blockette 1001 will return timing quality statistics.</span>
<span class="sd">    The data quality flags will always exists because they are part of the</span>
<span class="sd">    fixed Mini-SEED header and therefore need to be in every Mini-SEED file.</span>

<span class="sd">    &gt;&gt;&gt; filename = get_example_file(&quot;timingquality.mseed&quot;)</span>
<span class="sd">    &gt;&gt;&gt; tq = get_timing_and_data_quality(filename)</span>
<span class="sd">    &gt;&gt;&gt; for k, v in sorted(tq.items()):</span>
<span class="sd">    ...     print(k, v)</span>
<span class="sd">    data_quality_flags [0, 0, 0, 0, 0, 0, 0, 0]</span>
<span class="sd">    timing_quality_average 50.0</span>
<span class="sd">    timing_quality_lower_quantile 25.0</span>
<span class="sd">    timing_quality_max 100.0</span>
<span class="sd">    timing_quality_median 50.0</span>
<span class="sd">    timing_quality_min 0.0</span>
<span class="sd">    timing_quality_upper_quantile 75.0</span>

<span class="sd">    Also works with file pointers and BytesIOs.</span>

<span class="sd">    &gt;&gt;&gt; f = open(filename, &#39;rb&#39;)</span>
<span class="sd">    &gt;&gt;&gt; tq = get_timing_and_data_quality(f)</span>
<span class="sd">    &gt;&gt;&gt; for k, v in sorted(tq.items()):</span>
<span class="sd">    ...     print(k, v)</span>
<span class="sd">    data_quality_flags [0, 0, 0, 0, 0, 0, 0, 0]</span>
<span class="sd">    timing_quality_average 50.0</span>
<span class="sd">    timing_quality_lower_quantile 25.0</span>
<span class="sd">    timing_quality_max 100.0</span>
<span class="sd">    timing_quality_median 50.0</span>
<span class="sd">    timing_quality_min 0.0</span>
<span class="sd">    timing_quality_upper_quantile 75.0</span>

<span class="sd">    &gt;&gt;&gt; file_object = io.BytesIO(f.read())</span>
<span class="sd">    &gt;&gt;&gt; f.close()</span>
<span class="sd">    &gt;&gt;&gt; tq = get_timing_and_data_quality(file_object)</span>
<span class="sd">    &gt;&gt;&gt; for k, v in sorted(tq.items()):</span>
<span class="sd">    ...     print(k, v)</span>
<span class="sd">    data_quality_flags [0, 0, 0, 0, 0, 0, 0, 0]</span>
<span class="sd">    timing_quality_average 50.0</span>
<span class="sd">    timing_quality_lower_quantile 25.0</span>
<span class="sd">    timing_quality_max 100.0</span>
<span class="sd">    timing_quality_median 50.0</span>
<span class="sd">    timing_quality_min 0.0</span>
<span class="sd">    timing_quality_upper_quantile 75.0</span>
<span class="sd">    &gt;&gt;&gt; file_object.close()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the first record to get a starting point and.</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">get_record_information</span><span class="p">(</span><span class="n">file_or_file_object</span><span class="p">)</span>
    <span class="c1"># Keep track of the extracted information.</span>
    <span class="n">quality_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">timing_quality</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Loop over each record. A valid record needs to have a record length of at</span>
    <span class="c1"># least 256 bytes.</span>
    <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;filesize&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">256</span><span class="p">):</span>
        <span class="n">this_info</span> <span class="o">=</span> <span class="n">get_record_information</span><span class="p">(</span><span class="n">file_or_file_object</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        <span class="c1"># Add the timing quality.</span>
        <span class="k">if</span> <span class="s1">&#39;timing_quality&#39;</span> <span class="ow">in</span> <span class="n">this_info</span><span class="p">:</span>
            <span class="n">timing_quality</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">this_info</span><span class="p">[</span><span class="s1">&#39;timing_quality&#39;</span><span class="p">]))</span>
        <span class="c1"># Add the value of each bit to the quality_count.</span>
        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">this_info</span><span class="p">[</span><span class="s1">&#39;data_quality_flags&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">_i</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">quality_count</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">this_info</span><span class="p">[</span><span class="s1">&#39;record_length&#39;</span><span class="p">]</span>

    <span class="c1"># Collect the results in a dictionary.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;data_quality_flags&#39;</span><span class="p">:</span> <span class="n">quality_count</span><span class="p">}</span>

    <span class="c1"># Parse of the timing quality list.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">timing_quality</span><span class="p">)</span>
    <span class="n">timing_quality</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">timing_quality</span><span class="p">)</span>
    <span class="c1"># If no timing_quality was collected just return an empty dictionary.</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="c1"># Otherwise calculate some statistical values from the timing quality.</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;timing_quality_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">timing_quality</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;timing_quality_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">timing_quality</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;timing_quality_average&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">timing_quality</span><span class="p">)</span> <span class="o">/</span> <span class="n">count</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;timing_quality_median&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">score_at_percentile</span><span class="p">(</span><span class="n">timing_quality</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">issorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;timing_quality_lower_quantile&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">score_at_percentile</span><span class="p">(</span><span class="n">timing_quality</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="n">issorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;timing_quality_upper_quantile&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">score_at_percentile</span><span class="p">(</span><span class="n">timing_quality</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="n">issorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;&#39;getRecordInformation&#39; has been renamed to &quot;</span>
            <span class="s2">&quot;&#39;get_record_information&#39;. Use that instead.&quot;</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="k">def</span> <span class="nf">getRecordInformation</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_record_information</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="get_record_information"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util.get_record_information.html#obspy.io.mseed.util.get_record_information">[docs]</a><span class="k">def</span> <span class="nf">get_record_information</span><span class="p">(</span><span class="n">file_or_file_object</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">endian</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns record information about given files and file-like object.</span>

<span class="sd">    :param endian: If given, the byte order will be enforced. Can be either &quot;&lt;&quot;</span>
<span class="sd">        or &quot;&gt;&quot;. If None, it will be determined automatically.</span>
<span class="sd">        Defaults to None.</span>

<span class="sd">    .. rubric:: Example</span>

<span class="sd">    &gt;&gt;&gt; from obspy.core.util import get_example_file</span>
<span class="sd">    &gt;&gt;&gt; filename = get_example_file(&quot;test.mseed&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ri = get_record_information(filename)</span>
<span class="sd">    &gt;&gt;&gt; for k, v in sorted(ri.items()):</span>
<span class="sd">    ...     print(k, v)</span>
<span class="sd">    activity_flags 0</span>
<span class="sd">    byteorder &gt;</span>
<span class="sd">    channel BHZ</span>
<span class="sd">    data_quality_flags 0</span>
<span class="sd">    encoding 11</span>
<span class="sd">    endtime 2003-05-29T02:15:51.518400Z</span>
<span class="sd">    excess_bytes 0</span>
<span class="sd">    filesize 8192</span>
<span class="sd">    io_and_clock_flags 0</span>
<span class="sd">    location 00</span>
<span class="sd">    network NL</span>
<span class="sd">    npts 5980</span>
<span class="sd">    number_of_records 2</span>
<span class="sd">    record_length 4096</span>
<span class="sd">    samp_rate 40.0</span>
<span class="sd">    starttime 2003-05-29T02:13:22.043400Z</span>
<span class="sd">    station HGN</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_or_file_object</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">native_str</span><span class="p">)):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_or_file_object</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">_get_record_information</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">endian</span><span class="o">=</span><span class="n">endian</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">_get_record_information</span><span class="p">(</span><span class="n">file_or_file_object</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                       <span class="n">endian</span><span class="o">=</span><span class="n">endian</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">info</span></div>


<div class="viewcode-block" id="_get_record_information"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._get_record_information.html#obspy.io.mseed.util._get_record_information">[docs]</a><span class="k">def</span> <span class="nf">_get_record_information</span><span class="p">(</span><span class="n">file_object</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">endian</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Searches the first Mini-SEED record stored in file_object at the current</span>
<span class="sd">    position and returns some information about it.</span>

<span class="sd">    If offset is given, the Mini-SEED record is assumed to start at current</span>
<span class="sd">    position + offset in file_object.</span>

<span class="sd">    :param endian: If given, the byte order will be enforced. Can be either &quot;&lt;&quot;</span>
<span class="sd">        or &quot;&gt;&quot;. If None, it will be determined automatically.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">initial_position</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
    <span class="n">record_start</span> <span class="o">=</span> <span class="n">initial_position</span>
    <span class="n">samp_rate</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Apply the offset.</span>
    <span class="k">if</span> <span class="n">offset</span><span class="p">:</span>
        <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">record_start</span> <span class="o">+=</span> <span class="n">offset</span>

    <span class="c1"># Get the size of the buffer.</span>
    <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;filesize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">file_object</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">-</span> <span class="n">record_start</span><span class="p">)</span>
    <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">record_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">_code</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)[</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
    <span class="c1"># Reset the offset if starting somewhere in the middle of the file.</span>
    <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;filesize&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="mi">128</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># if a multiple of minimal record length 256</span>
        <span class="n">record_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">_code</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="sa">b</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39; &#39;</span><span class="p">]:</span>
        <span class="c1"># if valid data record start at all starting with D, R, Q or M</span>
        <span class="n">record_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Might be a noise record or completely empty.</span>
    <span class="k">elif</span> <span class="n">_code</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39; &#39;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_t</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">120</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid MiniSEED file.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_t</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">_get_record_information</span><span class="p">(</span><span class="n">file_object</span><span class="o">=</span><span class="n">file_object</span><span class="p">,</span>
                                           <span class="n">endian</span><span class="o">=</span><span class="n">endian</span><span class="p">)</span>
            <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">initial_position</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">info</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid MiniSEED file.&quot;</span><span class="p">)</span>
    <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">record_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># check if full SEED or Mini-SEED</span>
    <span class="k">if</span> <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">8</span><span class="p">)[</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;V&#39;</span><span class="p">:</span>
        <span class="c1"># found a full SEED record - seek first Mini-SEED record</span>
        <span class="c1"># search blockette 005, 008 or 010 which contain the record length</span>
        <span class="n">blockette_id</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">blockette_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="sa">b</span><span class="s1">&#39;010&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;008&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;005&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">blockette_id</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;0&#39;</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;SEED Volume Index Control Headers: blockette 0xx&quot;</span> <span class="o">+</span> \
                      <span class="s2">&quot; expected, got </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">blockette_id</span><span class="p">)</span>
            <span class="c1"># get length and jump to end of current blockette</span>
            <span class="n">blockette_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
            <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">blockette_len</span> <span class="o">-</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># read next blockette id</span>
            <span class="n">blockette_id</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Skip the next bytes containing length of the blockette and version</span>
        <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># get record length</span>
        <span class="n">rec_len</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
        <span class="c1"># reset file pointer</span>
        <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">record_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># cycle through file using record length until first data record found</span>
        <span class="k">while</span> <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">7</span><span class="p">)[</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="sa">b</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;M&#39;</span><span class="p">]:</span>
            <span class="n">record_start</span> <span class="o">+=</span> <span class="n">rec_len</span>
            <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">record_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Jump to the network, station, location and channel codes.</span>
    <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">record_start</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">info</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">info</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">info</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">info</span><span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

    <span class="c1"># Use the date to figure out the byte order.</span>
    <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">record_start</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Capital letters indicate unsigned quantities.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">28</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">HHBBBxHHhhBBBxlxxH&#39;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_time</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="c1"># The spec says values[5] (.0001 seconds) must be between 0-9999 but</span>
        <span class="c1"># we&#39;ve  encountered files which have a value of 10000. We interpret</span>
        <span class="c1"># this as an additional second. The approach here is general enough</span>
        <span class="c1"># to work for any value of values[5].</span>
        <span class="n">msec</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">msec</span> <span class="o">//</span> <span class="mi">1000000</span>
        <span class="k">if</span> <span class="n">offset</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Record contains a fractional seconds (.0001 secs) of </span><span class="si">%i</span><span class="s2"> - &quot;</span>
                <span class="s2">&quot;the maximum strictly allowed value is 9999. It will be &quot;</span>
                <span class="s2">&quot;interpreted as one or more additional seconds.&quot;</span> <span class="o">%</span> <span class="n">values</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
                <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">UTCDateTime</span><span class="p">(</span>
            <span class="n">year</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">julday</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">hour</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">minute</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">second</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
            <span class="n">microsecond</span><span class="o">=</span><span class="n">msec</span> <span class="o">%</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>

    <span class="k">if</span> <span class="n">endian</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">endian</span> <span class="o">=</span> <span class="s2">&quot;&gt;&quot;</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">(</span><span class="n">endian</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">starttime</span> <span class="o">=</span> <span class="n">_parse_time</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">endian</span> <span class="o">=</span> <span class="s2">&quot;&lt;&quot;</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">(</span><span class="n">endian</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">starttime</span> <span class="o">=</span> <span class="n">_parse_time</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">(</span><span class="n">endian</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">starttime</span> <span class="o">=</span> <span class="n">_parse_time</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Invalid starttime found. The passed byte order is likely &quot;</span>
                   <span class="s2">&quot;wrong.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;npts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">npts</span>
    <span class="n">samp_rate_factor</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="n">samp_rate_mult</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;activity_flags&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
    <span class="c1"># Bit 1 of the activity flags.</span>
    <span class="n">time_correction_applied</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;activity_flags&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;io_and_clock_flags&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;data_quality_flags&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
    <span class="n">time_correction</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
    <span class="n">blkt_offset</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span>

    <span class="c1"># Correct the starttime if applicable.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">time_correction_applied</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="n">time_correction</span><span class="p">:</span>
        <span class="c1"># Time correction is in units of 0.0001 seconds.</span>
        <span class="n">starttime</span> <span class="o">+=</span> <span class="n">time_correction</span> <span class="o">*</span> <span class="mf">0.0001</span>

    <span class="c1"># Traverse the blockettes and parse Blockettes 100, 500, 1000 and/or 1001</span>
    <span class="c1"># if any of those is found.</span>
    <span class="k">while</span> <span class="n">blkt_offset</span><span class="p">:</span>
        <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">record_start</span> <span class="o">+</span> <span class="n">blkt_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">blkt_type</span><span class="p">,</span> <span class="n">next_blkt</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">HH&#39;</span> <span class="o">%</span> <span class="n">endian</span><span class="p">),</span>
                                      <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">next_blkt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">next_blkt</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">next_blkt</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">&lt;=</span> <span class="n">blkt_offset</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Invalid blockette offset (</span><span class="si">%d</span><span class="s1">) less than or equal to &#39;</span>
                   <span class="s1">&#39;current offset (</span><span class="si">%d</span><span class="s1">)&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">next_blkt</span><span class="p">,</span> <span class="n">blkt_offset</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">blkt_offset</span> <span class="o">=</span> <span class="n">next_blkt</span>

        <span class="c1"># Parse in order of likeliness.</span>
        <span class="k">if</span> <span class="n">blkt_type</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="n">encoding</span><span class="p">,</span> <span class="n">word_order</span><span class="p">,</span> <span class="n">record_length</span> <span class="o">=</span> \
                <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">BBB&#39;</span> <span class="o">%</span> <span class="n">endian</span><span class="p">),</span>
                       <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ENDIAN</span><span class="p">[</span><span class="n">word_order</span><span class="p">]</span> <span class="o">!=</span> <span class="n">endian</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Inconsistent word order.&#39;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;encoding&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;record_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">record_length</span>
        <span class="k">elif</span> <span class="n">blkt_type</span> <span class="o">==</span> <span class="mi">1001</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;timing_quality&#39;</span><span class="p">],</span> <span class="n">mu_sec</span> <span class="o">=</span> \
                <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">Bb&#39;</span> <span class="o">%</span> <span class="n">endian</span><span class="p">),</span>
                       <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">starttime</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mu_sec</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1E6</span>
        <span class="k">elif</span> <span class="n">blkt_type</span> <span class="o">==</span> <span class="mi">500</span><span class="p">:</span>
            <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mu_sec</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">b&#39;</span> <span class="o">%</span> <span class="n">endian</span><span class="p">),</span>
                            <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">starttime</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mu_sec</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1E6</span>
        <span class="k">elif</span> <span class="n">blkt_type</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">samp_rate</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">f&#39;</span> <span class="o">%</span> <span class="n">endian</span><span class="p">),</span>
                               <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># No blockette 1000 found.</span>
    <span class="k">if</span> <span class="s2">&quot;record_length&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">record_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Read 16 kb - should be a safe maximal record length.</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">14</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="c1"># This is a messy check - we just delegate to libmseed.</span>
        <span class="n">reclen</span> <span class="o">=</span> <span class="n">clibmseed</span><span class="o">.</span><span class="n">ms_detect</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">reclen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not detect data record.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reclen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># It might be at the end of the file.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span> <span class="o">**</span> <span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">256</span><span class="p">)]:</span>
                <span class="n">reclen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not determine record length.&quot;</span><span class="p">)</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">&quot;record_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reclen</span>

    <span class="c1"># If samprate not set via blockette 100 calculate the sample rate according</span>
    <span class="c1"># to the SEED manual.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">samp_rate</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">samp_rate_factor</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">samp_rate_mult</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">samp_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">samp_rate_factor</span> <span class="o">*</span> <span class="n">samp_rate_mult</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">samp_rate_factor</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">samp_rate_mult</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">samp_rate</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">samp_rate_factor</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">samp_rate_mult</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">samp_rate_factor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">samp_rate_mult</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">samp_rate</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">samp_rate_mult</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">samp_rate_factor</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">samp_rate_factor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">samp_rate_mult</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">samp_rate</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">samp_rate_factor</span> <span class="o">*</span> <span class="n">samp_rate_mult</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if everything is unset or 0 set sample rate to 1</span>
            <span class="n">samp_rate</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;samp_rate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">samp_rate</span>

    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;starttime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">starttime</span>
    <span class="c1"># Endtime is the time of the last sample.</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;endtime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">starttime</span> <span class="o">+</span> <span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">samp_rate</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;byteorder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endian</span>

    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;number_of_records&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;filesize&#39;</span><span class="p">]</span> <span class="o">//</span>
                                    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;record_length&#39;</span><span class="p">])</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;excess_bytes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;filesize&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;record_length&#39;</span><span class="p">])</span>

    <span class="c1"># Reset file pointer.</span>
    <span class="n">file_object</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">initial_position</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">info</span></div>


<div class="viewcode-block" id="_ctypes_array_2_numpy_array"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._ctypes_array_2_numpy_array.html#obspy.io.mseed.util._ctypes_array_2_numpy_array">[docs]</a><span class="k">def</span> <span class="nf">_ctypes_array_2_numpy_array</span><span class="p">(</span><span class="n">buffer_</span><span class="p">,</span> <span class="n">buffer_elements</span><span class="p">,</span> <span class="n">sampletype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a Ctypes array and its length and type and returns it as a</span>
<span class="sd">    NumPy array.</span>

<span class="sd">    :param buffer_: Ctypes c_void_p pointer to buffer.</span>
<span class="sd">    :param buffer_elements: length of the whole buffer</span>
<span class="sd">    :param sampletype: type of sample, on of &quot;a&quot;, &quot;i&quot;, &quot;f&quot;, &quot;d&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Allocate NumPy array to move memory to</span>
    <span class="n">numpy_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">buffer_elements</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sampletype</span><span class="p">)</span>
    <span class="n">datptr</span> <span class="o">=</span> <span class="n">numpy_array</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
    <span class="c1"># Manually copy the contents of the C allocated memory area to</span>
    <span class="c1"># the address of the previously created NumPy array</span>
    <span class="n">C</span><span class="o">.</span><span class="n">memmove</span><span class="p">(</span><span class="n">datptr</span><span class="p">,</span> <span class="n">buffer_</span><span class="p">,</span> <span class="n">buffer_elements</span> <span class="o">*</span> <span class="n">SAMPLESIZES</span><span class="p">[</span><span class="n">sampletype</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">numpy_array</span></div>


<div class="viewcode-block" id="_convert_msr_to_dict"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._convert_msr_to_dict.html#obspy.io.mseed.util._convert_msr_to_dict">[docs]</a><span class="k">def</span> <span class="nf">_convert_msr_to_dict</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal method used for setting header attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;network&#39;</span><span class="p">,</span> <span class="s1">&#39;station&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="s1">&#39;channel&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;dataquality&#39;</span><span class="p">,</span> <span class="s1">&#39;starttime&#39;</span><span class="p">,</span> <span class="s1">&#39;samprate&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;samplecnt&#39;</span><span class="p">,</span> <span class="s1">&#39;numsamples&#39;</span><span class="p">,</span> <span class="s1">&#39;sampletype&#39;</span><span class="p">)</span>
    <span class="c1"># loop over attributes</span>
    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
        <span class="n">h</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">_i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">h</span></div>


<div class="viewcode-block" id="_convert_datetime_to_mstime"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._convert_datetime_to_mstime.html#obspy.io.mseed.util._convert_datetime_to_mstime">[docs]</a><span class="k">def</span> <span class="nf">_convert_datetime_to_mstime</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a obspy.util.UTCDateTime object and returns an epoch time in ms.</span>

<span class="sd">    :param dt: obspy.util.UTCDateTime object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_fsec</span><span class="p">,</span> <span class="n">_sec</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">_fsec</span> <span class="o">*</span> <span class="n">HPTMODULUS</span><span class="p">))</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">_sec</span> <span class="o">*</span> <span class="n">HPTMODULUS</span><span class="p">)</span></div>


<div class="viewcode-block" id="_convert_mstime_to_datetime"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._convert_mstime_to_datetime.html#obspy.io.mseed.util._convert_mstime_to_datetime">[docs]</a><span class="k">def</span> <span class="nf">_convert_mstime_to_datetime</span><span class="p">(</span><span class="n">timestring</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a Mini-SEED timestamp and returns a obspy.util.UTCDateTime object.</span>

<span class="sd">    :param timestamp: Mini-SEED timestring (Epoch time string in ms).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">timestring</span> <span class="o">/</span> <span class="n">HPTMODULUS</span><span class="p">)</span></div>


<div class="viewcode-block" id="_unpack_steim_1"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._unpack_steim_1.html#obspy.io.mseed.util._unpack_steim_1">[docs]</a><span class="k">def</span> <span class="nf">_unpack_steim_1</span><span class="p">(</span><span class="n">data_string</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">swapflag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unpack steim1 compressed data given as string.</span>

<span class="sd">    :param data_string: data as string</span>
<span class="sd">    :param npts: number of data points</span>
<span class="sd">    :param swapflag: Swap bytes, defaults to 0</span>
<span class="sd">    :return: Return data as numpy.ndarray of dtype int32</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dbuf</span> <span class="o">=</span> <span class="n">data_string</span>
    <span class="n">datasize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dbuf</span><span class="p">)</span>
    <span class="n">samplecnt</span> <span class="o">=</span> <span class="n">npts</span>
    <span class="n">datasamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">diffbuff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">c_int32</span><span class="p">()</span>
    <span class="n">xn</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">c_int32</span><span class="p">()</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="n">clibmseed</span><span class="o">.</span><span class="n">msr_unpack_steim1</span><span class="p">(</span>
        <span class="n">C</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">dbuf</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">FRAME</span><span class="p">)),</span> <span class="n">datasize</span><span class="p">,</span>
        <span class="n">samplecnt</span><span class="p">,</span> <span class="n">samplecnt</span><span class="p">,</span> <span class="n">datasamples</span><span class="p">,</span> <span class="n">diffbuff</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="n">C</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">xn</span><span class="p">),</span> <span class="n">swapflag</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nsamples</span> <span class="o">!=</span> <span class="n">npts</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error in unpack_steim1&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">datasamples</span></div>


<div class="viewcode-block" id="_unpack_steim_2"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._unpack_steim_2.html#obspy.io.mseed.util._unpack_steim_2">[docs]</a><span class="k">def</span> <span class="nf">_unpack_steim_2</span><span class="p">(</span><span class="n">data_string</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">swapflag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unpack steim2 compressed data given as string.</span>

<span class="sd">    :param data_string: data as string</span>
<span class="sd">    :param npts: number of data points</span>
<span class="sd">    :param swapflag: Swap bytes, defaults to 0</span>
<span class="sd">    :return: Return data as numpy.ndarray of dtype int32</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dbuf</span> <span class="o">=</span> <span class="n">data_string</span>
    <span class="n">datasize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dbuf</span><span class="p">)</span>
    <span class="n">samplecnt</span> <span class="o">=</span> <span class="n">npts</span>
    <span class="n">datasamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">diffbuff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">c_int32</span><span class="p">()</span>
    <span class="n">xn</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">c_int32</span><span class="p">()</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="n">clibmseed</span><span class="o">.</span><span class="n">msr_unpack_steim2</span><span class="p">(</span>
        <span class="n">C</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">dbuf</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">FRAME</span><span class="p">)),</span> <span class="n">datasize</span><span class="p">,</span>
        <span class="n">samplecnt</span><span class="p">,</span> <span class="n">samplecnt</span><span class="p">,</span> <span class="n">datasamples</span><span class="p">,</span> <span class="n">diffbuff</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="n">C</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">xn</span><span class="p">),</span> <span class="n">swapflag</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nsamples</span> <span class="o">!=</span> <span class="n">npts</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error in unpack_steim2&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">datasamples</span></div>


<div class="viewcode-block" id="set_flags_in_fixed_headers"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util.set_flags_in_fixed_headers.html#obspy.io.mseed.util.set_flags_in_fixed_headers">[docs]</a><span class="k">def</span> <span class="nf">set_flags_in_fixed_headers</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates a given MiniSEED file with some fixed header flags.</span>

<span class="sd">    :type filename: string</span>
<span class="sd">    :param filename: Name of the MiniSEED file to be changed</span>
<span class="sd">    :type flags: dict</span>
<span class="sd">    :param flags: The flags to update in the MiniSEED file</span>

<span class="sd">        Flags are stored as a nested dictionary::</span>

<span class="sd">            { trace_id:</span>
<span class="sd">                { flag_group:</span>
<span class="sd">                    { flag_name: flag_value,</span>
<span class="sd">                                 ...</span>
<span class="sd">                    },</span>
<span class="sd">                    ...</span>
<span class="sd">                },</span>
<span class="sd">                ...</span>
<span class="sd">            }</span>

<span class="sd">        with:</span>

<span class="sd">        * ``trace_id``</span>
<span class="sd">            A string identifying the trace. A string looking like</span>
<span class="sd">            ``NETWORK.STATION.LOCATION.CHANNEL`` is expected, the values will</span>
<span class="sd">            be compared to those found in the fixed header of every record. An</span>
<span class="sd">            empty field will be interpreted  as &quot;every possible value&quot;, so</span>
<span class="sd">            ``&quot;...&quot;`` will apply to every single trace in the file. Padding</span>
<span class="sd">            spaces are ignored.</span>
<span class="sd">        * ``flag_group``</span>
<span class="sd">            Which flag group is to be changed. One of ``&#39;activity_flags&#39;``,</span>
<span class="sd">            ``&#39;io_clock_flags&#39;``, ``&#39;data_qual_flags&#39;`` is expected. Invalid</span>
<span class="sd">            flag groups raise a ``ValueError``.</span>
<span class="sd">        * ``flag_name``</span>
<span class="sd">            The name of the flag. Possible values are matched with</span>
<span class="sd">            ``obspy.io.mseed.headers.FIXED_HEADER_ACTIVITY_FLAGS``,</span>
<span class="sd">            ``FIXED_HEADER_IO_CLOCK_FLAGS`` or ``FIXED_HEADER_DATA_QUAL_FLAGS``</span>
<span class="sd">            depending on the flag_group. Invalid flags raise a ``ValueError``.</span>
<span class="sd">        * ``flag_value``</span>
<span class="sd">            The value you want for this flag. Expected value is a bool (always</span>
<span class="sd">            ``True``/``False``) or a dict to store the moments and durations</span>
<span class="sd">            when this flag is ``True``. Expected syntax for this dict is</span>
<span class="sd">            accurately described in ``obspy.io.mseed.util._check_flag_value``.</span>

<span class="sd">    :raises IOError: if the file is not a MiniSEED file</span>
<span class="sd">    :raises ValueError: if one of the flag group, flag name or flag value is</span>
<span class="sd">        incorrect</span>

<span class="sd">    Example: to add a *Calibration Signals Present* flag (which belongs to the</span>
<span class="sd">    Activity Flags section of the fixed header) to every record, flags should</span>
<span class="sd">    be::</span>

<span class="sd">        { &quot;...&quot; : { &quot;activity_flags&quot; : { &quot;calib_signal&quot; : True }}}</span>

<span class="sd">    Example: to add a *Event in Progress* flag (which belongs to the</span>
<span class="sd">    Activity Flags section of the fixed header) from 2009/12/23 06:00:00 to</span>
<span class="sd">    2009/12/23 06:30:00, from 2009/12/24 10:00:00 to 2009/12/24 10:30:00 and</span>
<span class="sd">    at precise times 2009/12/26 18:00:00 and 2009/12/26 18:04:00,</span>
<span class="sd">    flags should be::</span>

<span class="sd">        date1 = UTCDateTime(&quot;2009-12-23T06:00:00.0&quot;)</span>
<span class="sd">        date2 = UTCDateTime(&quot;2009-12-23T06:30:00.0&quot;)</span>
<span class="sd">        date3 = UTCDateTime(&quot;2009-12-24T10:00:00.0&quot;)</span>
<span class="sd">        date4 = UTCDateTime(&quot;2009-12-24T10:30:00.0&quot;)</span>
<span class="sd">        date5 = UTCDateTime(&quot;2009-12-26T18:00:00.0&quot;)</span>
<span class="sd">        date6 = UTCDateTime(&quot;2009-12-26T18:04:00.0&quot;)</span>
<span class="sd">        { &quot;...&quot; :</span>
<span class="sd">            { &quot;activity_flags&quot; :</span>
<span class="sd">                { &quot;event_in_progress&quot; :</span>
<span class="sd">                    {&quot;INSTANT&quot; : [date5, date6],</span>
<span class="sd">                    &quot;DURATION&quot; : [(date1, date2), (date3, date4)]}}}}</span>

<span class="sd">    Alternative way to mark duration::</span>

<span class="sd">        { &quot;...&quot; :</span>
<span class="sd">            { &quot;activity_flags&quot; :</span>
<span class="sd">                { &quot;event_in_progress&quot; :</span>
<span class="sd">                    { &quot;INSTANT&quot; : [date5, date6],</span>
<span class="sd">                      &quot;DURATION&quot; : [date1, date2, date3, date4]}}}}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># import has to be here to break import loop</span>
    <span class="kn">from</span> <span class="nn">.core</span> <span class="k">import</span> <span class="n">_is_mseed</span>
    <span class="c1"># Basic check</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_is_mseed</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;File </span><span class="si">%s</span><span class="s2"> is not a valid MiniSEED file&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">filesize</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="c1"># Nested dictionaries to allow empty strings as wildcards</span>
    <span class="k">class</span> <span class="nc">NestedDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)()</span>
            <span class="k">return</span> <span class="n">value</span>
    <span class="c1"># Define wildcard character</span>
    <span class="n">wildcard</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># Check channel identifier value</span>
    <span class="n">flags_bytes</span> <span class="o">=</span> <span class="n">NestedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">flags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">split_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid channel identifier. &quot;</span> <span class="o">+</span>\
                  <span class="s2">&quot;Expected &#39;Network.Station.Location.Channel&#39; &quot;</span> <span class="o">+</span>\
                  <span class="s2">&quot;(empty fields allowed), got &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

        <span class="c1"># Remove padding spaces and store in new dict</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">split_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">sta</span> <span class="o">=</span> <span class="n">split_key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">split_key</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">cha</span> <span class="o">=</span> <span class="n">split_key</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="c1"># Check flag value for invalid data</span>
        <span class="k">for</span> <span class="n">flag_group</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
            <span class="c1"># Check invalid flag group, and prepare check for invalid flag name</span>
            <span class="k">if</span> <span class="n">flag_group</span> <span class="o">==</span> <span class="s1">&#39;activity_flags&#39;</span><span class="p">:</span>
                <span class="n">record_to_check</span> <span class="o">=</span> <span class="n">FIXED_HEADER_ACTIVITY_FLAGS</span>
            <span class="k">elif</span> <span class="n">flag_group</span> <span class="o">==</span> <span class="s1">&#39;io_clock_flags&#39;</span><span class="p">:</span>
                <span class="n">record_to_check</span> <span class="o">=</span> <span class="n">FIXED_HEADER_IO_CLOCK_FLAGS</span>
            <span class="k">elif</span> <span class="n">flag_group</span> <span class="o">==</span> <span class="s1">&#39;data_qual_flags&#39;</span><span class="p">:</span>
                <span class="n">record_to_check</span> <span class="o">=</span> <span class="n">FIXED_HEADER_DATA_QUAL_FLAGS</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid flag group </span><span class="si">%s</span><span class="s2">. One of &#39;activity_flags&#39;, &quot;</span> <span class="o">+</span>\
                      <span class="s2">&quot;&#39;io_clock_flags&#39;, &#39;data_qual_flags&#39; is expected.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">flag_group</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">flag_name</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="n">flag_group</span><span class="p">]:</span>
                <span class="c1"># Check invalid flag name</span>
                <span class="k">if</span> <span class="n">flag_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">record_to_check</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid flag name </span><span class="si">%s</span><span class="s2">. One of </span><span class="si">%s</span><span class="s2"> is expected.&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">flag_name</span><span class="p">,</span>
                                            <span class="nb">str</span><span class="p">(</span><span class="n">record_to_check</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>

                <span class="c1"># Check flag values and store them in an &quot;easy to parse&quot; way:</span>
                <span class="c1"># either bool or list of tuples (start, end)</span>
                <span class="n">flag_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">flag_group</span><span class="p">][</span><span class="n">flag_name</span><span class="p">]</span>
                <span class="n">corrected_flag</span> <span class="o">=</span> <span class="n">_check_flag_value</span><span class="p">(</span><span class="n">flag_value</span><span class="p">)</span>
                <span class="n">flags_bytes</span><span class="p">[</span><span class="n">net</span><span class="p">][</span><span class="n">sta</span><span class="p">][</span><span class="n">loc</span><span class="p">][</span><span class="n">cha</span><span class="p">][</span><span class="n">flag_group</span><span class="p">][</span><span class="n">flag_name</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">corrected_flag</span>

    <span class="c1"># Open file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r+b&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mseed_file</span><span class="p">:</span>
        <span class="c1"># Run through all records</span>
        <span class="k">while</span> <span class="n">mseed_file</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">filesize</span><span class="p">:</span>
            <span class="n">record_start</span> <span class="o">=</span> <span class="n">mseed_file</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

            <span class="c1"># Ignore sequence number and data header</span>
            <span class="n">mseed_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_CUR</span><span class="p">)</span>
            <span class="c1"># Read identifier</span>
            <span class="n">sta</span> <span class="o">=</span> <span class="n">mseed_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">mseed_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="n">chan</span> <span class="o">=</span> <span class="n">mseed_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="n">net</span> <span class="o">=</span> <span class="n">mseed_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

            <span class="c1"># Search the nested dict for the network identifier</span>
            <span class="k">if</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">flags_bytes</span><span class="p">:</span>
                <span class="n">dict_to_use</span> <span class="o">=</span> <span class="n">flags_bytes</span><span class="p">[</span><span class="n">net</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">wildcard</span> <span class="ow">in</span> <span class="n">flags_bytes</span><span class="p">:</span>
                <span class="n">dict_to_use</span> <span class="o">=</span> <span class="n">flags_bytes</span><span class="p">[</span><span class="n">wildcard</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dict_to_use</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Search the nested dict for the station identifier</span>
            <span class="k">if</span> <span class="n">dict_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">dict_to_use</span><span class="p">:</span>
                <span class="n">dict_to_use</span> <span class="o">=</span> <span class="n">dict_to_use</span><span class="p">[</span><span class="n">sta</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">dict_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wildcard</span> <span class="ow">in</span> <span class="n">dict_to_use</span><span class="p">:</span>
                <span class="n">dict_to_use</span> <span class="o">=</span> <span class="n">dict_to_use</span><span class="p">[</span><span class="n">wildcard</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dict_to_use</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Search the nested dict for the location identifier</span>
            <span class="k">if</span> <span class="n">dict_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">dict_to_use</span><span class="p">:</span>
                <span class="n">dict_to_use</span> <span class="o">=</span> <span class="n">dict_to_use</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">dict_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wildcard</span> <span class="ow">in</span> <span class="n">dict_to_use</span><span class="p">:</span>
                <span class="n">dict_to_use</span> <span class="o">=</span> <span class="n">dict_to_use</span><span class="p">[</span><span class="n">wildcard</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dict_to_use</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Search the nested dict for the channel identifier</span>
            <span class="k">if</span> <span class="n">dict_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">dict_to_use</span><span class="p">:</span>
                <span class="n">flags_value</span> <span class="o">=</span> <span class="n">dict_to_use</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">dict_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wildcard</span> <span class="ow">in</span> <span class="n">dict_to_use</span><span class="p">:</span>
                <span class="n">flags_value</span> <span class="o">=</span> <span class="n">dict_to_use</span><span class="p">[</span><span class="n">wildcard</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flags_value</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">flags_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Calculate the real start and end of the record</span>
                <span class="n">recstart</span> <span class="o">=</span> <span class="n">mseed_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                <span class="p">(</span><span class="n">yr</span><span class="p">,</span> <span class="n">doy</span><span class="p">,</span> <span class="n">hr</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">sec</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">mil</span><span class="p">)</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s2">&quot;&gt;HHBBBBH&quot;</span><span class="p">),</span>
                                                        <span class="n">recstart</span><span class="p">)</span>
                <span class="c1"># Transformation to UTCDatetime()</span>
                <span class="n">recstart</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">yr</span><span class="p">,</span> <span class="n">julday</span><span class="o">=</span><span class="n">doy</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="n">hr</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="n">mn</span><span class="p">,</span>
                                       <span class="n">second</span><span class="o">=</span><span class="n">sec</span><span class="p">,</span> <span class="n">microsecond</span><span class="o">=</span><span class="n">mil</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
                <span class="c1"># Read data to date begin and end of record</span>
                <span class="p">(</span><span class="n">nb_samples</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">mult</span><span class="p">)</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s2">&quot;&gt;Hhh&quot;</span><span class="p">),</span>
                                                  <span class="n">mseed_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>

                <span class="c1"># Manage time correction</span>
                <span class="n">act_flags</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s2">&quot;&gt;B&quot;</span><span class="p">),</span> <span class="n">mseed_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">time_correction_applied</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">act_flags</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">time_correction</span><span class="p">)</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s2">&quot;&gt;BBBl&quot;</span><span class="p">),</span>
                                                    <span class="n">mseed_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">time_correction_applied</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="n">time_correction</span><span class="p">:</span>
                    <span class="c1"># Time correction is in units of 0.0001 seconds.</span>
                    <span class="n">recstart</span> <span class="o">+=</span> <span class="n">time_correction</span> <span class="o">*</span> <span class="mf">0.0001</span>

                <span class="c1"># Manage blockette&#39;s datation informations</span>
                <span class="c1"># Search for blockette 100&#39;s &quot;Actual sample rate&quot; field</span>
                <span class="n">samp_rate</span> <span class="o">=</span> <span class="n">_search_flag_in_blockette</span><span class="p">(</span><span class="n">mseed_file</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">samp_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">samp_rate</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s2">&quot;&gt;b&quot;</span><span class="p">),</span> <span class="n">samp_rate</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Search for blockette 1001&#39;s &quot;microsec&quot; field</span>
                <span class="n">microsec</span> <span class="o">=</span> <span class="n">_search_flag_in_blockette</span><span class="p">(</span><span class="n">mseed_file</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1001</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">microsec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">microsec</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s2">&quot;&gt;b&quot;</span><span class="p">),</span> <span class="n">microsec</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">microsec</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">realstarttime</span> <span class="o">=</span> <span class="n">recstart</span> <span class="o">+</span> <span class="n">microsec</span> <span class="o">*</span> <span class="mf">0.000001</span>

                <span class="c1"># If samprate not set via blockette 100 calculate the sample</span>
                <span class="c1"># rate according to the SEED manual.</span>
                <span class="k">if</span> <span class="n">samp_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">fact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mult</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">samp_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fact</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">fact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mult</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">samp_rate</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">fact</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">fact</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mult</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">samp_rate</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">fact</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">fact</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mult</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">samp_rate</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">fact</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># if everything is unset or 0 set sample rate to 1</span>
                        <span class="n">samp_rate</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># date of the last sample is recstart+samp_rate*(nb_samples-1)</span>
                <span class="c1"># We assume here that a record with samples [0, 1, ..., n]</span>
                <span class="c1"># has a period [ date_0, date_n+1 [  AND NOT [ date_0, date_n ]</span>
                <span class="n">realendtime</span> <span class="o">=</span> <span class="n">recstart</span> <span class="o">+</span> <span class="n">samp_rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">nb_samples</span><span class="p">)</span>

                <span class="c1"># Convert flags to bytes : activity</span>
                <span class="k">if</span> <span class="s1">&#39;activity_flags&#39;</span> <span class="ow">in</span> <span class="n">flags_value</span><span class="p">:</span>
                    <span class="n">act_flag</span> <span class="o">=</span> <span class="n">_convert_flags_to_raw_byte</span><span class="p">(</span>
                        <span class="n">FIXED_HEADER_ACTIVITY_FLAGS</span><span class="p">,</span>
                        <span class="n">flags_value</span><span class="p">[</span><span class="s1">&#39;activity_flags&#39;</span><span class="p">],</span>
                        <span class="n">realstarttime</span><span class="p">,</span> <span class="n">realendtime</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">act_flag</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Convert flags to bytes : i/o and clock</span>
                <span class="k">if</span> <span class="s1">&#39;io_clock_flags&#39;</span> <span class="ow">in</span> <span class="n">flags_value</span><span class="p">:</span>
                    <span class="n">io_clock_flag</span> <span class="o">=</span> <span class="n">_convert_flags_to_raw_byte</span><span class="p">(</span>
                        <span class="n">FIXED_HEADER_IO_CLOCK_FLAGS</span><span class="p">,</span>
                        <span class="n">flags_value</span><span class="p">[</span><span class="s1">&#39;io_clock_flags&#39;</span><span class="p">],</span>
                        <span class="n">realstarttime</span><span class="p">,</span> <span class="n">realendtime</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">io_clock_flag</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Convert flags to bytes : data quality flags</span>
                <span class="k">if</span> <span class="s1">&#39;data_qual_flags&#39;</span> <span class="ow">in</span> <span class="n">flags_value</span><span class="p">:</span>
                    <span class="n">data_qual_flag</span> <span class="o">=</span> <span class="n">_convert_flags_to_raw_byte</span><span class="p">(</span>
                        <span class="n">FIXED_HEADER_DATA_QUAL_FLAGS</span><span class="p">,</span>
                        <span class="n">flags_value</span><span class="p">[</span><span class="s1">&#39;data_qual_flags&#39;</span><span class="p">],</span>
                        <span class="n">realstarttime</span><span class="p">,</span> <span class="n">realendtime</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data_qual_flag</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">flagsbytes</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="s2">&quot;BBB&quot;</span><span class="p">,</span> <span class="n">act_flag</span><span class="p">,</span>
                                  <span class="n">io_clock_flag</span><span class="p">,</span> <span class="n">data_qual_flag</span><span class="p">)</span>
                <span class="c1"># Go back right before the fixed header flags</span>
                <span class="n">mseed_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_CUR</span><span class="p">)</span>
                <span class="c1"># Update flags*</span>
                <span class="n">mseed_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">flagsbytes</span><span class="p">)</span>
                <span class="c1"># Seek to first blockette</span>
                <span class="n">mseed_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_CUR</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Seek directly to first blockette</span>
                <span class="n">mseed_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_CUR</span><span class="p">)</span>

            <span class="c1"># Read record length in blockette 1000 to seek to the next record</span>
            <span class="n">reclen_pow</span> <span class="o">=</span> <span class="n">_search_flag_in_blockette</span><span class="p">(</span><span class="n">mseed_file</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">reclen_pow</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid MiniSEED file. No blockette 1000 was found.&quot;</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reclen_pow</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">),</span> <span class="n">reclen_pow</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">reclen</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">reclen_pow</span>
                <span class="n">mseed_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">record_start</span> <span class="o">+</span> <span class="n">reclen</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">)</span></div>


<div class="viewcode-block" id="_check_flag_value"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._check_flag_value.html#obspy.io.mseed.util._check_flag_value">[docs]</a><span class="k">def</span> <span class="nf">_check_flag_value</span><span class="p">(</span><span class="n">flag_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Search for a given flag in a given blockette for the current record.</span>

<span class="sd">    This is a utility function for set_flags_in_fixed_headers and is not</span>
<span class="sd">    designed to be called by someone else.</span>

<span class="sd">    This function checks for valid entries for a flag. A flag can be either</span>
<span class="sd">    * ``bool`` value to be always True or False for all the records</span>
<span class="sd">    * ``datetime`` or ``UTCDateTime`` value to add a single &#39;INSTANT&#39; datation</span>
<span class="sd">    (see below)</span>
<span class="sd">    * ``dict`` to allow complex flag datation</span>
<span class="sd">    ** The dict keys may be the keyword INSTANT to mark arbitrarly short</span>
<span class="sd">    duration flags, or the keyword DURATION to mark events that span across</span>
<span class="sd">    time.</span>
<span class="sd">    ** The dict values are:</span>
<span class="sd">    *** for the INSTANT value, a single UTCDateTime or datetime object, or a</span>
<span class="sd">    list of these datation objects</span>
<span class="sd">    *** for the DURATION value, either a list of</span>
<span class="sd">    [start1, end1, start2, end2, ...] or a list of tuples</span>
<span class="sd">    [(start1, end1), (start2, end2), ...]</span>


<span class="sd">    This function then returns all datation events as a list of tuples</span>
<span class="sd">    [(start1, end1), ...] to ease the work of _convert_flags_to_raw_byte. Bool</span>
<span class="sd">    values are unchanged, instant events become a tuple</span>
<span class="sd">    (event_date, event_date).</span>

<span class="sd">    If the flag value is incorrect, a ValueError is raised with a (hopefully)</span>
<span class="sd">    explicit enough message.</span>

<span class="sd">    :type flag_value: bool or dict</span>
<span class="sd">    :param flag_value: the flag value to check.</span>
<span class="sd">    :return: corrected value of the flag.</span>
<span class="sd">    :raises: If the flag is not the one expected, a ``ValueError`` is raised</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flag_value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="c1"># bool allowed</span>
        <span class="n">corrected_flag</span> <span class="o">=</span> <span class="n">flag_value</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flag_value</span><span class="p">,</span> <span class="n">datetime</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">flag_value</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
        <span class="c1"># A single instant value is allowed</span>
        <span class="n">utc_val</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">flag_value</span><span class="p">)</span>
        <span class="n">corrected_flag</span> <span class="o">=</span> <span class="p">[(</span><span class="n">utc_val</span><span class="p">,</span> <span class="n">utc_val</span><span class="p">)]</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flag_value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
        <span class="c1"># dict allowed if it has the right format</span>
        <span class="n">corrected_flag</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">flag_key</span> <span class="ow">in</span> <span class="n">flag_value</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flag_key</span> <span class="o">==</span> <span class="s2">&quot;INSTANT&quot;</span><span class="p">:</span>
                <span class="c1"># Expected: list of UTCDateTime</span>
                <span class="n">inst_values</span> <span class="o">=</span> <span class="n">flag_value</span><span class="p">[</span><span class="n">flag_key</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst_values</span><span class="p">,</span> <span class="n">datetime</span><span class="p">)</span> <span class="ow">or</span> \
                   <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst_values</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
                    <span class="c1"># Single value : ensure it&#39;s UTCDateTime and store it</span>
                    <span class="n">utc_val</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">inst_values</span><span class="p">)</span>
                    <span class="n">corrected_flag</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">utc_val</span><span class="p">,</span> <span class="n">utc_val</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst_values</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
                    <span class="c1"># Several instant values : check their types</span>
                    <span class="c1"># and add each of them</span>
                    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inst_values</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">datetime</span><span class="p">)</span> <span class="ow">or</span> \
                           <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
                            <span class="n">utc_val</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                            <span class="n">corrected_flag</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">utc_val</span><span class="p">,</span> <span class="n">utc_val</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unexpected type for flag duration &quot;</span> <span class="o">+</span>\
                                  <span class="s2">&quot;&#39;INSTANT&#39; </span><span class="si">%s</span><span class="s2">&quot;</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">inst_values</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unexpected type for flag duration &#39;INSTANT&#39; </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">inst_values</span><span class="p">)))</span>

            <span class="k">elif</span> <span class="n">flag_key</span> <span class="o">==</span> <span class="s2">&quot;DURATION&quot;</span><span class="p">:</span>
                <span class="c1"># Expecting either a list of tuples (start, end) or</span>
                <span class="c1"># a list of (start1, end1, start1, end1)</span>
                <span class="n">dur_values</span> <span class="o">=</span> <span class="n">flag_value</span><span class="p">[</span><span class="n">flag_key</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dur_values</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dur_values</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Check first item</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dur_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">datetime</span><span class="p">)</span> <span class="ow">or</span> \
                           <span class="nb">isinstance</span><span class="p">(</span><span class="n">dur_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">UTCDateTime</span><span class="p">):</span>
                            <span class="c1"># List of [start1, end1, start2, end2, etc]</span>
                            <span class="c1"># Check len</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dur_values</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Expected even length of duration &quot;</span> <span class="o">+</span>\
                                      <span class="s2">&quot;values, got </span><span class="si">%s</span><span class="s2">&quot;</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">dur_values</span><span class="p">))</span>

                            <span class="c1"># Add values</span>
                            <span class="n">duration_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">dur_values</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">duration_iter</span><span class="p">:</span>
                                <span class="n">start</span> <span class="o">=</span> <span class="n">value</span>
                                <span class="n">end</span> <span class="o">=</span> <span class="n">dur_values</span><span class="p">[</span><span class="n">dur_values</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                                <span class="c1"># Check start type</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">datetime</span><span class="p">)</span> <span class="ow">and</span> \
                                   <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
                                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Incorrect type for duration &quot;</span> <span class="o">+</span>\
                                          <span class="s2">&quot;start </span><span class="si">%s</span><span class="s2">&quot;</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">start</span><span class="p">)))</span>

                                <span class="c1"># Check end type</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">datetime</span><span class="p">)</span> <span class="ow">and</span> \
                                   <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
                                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Incorrect type for duration &quot;</span> <span class="o">+</span>\
                                          <span class="s2">&quot;end </span><span class="si">%s</span><span class="s2">&quot;</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">end</span><span class="p">)))</span>

                                <span class="c1"># Check duration validity</span>
                                <span class="n">start</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                                <span class="n">end</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
                                    <span class="n">corrected_flag</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Flag datation: expected end of &quot;</span> <span class="o">+</span>\
                                          <span class="s2">&quot;duration after its start&quot;</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                                <span class="nb">next</span><span class="p">(</span><span class="n">duration_iter</span><span class="p">)</span>

                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dur_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
                            <span class="c1"># List of tuples (start, end)</span>
                            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dur_values</span><span class="p">:</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
                                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Incorrect type </span><span class="si">%s</span><span class="s2"> for flag duration&quot;</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
                                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Incorrect len </span><span class="si">%s</span><span class="s2"> for flag duration&quot;</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">start</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="n">end</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                                    <span class="c1"># Check start type</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">datetime</span><span class="p">)</span> <span class="ow">and</span> \
                                       <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
                                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Incorrect type for duration &quot;</span> <span class="o">+</span>\
                                              <span class="s2">&quot;start </span><span class="si">%s</span><span class="s2">&quot;</span>
                                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span>
                                                         <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">start</span><span class="p">)))</span>

                                    <span class="c1"># Check end type</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">datetime</span><span class="p">)</span> <span class="ow">and</span> \
                                       <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
                                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Incorrect type for duration &quot;</span> <span class="o">+</span>\
                                              <span class="s2">&quot;end </span><span class="si">%s</span><span class="s2">&quot;</span>
                                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">end</span><span class="p">)))</span>
                                    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
                                        <span class="n">corrected_flag</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Flag datation: expected end &quot;</span> <span class="o">+</span>\
                                              <span class="s2">&quot;of duration after its start&quot;</span>
                                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                    <span class="c1"># Else: len(dur_values) == 0, empty duration list:</span>
                    <span class="c1"># do nothing</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Incorrect DURATION value: expected a list of &quot;</span> <span class="o">+</span>\
                          <span class="s2">&quot;tuples (start, end), got </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dur_values</span><span class="p">)))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid key </span><span class="si">%s</span><span class="s2"> for flag value. One of &quot;</span> <span class="o">+</span>\
                      <span class="s2">&quot;&#39;INSTANT&#39;, &#39;DURATION&#39; is expected.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">flag_key</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid type </span><span class="si">%s</span><span class="s2"> for flag value. Allowed values &quot;</span> <span class="o">+</span>\
              <span class="s2">&quot;are bool or dict&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">flag_value</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">corrected_flag</span></div>


<div class="viewcode-block" id="_search_flag_in_blockette"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._search_flag_in_blockette.html#obspy.io.mseed.util._search_flag_in_blockette">[docs]</a><span class="k">def</span> <span class="nf">_search_flag_in_blockette</span><span class="p">(</span><span class="n">mseed_file_desc</span><span class="p">,</span> <span class="n">first_blockette_offset</span><span class="p">,</span>
                              <span class="n">blockette_number</span><span class="p">,</span> <span class="n">field_offset</span><span class="p">,</span> <span class="n">field_length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Search for a given flag in a given blockette for the current record.</span>

<span class="sd">    This is a utility function for set_flags_in_fixed_headers and is not</span>
<span class="sd">    designed to be called by someone else.</span>

<span class="sd">    This function uses the file descriptor``mseed_file_desc``, seeks</span>
<span class="sd">    ``first_blockette_offset`` to go to the first blockette, reads through all</span>
<span class="sd">    the blockettes until it finds the one with number ``blockette_number``,</span>
<span class="sd">    then skips ``field_offset`` bytes to read ``field_length`` bytes and</span>
<span class="sd">    returns them. If the blockette does not exist, it returns None</span>

<span class="sd">    Please note that this function does not decommute the binary value into an</span>
<span class="sd">    exploitable data (int, float, string, ...)</span>
<span class="sd">    :type mseed_file_desc: File object</span>
<span class="sd">    :param mseed_file_desc: a File descriptor to the current miniseed file.</span>
<span class="sd">    The value of mseed_file_desc.tell() is set back by this funcion before</span>
<span class="sd">    returning, use in multithread applications at your own risk.</span>
<span class="sd">    :type first_blockette_offset: int</span>
<span class="sd">    :param first_blockette_offset: tells the function where the first blockette</span>
<span class="sd">    of the record is compared to the mseed_file_desc current position in the</span>
<span class="sd">    file. A positive value means the blockette is after the current position.</span>
<span class="sd">    :type blockette_number: int</span>
<span class="sd">    :param blockette_number: the blockette number to search for</span>
<span class="sd">    :type field_offset: int</span>
<span class="sd">    :param field_offset: how many bytes we have to skip before attaining the</span>
<span class="sd">    wanted field. Please note that it also counts blockette number and next</span>
<span class="sd">    blockette index&#39;s field.</span>
<span class="sd">    :type field_length: int</span>
<span class="sd">    :param field_length: length of the wanted field, in bytes</span>
<span class="sd">    :return: bytes containing the field&#39;s value in this record</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">previous_position</span> <span class="o">=</span> <span class="n">mseed_file_desc</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Go to first blockette</span>
        <span class="n">mseed_file_desc</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">first_blockette_offset</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_CUR</span><span class="p">)</span>
        <span class="n">mseed_record_start</span> <span class="o">=</span> <span class="n">mseed_file_desc</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">-</span> <span class="mi">48</span>
        <span class="n">read_data</span> <span class="o">=</span> <span class="n">mseed_file_desc</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># Read info in the first blockette</span>
        <span class="p">[</span><span class="n">cur_blkt_number</span><span class="p">,</span> <span class="n">next_blkt_offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s2">&quot;&gt;HH&quot;</span><span class="p">),</span>
                                                     <span class="n">read_data</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">cur_blkt_number</span> <span class="o">!=</span> <span class="n">blockette_number</span> \
                <span class="ow">and</span> <span class="n">next_blkt_offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Nothing here, read next blockette</span>
            <span class="n">mseed_file_desc</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">mseed_record_start</span> <span class="o">+</span> <span class="n">next_blkt_offset</span><span class="p">,</span>
                                 <span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">)</span>
            <span class="n">read_data</span> <span class="o">=</span> <span class="n">mseed_file_desc</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="p">[</span><span class="n">cur_blkt_number</span><span class="p">,</span> <span class="n">next_blkt_offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s2">&quot;&gt;HH&quot;</span><span class="p">),</span>
                                                         <span class="n">read_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cur_blkt_number</span> <span class="o">==</span> <span class="n">blockette_number</span><span class="p">:</span>
            <span class="c1"># Blockette found: we want to skip ``field_offset`` bytes but we</span>
            <span class="c1"># have already read 4 of the offset to get informations about the</span>
            <span class="c1"># current blockette, so we remove them from skipped data</span>
            <span class="n">mseed_file_desc</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">field_offset</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_CUR</span><span class="p">)</span>
            <span class="n">returned_bytes</span> <span class="o">=</span> <span class="n">mseed_file_desc</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">field_length</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">returned_bytes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">finally</span><span class="p">:</span>
        <span class="n">mseed_file_desc</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">previous_position</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">returned_bytes</span></div>


<div class="viewcode-block" id="_convert_flags_to_raw_byte"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._convert_flags_to_raw_byte.html#obspy.io.mseed.util._convert_flags_to_raw_byte">[docs]</a><span class="k">def</span> <span class="nf">_convert_flags_to_raw_byte</span><span class="p">(</span><span class="n">expected_flags</span><span class="p">,</span> <span class="n">user_flags</span><span class="p">,</span> <span class="n">recstart</span><span class="p">,</span> <span class="n">recend</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a flag dictionary to a byte, ready to be encoded in a MiniSEED</span>
<span class="sd">    header.</span>

<span class="sd">    This is a utility function for set_flags_in_fixed_headers and is not</span>
<span class="sd">    designed to be called by someone else.</span>

<span class="sd">    expected_signals describes all the possible bit names for the user flags</span>
<span class="sd">    and their place in the result byte. Expected: dict { exponent: bit_name }.</span>
<span class="sd">    The fixed header flags are available in obspy.io.mseed.headers as</span>
<span class="sd">    FIXED_HEADER_ACTIVITY_FLAGS, FIXED_HEADER_DATA_QUAL_FLAGS and</span>
<span class="sd">    FIXED_HEADER_IO_CLOCK_FLAGS.</span>

<span class="sd">    This expects a user_flags as a dictionary { bit_name : value }. bit_name is</span>
<span class="sd">    compared to the expected_signals, and its value is converted to bool.</span>
<span class="sd">    Missing values are considered false.</span>

<span class="sd">    :type expected_flags: dict {int: str}</span>
<span class="sd">    :param expected_flags: every possible flag in this field, with its offset</span>
<span class="sd">    :type user_flags: dict {str: bool}</span>
<span class="sd">    :param user_flags: user defined flags and its value</span>
<span class="sd">    :type recstart: UTCDateTime</span>
<span class="sd">    :param recstart: date of the first sample of the current record</span>
<span class="sd">    :type recstart: UTCDateTime</span>
<span class="sd">    :param recend: date of the last sample of the current record</span>
<span class="sd">    :return: raw int value for the flag group</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">flag_byte</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">expected_flags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">use_in_this_record</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">user_flags</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_flags</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">user_flags</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="c1"># Boolean value, we accept it for all records</span>
                <span class="n">use_in_this_record</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_flags</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
                <span class="c1"># List of tuples (start, end)</span>
                <span class="n">use_in_this_record</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">tuple_value</span> <span class="ow">in</span> <span class="n">user_flags</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="c1"># Check wether this record is concerned</span>
                    <span class="n">event_start</span> <span class="o">=</span> <span class="n">tuple_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">event_end</span> <span class="o">=</span> <span class="n">tuple_value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span><span class="p">(</span><span class="n">event_start</span> <span class="o">&lt;</span> <span class="n">recend</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">recstart</span> <span class="o">&lt;=</span> <span class="n">event_end</span><span class="p">):</span>
                        <span class="n">use_in_this_record</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

        <span class="k">if</span> <span class="n">use_in_this_record</span><span class="p">:</span>
            <span class="n">flag_byte</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">**</span><span class="n">bit</span>

    <span class="k">return</span> <span class="n">flag_byte</span></div>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;&#39;shiftTimeOfFile&#39; has been renamed to &quot;</span>
            <span class="s2">&quot;&#39;shift_time_of_file&#39;. Use that instead.&quot;</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="k">def</span> <span class="nf">shiftTimeOfFile</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">shift_time_of_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="shift_time_of_file"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util.shift_time_of_file.html#obspy.io.mseed.util.shift_time_of_file">[docs]</a><span class="k">def</span> <span class="nf">shift_time_of_file</span><span class="p">(</span><span class="n">input_file</span><span class="p">,</span> <span class="n">output_file</span><span class="p">,</span> <span class="n">timeshift</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a MiniSEED file and shifts the time of every record by the given</span>
<span class="sd">    amount.</span>

<span class="sd">    The same could be achieved by reading the MiniSEED file with ObsPy,</span>
<span class="sd">    modifying the starttime and writing it again. The problem with this</span>
<span class="sd">    approach is that some record specific flags and special blockettes might</span>
<span class="sd">    not be conserved. This function directly operates on the file and simply</span>
<span class="sd">    changes some header fields, not touching the rest, thus preserving it.</span>

<span class="sd">    Will only work correctly if all records have the same record length which</span>
<span class="sd">    usually should be the case.</span>

<span class="sd">    All times are in 0.0001 seconds, that is in 1/10000 seconds. NOT ms but one</span>
<span class="sd">    order of magnitude smaller! This is due to the way time corrections are</span>
<span class="sd">    stored in the MiniSEED format.</span>

<span class="sd">    :type input_file: str</span>
<span class="sd">    :param input_file: The input filename.</span>
<span class="sd">    :type output_file: str</span>
<span class="sd">    :param output_file: The output filename.</span>
<span class="sd">    :type timeshift: int</span>
<span class="sd">    :param timeshift: The time-shift to be applied in 0.0001, e.g. 1E-4</span>
<span class="sd">        seconds. Use an integer number.</span>

<span class="sd">    Please do NOT use identical input and output files because if something</span>
<span class="sd">    goes wrong, your data WILL be corrupted/destroyed. Also always check the</span>
<span class="sd">    resulting output file.</span>

<span class="sd">    .. rubric:: Technical details</span>

<span class="sd">    The function will loop over every record and change the &quot;Time correction&quot;</span>
<span class="sd">    field in the fixed section of the MiniSEED data header by the specified</span>
<span class="sd">    amount. Unfortunately a further flag (bit 1 in the &quot;Activity flags&quot; field)</span>
<span class="sd">    determines whether or not the time correction has already been applied to</span>
<span class="sd">    the record start time. If it has not, all is fine and changing the &quot;Time</span>
<span class="sd">    correction&quot; field is enough. Otherwise the actual time also needs to be</span>
<span class="sd">    changed.</span>

<span class="sd">    One further detail: If bit 1 in the &quot;Activity flags&quot; field is 1 (True) and</span>
<span class="sd">    the &quot;Time correction&quot; field is 0, then the bit will be set to 0 and only</span>
<span class="sd">    the time correction will be changed thus avoiding the need to change the</span>
<span class="sd">    record start time which is preferable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timeshift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">timeshift</span><span class="p">)</span>
    <span class="c1"># A timeshift of zero makes no sense.</span>
    <span class="k">if</span> <span class="n">timeshift</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The timeshift must to be not equal to 0.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Get the necessary information from the file.</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">get_record_information</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span>
    <span class="n">record_length</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;record_length&quot;</span><span class="p">]</span>

    <span class="n">byteorder</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;byteorder&quot;</span><span class="p">]</span>
    <span class="n">sys_byteorder</span> <span class="o">=</span> <span class="s2">&quot;&lt;&quot;</span> <span class="k">if</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s2">&quot;little&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&gt;&quot;</span>
    <span class="n">do_swap</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="p">(</span><span class="n">byteorder</span> <span class="o">==</span> <span class="n">sys_byteorder</span><span class="p">)</span> <span class="k">else</span> <span class="kc">True</span>

    <span class="c1"># This is in this scenario somewhat easier to use than BytesIO because one</span>
    <span class="c1"># can directly modify the data array.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">input_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">array_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">record_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Loop over every record.</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">remaining_bytes</span> <span class="o">=</span> <span class="n">array_length</span> <span class="o">-</span> <span class="n">record_offset</span>
        <span class="k">if</span> <span class="n">remaining_bytes</span> <span class="o">&lt;</span> <span class="mi">48</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">remaining_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> excessive byte(s) in the file. &quot;</span> <span class="o">%</span> <span class="n">remaining_bytes</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;They will be appended to the output file.&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="c1"># Use a slice for the current record.</span>
        <span class="n">current_record</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">record_offset</span><span class="p">:</span> <span class="n">record_offset</span> <span class="o">+</span> <span class="n">record_length</span><span class="p">]</span>
        <span class="n">record_offset</span> <span class="o">+=</span> <span class="n">record_length</span>

        <span class="n">activity_flags</span> <span class="o">=</span> <span class="n">current_record</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span>
        <span class="n">is_time_correction_applied</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">activity_flags</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">current_time_shift</span> <span class="o">=</span> <span class="n">current_record</span><span class="p">[</span><span class="mi">40</span><span class="p">:</span><span class="mi">44</span><span class="p">]</span>
        <span class="n">current_time_shift</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
        <span class="k">if</span> <span class="n">do_swap</span><span class="p">:</span>
            <span class="n">current_time_shift</span> <span class="o">=</span> <span class="n">current_time_shift</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">current_time_shift</span> <span class="o">=</span> <span class="n">current_time_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># If the time correction has been applied, but there is no actual</span>
        <span class="c1"># time correction, then simply set the time correction applied</span>
        <span class="c1"># field to false and process normally.</span>
        <span class="c1"># This should rarely be the case.</span>
        <span class="k">if</span> <span class="n">current_time_shift</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">is_time_correction_applied</span><span class="p">:</span>
            <span class="c1"># This sets bit 2 of the activity flags to 0.</span>
            <span class="n">current_record</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_record</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">is_time_correction_applied</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># This is the case if the time correction has been applied. This</span>
        <span class="c1"># requires some more work by changing both, the actual time and the</span>
        <span class="c1"># time correction field.</span>
        <span class="k">elif</span> <span class="n">is_time_correction_applied</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The timeshift can only be applied by actually changing the &quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;time. This is experimental. Please make sure the output &quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;file is correct.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># The whole process is not particularly fast or optimized but</span>
            <span class="c1"># instead intends to avoid errors.</span>
            <span class="c1"># Get the time variables.</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">current_record</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">30</span><span class="p">]</span>
            <span class="n">year</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">julday</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">hour</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">minute</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
            <span class="n">msecs</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
            <span class="c1"># Change dtype of multibyte values.</span>
            <span class="n">year</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span>
            <span class="n">julday</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span>
            <span class="n">msecs</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span>
            <span class="k">if</span> <span class="n">do_swap</span><span class="p">:</span>
                <span class="n">year</span> <span class="o">=</span> <span class="n">year</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">julday</span> <span class="o">=</span> <span class="n">julday</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">msecs</span> <span class="o">=</span> <span class="n">msecs</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">dtime</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">year</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">julday</span><span class="o">=</span><span class="n">julday</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hour</span><span class="o">=</span><span class="n">hour</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">minute</span><span class="o">=</span><span class="n">minute</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">second</span><span class="o">=</span><span class="n">second</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">microsecond</span><span class="o">=</span><span class="n">msecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">dtime</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">timeshift</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">)</span>
            <span class="n">year</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtime</span><span class="o">.</span><span class="n">year</span>
            <span class="n">julday</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtime</span><span class="o">.</span><span class="n">julday</span>
            <span class="n">hour</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtime</span><span class="o">.</span><span class="n">hour</span>
            <span class="n">minute</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtime</span><span class="o">.</span><span class="n">minute</span>
            <span class="n">second</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtime</span><span class="o">.</span><span class="n">second</span>
            <span class="n">msecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtime</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mi">100</span>
            <span class="c1"># Swap again.</span>
            <span class="k">if</span> <span class="n">do_swap</span><span class="p">:</span>
                <span class="n">year</span> <span class="o">=</span> <span class="n">year</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">julday</span> <span class="o">=</span> <span class="n">julday</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">msecs</span> <span class="o">=</span> <span class="n">msecs</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Change dtypes back.</span>
            <span class="n">year</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
            <span class="n">julday</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
            <span class="n">msecs</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
            <span class="c1"># Write to current record.</span>
            <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">year</span><span class="p">[:]</span>
            <span class="n">time</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">julday</span><span class="p">[:]</span>
            <span class="n">time</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">hour</span><span class="p">[:]</span>
            <span class="n">time</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">minute</span><span class="p">[:]</span>
            <span class="n">time</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">second</span><span class="p">[:]</span>
            <span class="n">time</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">msecs</span><span class="p">[:]</span>
            <span class="n">current_record</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">[:]</span>

        <span class="c1"># Now modify the time correction flag.</span>
        <span class="n">current_time_shift</span> <span class="o">+=</span> <span class="n">timeshift</span>
        <span class="n">current_time_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">current_time_shift</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_swap</span><span class="p">:</span>
            <span class="n">current_time_shift</span> <span class="o">=</span> <span class="n">current_time_shift</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">current_time_shift</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
        <span class="n">current_record</span><span class="p">[</span><span class="mi">40</span><span class="p">:</span><span class="mi">44</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_time_shift</span><span class="p">[:]</span>

    <span class="c1"># Write to the output file.</span>
    <span class="n">data</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="_convert_and_check_encoding_for_writing"><a class="viewcode-back" href="../../../../packages/autogen/obspy.io.mseed.util._convert_and_check_encoding_for_writing.html#obspy.io.mseed.util._convert_and_check_encoding_for_writing">[docs]</a><span class="k">def</span> <span class="nf">_convert_and_check_encoding_for_writing</span><span class="p">(</span><span class="n">encoding</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to handle and test encodings.</span>

<span class="sd">    If encoding is a string, it will be converted to the appropriate</span>
<span class="sd">    integer. It will furthermore be checked if the specified encoding can be</span>
<span class="sd">    written using libmseed. Appropriate errors will be raised if necessary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if encoding kwarg is set and catch invalid encodings.</span>
    <span class="n">encoding_strings</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ENCODINGS</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="ow">in</span> <span class="n">ENCODINGS</span> <span class="ow">and</span> <span class="n">ENCODINGS</span><span class="p">[</span><span class="n">encoding</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="n">encoding</span> <span class="ow">in</span> <span class="n">UNSUPPORTED_ENCODINGS</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Encoding </span><span class="si">%i</span><span class="s2"> cannot be written with ObsPy. Please &quot;</span>
                   <span class="s2">&quot;use another encoding.&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">encoding</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">encoding</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ENCODINGS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown encoding: </span><span class="si">%i</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">encoding</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">encoding_strings</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown encoding: &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">ENCODINGS</span><span class="p">[</span><span class="n">encoding_strings</span><span class="p">[</span><span class="n">encoding</span><span class="p">]][</span><span class="mi">3</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Encoding &#39;</span><span class="si">%s</span><span class="s2">&#39; cannot be written with ObsPy. Please &quot;</span>
                   <span class="s2">&quot;use another encoding.&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">encoding</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding_strings</span><span class="p">[</span><span class="n">encoding</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">encoding</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">exclude_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

</div>

<footer>
<p class="text-muted small">
By the <a href="https://github.com/orgs/obspy/people">ObsPy
Development Team</a> and many <a href="#contributers" role="button"
data-toggle="modal" data-target="#contributers">Awesome Contributors</a>™ &nbsp;|&nbsp; Built with
<a href="http://getbootstrap.com/">Bootstrap</a> and
<a href="http://glyphicons.com//">Glyphicons</a> &nbsp;|&nbsp; Copyright 2008-2016
</p>
</footer>
<div id="contributers" class="modal fade" tabindex="-1"
role="dialog" aria-labelledby="contributersLabel" aria-hidden="true">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<button type="button" class="close" data-dismiss="modal"
aria-hidden="true">&times;</button>
<h3 class="modal-title" id="contributersLabel">Thank you!</h3>
</div>
<div class="modal-body">
<p>We would like to thank our contributors, whose efforts make
this software what it is. These people have helped by writing code
and documentation, and by testing. They have created and
maintained this product, its associated libraries and
applications, our build tools and our web sites.</p>
<h4>Contributors</h4>
<div class="container-fluid">
<div class="row">
<div class="col-md-6">
<ul>
<li>Ammon, Charles J.</li>
<li>Arnarsson, Ólafur St.</li>
<li>Barsch, Robert</li>
<li>Bernardi, Fabrizio</li>
<li>Beyreuther, Moritz</li>
<li>Carothers, Lloyd</li>
<li>Egdorf, Sven</li>
<li>Ermert, Laura</li>
<li>Fabbri, Tommaso</li>
<li>Grunberg, Marc</li>
<li>Heimann, Sebastian</li>
<li>Hope, Gaute</li>
<li>Inza, Adolfo</li>
<li>Ketchum, David</li>
<li>Kremers, Simon</li>
<li>Krieger, Lars</li>
<li>Käufl, Paul</li>
<li>Lecocq, Thomas</li>
<li>Lesage, Philippe</li>
<li>Lopes, Rui L.</li>
<li>Maggi, Alessia</li>
<li>Megies, Tobias</li>
<li>Michelini, Alberto</li>
<li>Morgenstern, Bernhard</li>
<li>Panning, Mark P.</li>
<li>Reyes, Celso</li>
<li>Rothenhäusler, Nicolas</li>
<li>Sales de Andrade, Elliott</li>
<li>Saul, Joachim</li>
<li>Sippl, Christian</li>
<li>Stange, Stefan</li>
<li>Trabant, Chad</li>
<li>Walker, Andrew</li>
<li>Wassermann, Joachim</li>
<li>Winkelman, Andrew</li>
<li>van Driel, Martin</li>
</ul>
</div>
<div class="col-md-6">
<ul>
<li>Antunes, Emanuel</li>
<li>Bank, Markus</li>
<li>Behr, Yannik</li>
<li>Bernauer, Felix</li>
<li>Bonaimé, Sébastien</li>
<li>Danecek, Peter</li>
<li>Engels, Fabian</li>
<li>Eulenfeld, Tom</li>
<li>Grellier, Clément</li>
<li>Hammer, Conny</li>
<li>Heiniger, Lukas</li>
<li>Igel, Heiner</li>
<li>Isken, Marius</li>
<li>Koymans, Mathijs</li>
<li>Kress, Victor</li>
<li>Krischer, Lion</li>
<li>Köhler, Andreas</li>
<li>Leeman, John</li>
<li>Lomax, Anthony</li>
<li>MacCarthy, Jonathan</li>
<li>Martin, Henri</li>
<li>Meschede, Matthias</li>
<li>Miller, Nathaniel C.</li>
<li>Nof, Ran Novitsky</li>
<li>Rapagnani, Giovanni</li>
<li>Ringler, Adam</li>
<li>Russo, Emiliano</li>
<li>Satriano, Claudio</li>
<li>Scheingraber, Chris</li>
<li>Snoke, Arthur</li>
<li>Sullivan, Benjamin</li>
<li>Uieda, Leonardo</li>
<li>Walther, Marcus</li>
<li>Williams, Mark C.</li>
<li>Zad, Seyed Kasra Hosseini</li>
</ul>
</div>
</div>
</div>
<h4>Funds</h4>
<p>ObsPy was partially funded by the</p>
<ul>
<li>German Science Foundation (DFG) via grant DFG IG 16/9-1</li>
<li>German Ministry for Education and Research (BMBF), GEOTECHNOLOGIEN grant 03G0646H.</li>
<li>NERA project (Network of European Research Infrastructures for Earthquake Risk Assessment and Mitigation) under the European Community&#39;s Seventh Framework Programme (FP7/2007-2013) grant agreement n° 262330</li>
<li>Leibniz Institute for Applied Geophysics (LIAG)</li>
<li>VERCE EU-FP7 project (no. 283543)</li>
</ul>
</div>
<div class="modal-footer">
<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
</div>
</div>
</div>
</div>

</div>


  </body>
</html>