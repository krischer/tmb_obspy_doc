<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>obspy.core.stream &#8212; ObsPy Documentation (1.0.3)</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/font.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/base.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript">
  var shiftWindow = function() { scrollBy(0, -70) };
  if (location.hash) shiftWindow();
  window.addEventListener("hashchange", shiftWindow);
</script>

  </head>
  <body>
<div id="wrapper">
<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
<div class="container-fluid">
<div class="navbar-header">
<button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a href="/" class="navbar-brand" title="Home"><span class="icon-obspy"></span>&nbsp;ObsPy</a>
</div>
<div class="navbar-collapse collapse">
<form class="navbar-form navbar-right" role="search" method="get" action="search.html">
<div class="form-group">
<input type="text" class="form-control" placeholder="Search Docs" name="q">
</div>
</form>
<ul class="nav navbar-nav navbar-right">
<li><a href="https://github.com/obspy/obspy/" title="GitHub"><span class="icon-github iconx2"></span><span class="hidden-sm">&nbsp;GitHub</span></a></li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Documentation"><span class="glyphicon glyphicon-book iconx2"></span><span class="hidden-sm">&nbsp;Documentation</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Getting&nbsp;Started</li>
<li><a href="https://github.com/obspy/obspy/wiki#installation">Installation</a></li>
<li><a href="https://tutorial.obspy.org/">Tutorial</a></li>
<li><a href="http://gallery.obspy.org/">Gallery</a></li>
<li><a href="https://docs.obspy.org/">API&nbsp;Documentation&nbsp;(latest&nbsp;release)</a></li>
<li><a href="https://docs.obspy.org/master/">API&nbsp;Documentation&nbsp;(current&nbsp;master)</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Mailing&nbsp;Lists"><span class="glyphicon glyphicon-envelope iconx2"></span><span class="hidden-sm">&nbsp;Mailing&nbsp;Lists</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Announcements&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-announcements"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-announcements/"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archive</a></li>
<li class="divider"></li>
<li class="dropdown-header">Users&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-users"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-users"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archives</a></li>
<li><a href="mailto:users@obspy.org"><span class="glyphicon glyphicon-envelope"></span>&nbsp;Post&nbsp;a&nbsp;message</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Developer&nbsp;Resources"><span class="glyphicon glyphicon-cog iconx2"></span><span class="hidden-sm">&nbsp;Developer&nbsp;Resources</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li><a href="https://gitter.im/obspy/obspy">Gitter</a></li>
<li><a href="https://github.com/obspy/obspy/blob/master/.github/CONTRIBUTING.md">How&nbsp;to&nbsp;contribute</a></li>
<li><a href="http://docs.obspy.org/coding_style.html">Coding&nbsp;Style&nbsp;Guide</a></li>
<li><a href="https://github.com/obspy/obspy/releases/">All&nbsp;Releases</a></li>
<li class="divider"></li>
<li class="dropdown-header">Code&nbsp;Analysis</li>
<li><a href="http://docs.obspy.org/master/pep8/index.html">PEP8</a></li>
<li><a href="http://docs.obspy.org/master/coverage/index.html">Python&nbsp;Coverage</a></li>
<li><a href="http://docs.obspy.org/master/c_coverage/index.html">C&nbsp;Coverage</a></li>
<li><a href="https://coveralls.io/r/obspy/obspy?branch=master">Coveralls</a></li>
<li class="divider"></li>
<li class="dropdown-header">Continuous&nbsp;Integration</li>
<li><a href="http://tests.obspy.org/">Test&nbsp;Reports</a></li>
<li><a href="https://travis-ci.org/obspy/obspy/"><span class="icon-travis"></span>&nbsp;Travis&nbsp;CI</a></li>
<li><a href="https://ci.appveyor.com/project/obspy/obspy"><span class="icon-appveyor"></span>&nbsp;AppVeyor</a></li>
</ul>
</li>
</ul>
</div>
</div>
</nav>

<div id="content" class="container">
  
    <div class="breadcrumb pull-right"><a href="../../../genindex.html" title="General Index"
         accesskey="I">index</a><span style="color: #ccc; padding: 0 5px;">| </span><a href="../../../py-modindex.html" title="Python Module Index"
         >modules</a>
    </div>
    <ol class="breadcrumb">
        <li><a href="../../../contents.html">ObsPy Documentation (1.0.3)</a></li>
        <li><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ol>
  
  <h1>Source code for obspy.core.stream</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for handling ObsPy Stream objects.</span>

<span class="sd">:copyright:</span>
<span class="sd">    The ObsPy Development Team (devs@obspy.org)</span>
<span class="sd">:license:</span>
<span class="sd">    GNU Lesser General Public License, Version 3</span>
<span class="sd">    (https://www.gnu.org/copyleft/lesser.html)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">future.builtins</span> <span class="k">import</span> <span class="o">*</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">future.utils</span> <span class="k">import</span> <span class="n">native_str</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="k">import</span> <span class="n">glob</span><span class="p">,</span> <span class="n">has_magic</span>

<span class="kn">from</span> <span class="nn">pkg_resources</span> <span class="k">import</span> <span class="n">load_entry_point</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">obspy.core</span> <span class="k">import</span> <span class="n">compatibility</span>
<span class="kn">from</span> <span class="nn">obspy.core.trace</span> <span class="k">import</span> <span class="n">Trace</span>
<span class="kn">from</span> <span class="nn">obspy.core.utcdatetime</span> <span class="k">import</span> <span class="n">UTCDateTime</span>
<span class="kn">from</span> <span class="nn">obspy.core.util</span> <span class="k">import</span> <span class="n">NamedTemporaryFile</span>
<span class="kn">from</span> <span class="nn">obspy.core.util.base</span> <span class="k">import</span> <span class="p">(</span><span class="n">ENTRY_POINTS</span><span class="p">,</span> <span class="n">_get_function_from_entry_point</span><span class="p">,</span>
                                  <span class="n">_read_from_plugin</span><span class="p">,</span> <span class="n">download_to_file</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">obspy.core.util.decorator</span> <span class="k">import</span> <span class="p">(</span><span class="n">deprecated</span><span class="p">,</span> <span class="n">map_example_filename</span><span class="p">,</span>
                                       <span class="n">raise_if_masked</span><span class="p">,</span> <span class="n">uncompress_file</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">obspy.core.util.misc</span> <span class="k">import</span> <span class="n">get_window_times</span>


<span class="n">_headonly_warning_msg</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;Keyword headonly cannot be combined with starttime, endtime or dtype.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="read"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.read.html#obspy.core.stream.read">[docs]</a><span class="nd">@map_example_filename</span><span class="p">(</span><span class="s2">&quot;pathname_or_url&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">pathname_or_url</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">headonly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">apply_calib</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read waveform files into an ObsPy Stream object.</span>

<span class="sd">    The :func:`~obspy.core.stream.read` function opens either one or multiple</span>
<span class="sd">    waveform files given via file name or URL using the ``pathname_or_url``</span>
<span class="sd">    attribute.</span>

<span class="sd">    The format of the waveform file will be automatically detected if not</span>
<span class="sd">    given. See the `Supported Formats`_ section below for available formats.</span>

<span class="sd">    This function returns an ObsPy :class:`~obspy.core.stream.Stream` object, a</span>
<span class="sd">    ``list``-like object of multiple ObsPy :class:`~obspy.core.trace.Trace`</span>
<span class="sd">    objects.</span>

<span class="sd">    :type pathname_or_url: str or io.BytesIO, optional</span>
<span class="sd">    :param pathname_or_url: String containing a file name or a URL or a open</span>
<span class="sd">        file-like object. Wildcards are allowed for a file name. If this</span>
<span class="sd">        attribute is omitted, an example :class:`~obspy.core.stream.Stream`</span>
<span class="sd">        object will be returned.</span>
<span class="sd">    :type format: str, optional</span>
<span class="sd">    :param format: Format of the file to read (e.g. ``&quot;MSEED&quot;``). See</span>
<span class="sd">        the `Supported Formats`_ section below for a list of supported formats.</span>
<span class="sd">        If format is set to ``None`` it will be automatically detected which</span>
<span class="sd">        results in a slightly slower reading. If a format is specified, no</span>
<span class="sd">        further format checking is done.</span>
<span class="sd">    :type headonly: bool, optional</span>
<span class="sd">    :param headonly: If set to ``True``, read only the data header. This is</span>
<span class="sd">        most useful for scanning available meta information of huge data sets.</span>
<span class="sd">    :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime`, optional</span>
<span class="sd">    :param starttime: Specify the start time to read.</span>
<span class="sd">    :type endtime: :class:`~obspy.core.utcdatetime.UTCDateTime`, optional</span>
<span class="sd">    :param endtime: Specify the end time to read.</span>
<span class="sd">    :type nearest_sample: bool, optional</span>
<span class="sd">    :param nearest_sample: Only applied if `starttime` or `endtime` is given.</span>
<span class="sd">        Select nearest sample or the one containing the specified time. For</span>
<span class="sd">        more info, see :meth:`~obspy.core.trace.Trace.trim`.</span>
<span class="sd">    :type dtype: :class:`numpy.dtype`, optional</span>
<span class="sd">    :param dtype: Convert data of all traces into given numpy.dtype.</span>
<span class="sd">    :type apply_calib: bool, optional</span>
<span class="sd">    :param apply_calib: Automatically applies the calibration factor</span>
<span class="sd">        ``trace.stats.calib`` for each trace, if set. Defaults to ``False``.</span>
<span class="sd">    :param kwargs: Additional keyword arguments passed to the underlying</span>
<span class="sd">        waveform reader method.</span>
<span class="sd">    :return: An ObsPy :class:`~obspy.core.stream.Stream` object.</span>

<span class="sd">    .. rubric:: Basic Usage</span>

<span class="sd">    In most cases a filename is specified as the only argument to</span>
<span class="sd">    :func:`~obspy.core.stream.read`. For a quick start you may omit all</span>
<span class="sd">    arguments and ObsPy will create and return a basic example seismogram.</span>
<span class="sd">    Further usages of the :func:`~obspy.core.stream.read` function can</span>
<span class="sd">    be seen in the `Further Examples`_ section underneath.</span>

<span class="sd">    &gt;&gt;&gt; from obspy import read</span>
<span class="sd">    &gt;&gt;&gt; st = read()</span>
<span class="sd">    &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">    3 Trace(s) in Stream:</span>
<span class="sd">    BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">    BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">    BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z - ... | 100.0 Hz, 3000 samples</span>

<span class="sd">    .. rubric:: _`Supported Formats`</span>

<span class="sd">    Additional ObsPy modules extend the functionality of the</span>
<span class="sd">    :func:`~obspy.core.stream.read` function. The following table summarizes</span>
<span class="sd">    all known file formats currently supported by ObsPy. The table order also</span>
<span class="sd">    reflects the order of the autodetection routine if no format option is</span>
<span class="sd">    specified.</span>

<span class="sd">    Please refer to the `Linked Function Call`_ of each module for any extra</span>
<span class="sd">    options available at the import stage.</span>

<span class="sd">    %s</span>

<span class="sd">    Next to the :func:`~obspy.core.stream.read` function the</span>
<span class="sd">    :meth:`~obspy.core.stream.Stream.write` method of the returned</span>
<span class="sd">    :class:`~obspy.core.stream.Stream` object can be used to export the data</span>
<span class="sd">    to the file system.</span>

<span class="sd">    .. rubric:: _`Further Examples`</span>

<span class="sd">    Example waveform files may be retrieved via https://examples.obspy.org.</span>

<span class="sd">    (1) Reading multiple local files using wildcards.</span>

<span class="sd">        The following code uses wildcards, in this case it matches two files.</span>
<span class="sd">        Both files are then read into a single</span>
<span class="sd">        :class:`~obspy.core.stream.Stream` object.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; st = read(&quot;/path/to/loc_R*.z&quot;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +SKIP</span>
<span class="sd">        2 Trace(s) in Stream:</span>
<span class="sd">        .RJOB..Z | 2005-08-31T02:33:49.850000Z - ... | 200.0 Hz, 12000 samples</span>
<span class="sd">        .RNON..Z | 2004-06-09T20:05:59.850000Z - ... | 200.0 Hz, 12000 samples</span>

<span class="sd">    (2) Reading a local file without format detection.</span>

<span class="sd">        Using the ``format`` parameter disables the automatic detection and</span>
<span class="sd">        enforces reading a file in a given format.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read(&quot;/path/to/loc_RJOB20050831023349.z&quot;, format=&quot;GSE2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        1 Trace(s) in Stream:</span>
<span class="sd">        .RJOB..Z | 2005-08-31T02:33:49.850000Z - ... | 200.0 Hz, 12000 samples</span>

<span class="sd">    (3) Reading a remote file via HTTP protocol.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read(&quot;https://examples.obspy.org/loc_RJOB20050831023349.z&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        1 Trace(s) in Stream:</span>
<span class="sd">        .RJOB..Z | 2005-08-31T02:33:49.850000Z - ... | 200.0 Hz, 12000 samples</span>

<span class="sd">    (4) Reading a compressed files.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read(&quot;/path/to/tspair.ascii.gz&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        1 Trace(s) in Stream:</span>
<span class="sd">        XX.TEST..BHZ | 2008-01-15T00:00:00.025000Z - ... | 40.0 Hz, 635 samples</span>

<span class="sd">        &gt;&gt;&gt; st = read(&quot;https://examples.obspy.org/slist.ascii.bz2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        1 Trace(s) in Stream:</span>
<span class="sd">        XX.TEST..BHZ | 2008-01-15T00:00:00.025000Z - ... | 40.0 Hz, 635 samples</span>

<span class="sd">    (5) Reading a file-like object.</span>

<span class="sd">        &gt;&gt;&gt; import requests</span>
<span class="sd">        &gt;&gt;&gt; import io</span>
<span class="sd">        &gt;&gt;&gt; example_url = &quot;https://examples.obspy.org/loc_RJOB20050831023349.z&quot;</span>
<span class="sd">        &gt;&gt;&gt; stringio_obj = io.BytesIO(requests.get(example_url).content)</span>
<span class="sd">        &gt;&gt;&gt; st = read(stringio_obj)</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        1 Trace(s) in Stream:</span>
<span class="sd">        .RJOB..Z | 2005-08-31T02:33:49.850000Z - ... | 200.0 Hz, 12000 samples</span>

<span class="sd">    (6) Using &#39;starttime&#39; and &#39;endtime&#39; parameters</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; dt = UTCDateTime(&quot;2005-08-31T02:34:00&quot;)</span>
<span class="sd">        &gt;&gt;&gt; st = read(&quot;https://examples.obspy.org/loc_RJOB20050831023349.z&quot;,</span>
<span class="sd">        ...           starttime=dt, endtime=dt+10)</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        1 Trace(s) in Stream:</span>
<span class="sd">        .RJOB..Z | 2005-08-31T02:34:00.000000Z - ... | 200.0 Hz, 2001 samples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># add default parameters to kwargs so sub-modules may handle them</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;starttime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">starttime</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;endtime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endtime</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nearest_sample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest_sample</span>
    <span class="c1"># create stream</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">pathname_or_url</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># if no pathname or URL specified, return example stream</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">_create_example_stream</span><span class="p">(</span><span class="n">headonly</span><span class="o">=</span><span class="n">headonly</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pathname_or_url</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">native_str</span><span class="p">)):</span>
        <span class="c1"># not a string - we assume a file-like object</span>
        <span class="n">pathname_or_url</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># first try reading directly</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">_read</span><span class="p">(</span><span class="n">pathname_or_url</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">headonly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">st</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># if this fails, create a temporary file which is read directly</span>
            <span class="c1"># from the file system</span>
            <span class="n">pathname_or_url</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">NamedTemporaryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pathname_or_url</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
                <span class="n">st</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_read</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">headonly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span>
        <span class="n">pathname_or_url</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;://&quot;</span> <span class="ow">in</span> <span class="n">pathname_or_url</span><span class="p">:</span>
        <span class="c1"># some URL</span>
        <span class="c1"># extract extension if any</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">pathname_or_url</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="s1">&#39;.tmp&#39;</span>
        <span class="k">with</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">download_to_file</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">pathname_or_url</span><span class="p">,</span> <span class="n">filename_or_buffer</span><span class="o">=</span><span class="n">fh</span><span class="p">)</span>
            <span class="n">st</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_read</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">headonly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># some file name</span>
        <span class="n">pathname</span> <span class="o">=</span> <span class="n">pathname_or_url</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="n">pathname</span><span class="p">)):</span>
            <span class="n">st</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">headonly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># try to give more specific information why the stream is empty</span>
            <span class="k">if</span> <span class="n">has_magic</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">glob</span><span class="p">(</span><span class="n">pathname</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No file matching file pattern: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">pathname</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">has_magic</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">pathname</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;No such file or directory&quot;</span><span class="p">,</span> <span class="n">pathname</span><span class="p">)</span>
            <span class="c1"># Only raise error if no start/end time has been set. This</span>
            <span class="c1"># will return an empty stream if the user chose a time window with</span>
            <span class="c1"># no data in it.</span>
            <span class="c1"># XXX: Might cause problems if the data is faulty and the user</span>
            <span class="c1"># set start/end time. Not sure what to do in this case.</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">starttime</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">endtime</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot open file/files: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">pathname</span><span class="p">)</span>
    <span class="c1"># Trim if times are given.</span>
    <span class="k">if</span> <span class="n">headonly</span> <span class="ow">and</span> <span class="p">(</span><span class="n">starttime</span> <span class="ow">or</span> <span class="n">endtime</span> <span class="ow">or</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">_headonly_warning_msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">st</span>
    <span class="k">if</span> <span class="n">starttime</span><span class="p">:</span>
        <span class="n">st</span><span class="o">.</span><span class="n">_ltrim</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">endtime</span><span class="p">:</span>
        <span class="n">st</span><span class="o">.</span><span class="n">_rtrim</span><span class="p">(</span><span class="n">endtime</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">)</span>
    <span class="c1"># convert to dtype if given</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="c1"># For compatibility with NumPy 1.4</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">native_str</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># applies calibration factor</span>
    <span class="k">if</span> <span class="n">apply_calib</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">calib</span>
    <span class="k">return</span> <span class="n">st</span></div>


<div class="viewcode-block" id="_read"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream._read.html#obspy.core.stream._read">[docs]</a><span class="nd">@uncompress_file</span>
<span class="k">def</span> <span class="nf">_read</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">headonly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read a single file into a ObsPy Stream object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stream</span><span class="p">,</span> <span class="nb">format</span> <span class="o">=</span> <span class="n">_read_from_plugin</span><span class="p">(</span><span class="s1">&#39;waveform&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
                                       <span class="n">headonly</span><span class="o">=</span><span class="n">headonly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># set _format identifier for each element</span>
    <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">_format</span> <span class="o">=</span> <span class="nb">format</span>
    <span class="k">return</span> <span class="n">stream</span></div>


<div class="viewcode-block" id="_create_example_stream"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream._create_example_stream.html#obspy.core.stream._create_example_stream">[docs]</a><span class="k">def</span> <span class="nf">_create_example_stream</span><span class="p">(</span><span class="n">headonly</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an example stream.</span>

<span class="sd">    Data arrays are stored in NumPy&#39;s NPZ format. The header information are</span>
<span class="sd">    fixed values.</span>

<span class="sd">    PAZ of the used instrument, needed to demonstrate simulate_seismometer()</span>
<span class="sd">    etc.::</span>

<span class="sd">        paz = {&#39;gain&#39;: 60077000.0,</span>
<span class="sd">               &#39;poles&#39;: [-0.037004+0.037016j, -0.037004-0.037016j, -251.33+0j,</span>
<span class="sd">                         -131.04-467.29j, -131.04+467.29j],</span>
<span class="sd">               &#39;sensitivity&#39;: 2516778400.0,</span>
<span class="sd">               &#39;zeros&#39;: [0j, 0j]}}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s2">&quot;data&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">headonly</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s2">&quot;example.npz&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;EHZ&quot;</span><span class="p">,</span> <span class="s2">&quot;EHN&quot;</span><span class="p">,</span> <span class="s2">&quot;EHE&quot;</span><span class="p">]:</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;network&#39;</span><span class="p">:</span> <span class="s2">&quot;BW&quot;</span><span class="p">,</span>
                  <span class="s1">&#39;station&#39;</span><span class="p">:</span> <span class="s2">&quot;RJOB&quot;</span><span class="p">,</span>
                  <span class="s1">&#39;location&#39;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                  <span class="s1">&#39;npts&#39;</span><span class="p">:</span> <span class="mi">3000</span><span class="p">,</span>
                  <span class="s1">&#39;starttime&#39;</span><span class="p">:</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                  <span class="s1">&#39;sampling_rate&#39;</span><span class="p">:</span> <span class="mf">100.0</span><span class="p">,</span>
                  <span class="s1">&#39;calib&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                  <span class="s1">&#39;back_azimuth&#39;</span><span class="p">:</span> <span class="mf">100.0</span><span class="p">,</span>
                  <span class="s1">&#39;inclination&#39;</span><span class="p">:</span> <span class="mf">30.0</span><span class="p">}</span>
        <span class="n">header</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">headonly</span><span class="p">:</span>
            <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Trace</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">channel</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Trace</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">))</span>
    <span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">read_inventory</span>
    <span class="n">inv</span> <span class="o">=</span> <span class="n">read_inventory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s2">&quot;BW_RJOB.xml&quot;</span><span class="p">))</span>
    <span class="n">st</span><span class="o">.</span><span class="n">attach_response</span><span class="p">(</span><span class="n">inv</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">st</span></div>


<div class="viewcode-block" id="Stream"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.html#obspy.core.stream.Stream">[docs]</a><span class="k">class</span> <span class="nc">Stream</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List like object of multiple ObsPy Trace objects.</span>

<span class="sd">    :type traces: list of :class:`~obspy.core.trace.Trace`, optional</span>
<span class="sd">    :param traces: Initial list of ObsPy :class:`~obspy.core.trace.Trace`</span>
<span class="sd">        objects.</span>

<span class="sd">    .. rubric:: Basic Usage</span>

<span class="sd">    &gt;&gt;&gt; trace1 = Trace()</span>
<span class="sd">    &gt;&gt;&gt; trace2 = Trace()</span>
<span class="sd">    &gt;&gt;&gt; stream = Stream(traces=[trace1, trace2])</span>
<span class="sd">    &gt;&gt;&gt; print(stream)  # doctest: +ELLIPSIS</span>
<span class="sd">    2 Trace(s) in Stream:</span>
<span class="sd">    ...</span>

<span class="sd">    .. rubric:: Supported Operations</span>

<span class="sd">    ``stream = streamA + streamB``</span>
<span class="sd">        Merges all traces within the two Stream objects ``streamA`` and</span>
<span class="sd">        ``streamB`` into the new Stream object ``stream``.</span>
<span class="sd">        See also: :meth:`Stream.__add__`.</span>
<span class="sd">    ``stream += streamA``</span>
<span class="sd">        Extends the Stream object ``stream`` with all traces from ``streamA``.</span>
<span class="sd">        See also: :meth:`Stream.__iadd__`.</span>
<span class="sd">    ``len(stream)``</span>
<span class="sd">        Returns the number of Traces in the Stream object ``stream``.</span>
<span class="sd">        See also: :meth:`Stream.__len__`.</span>
<span class="sd">    ``str(stream)``</span>
<span class="sd">        Contains the number of traces in the Stream object and returns the</span>
<span class="sd">        value of each Trace&#39;s __str__ method.</span>
<span class="sd">        See also: :meth:`Stream.__str__`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Stream.__init__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__init__.html#obspy.core.stream.Stream.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">traces</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">traces</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">traces</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.__add__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__add__.html#obspy.core.stream.Stream.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two streams or a stream with a single trace.</span>

<span class="sd">        :type other: :class:`~obspy.core.stream.Stream` or</span>
<span class="sd">            :class:`~obspy.core.trace.Trace`</span>
<span class="sd">        :param other: Stream or Trace object to add.</span>
<span class="sd">        :rtype: :class:`~obspy.core.stream.Stream`</span>
<span class="sd">        :returns: New Stream object containing references to the traces of the</span>
<span class="sd">            original streams</span>

<span class="sd">        .. rubric:: Examples</span>

<span class="sd">        1. Adding two Streams</span>

<span class="sd">            &gt;&gt;&gt; st1 = Stream([Trace(), Trace(), Trace()])</span>
<span class="sd">            &gt;&gt;&gt; len(st1)</span>
<span class="sd">            3</span>
<span class="sd">            &gt;&gt;&gt; st2 = Stream([Trace(), Trace()])</span>
<span class="sd">            &gt;&gt;&gt; len(st2)</span>
<span class="sd">            2</span>
<span class="sd">            &gt;&gt;&gt; stream = st1 + st2</span>
<span class="sd">            &gt;&gt;&gt; len(stream)</span>
<span class="sd">            5</span>

<span class="sd">        2. Adding Stream and Trace</span>

<span class="sd">            &gt;&gt;&gt; stream2 = st1 + Trace()</span>
<span class="sd">            &gt;&gt;&gt; len(stream2)</span>
<span class="sd">            4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">([</span><span class="n">other</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Stream</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">traces</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">traces</span><span class="o">=</span><span class="n">traces</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.__iadd__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__iadd__.html#obspy.core.stream.Stream.__iadd__">[docs]</a>    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two streams with self += other.</span>

<span class="sd">        It will extend the current Stream object with the traces of the given</span>
<span class="sd">        Stream. Traces will not be copied but references to the original traces</span>
<span class="sd">        will be appended.</span>

<span class="sd">        :type other: :class:`~obspy.core.stream.Stream` or</span>
<span class="sd">            :class:`~obspy.core.trace.Trace`</span>
<span class="sd">        :param other: Stream or Trace object to add.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; stream = Stream([Trace(), Trace(), Trace()])</span>
<span class="sd">        &gt;&gt;&gt; len(stream)</span>
<span class="sd">        3</span>

<span class="sd">        &gt;&gt;&gt; stream += Stream([Trace(), Trace()])</span>
<span class="sd">        &gt;&gt;&gt; len(stream)</span>
<span class="sd">        5</span>

<span class="sd">        &gt;&gt;&gt; stream += Trace()</span>
<span class="sd">        &gt;&gt;&gt; len(stream)</span>
<span class="sd">        6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">([</span><span class="n">other</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Stream</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.__mul__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__mul__.html#obspy.core.stream.Stream.__mul__">[docs]</a>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Stream containing num copies of this stream.</span>

<span class="sd">        :rtype num: int</span>
<span class="sd">        :param num: Number of copies.</span>
<span class="sd">        :returns: New ObsPy Stream object.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; len(st)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; st2 = st * 5</span>
<span class="sd">        &gt;&gt;&gt; len(st2)</span>
<span class="sd">        15</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Integer expected&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">Stream</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">st</span></div>

<div class="viewcode-block" id="Stream.__iter__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__iter__.html#obspy.core.stream.Stream.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a robust iterator for stream.traces.</span>

<span class="sd">        Doing this it is safe to remove traces from streams inside of</span>
<span class="sd">        for-loops using stream&#39;s :meth:`~obspy.core.stream.Stream.remove`</span>
<span class="sd">        method. Actually this creates a new iterator every time a trace is</span>
<span class="sd">        removed inside the for-loop.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import Stream</span>
<span class="sd">        &gt;&gt;&gt; st = Stream()</span>
<span class="sd">        &gt;&gt;&gt; for component in [&quot;1&quot;, &quot;Z&quot;, &quot;2&quot;, &quot;3&quot;, &quot;Z&quot;, &quot;N&quot;, &quot;E&quot;, &quot;4&quot;, &quot;5&quot;]:</span>
<span class="sd">        ...     channel = &quot;EH&quot; + component</span>
<span class="sd">        ...     tr = Trace(header={&#39;station&#39;: &#39;TEST&#39;, &#39;channel&#39;: channel})</span>
<span class="sd">        ...     st.append(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        9 Trace(s) in Stream:</span>
<span class="sd">        .TEST..EH1 | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EHZ | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EH2 | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EH3 | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EHZ | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EHN | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EHE | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EH4 | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EH5 | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>

<span class="sd">        &gt;&gt;&gt; for tr in st:</span>
<span class="sd">        ...     if tr.stats.channel[-1] not in [&quot;Z&quot;, &quot;N&quot;, &quot;E&quot;]:</span>
<span class="sd">        ...         st.remove(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        4 Trace(s) in Stream:</span>
<span class="sd">        .TEST..EHZ | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EHZ | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EHN | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST..EHE | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span></div>

<div class="viewcode-block" id="Stream.__nonzero__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__nonzero__.html#obspy.core.stream.Stream.__nonzero__">[docs]</a>    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Stream is considered zero if has no Traces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">))</span></div>

<div class="viewcode-block" id="Stream.__len__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__len__.html#obspy.core.stream.Stream.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of Traces in the Stream object.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; stream = Stream([Trace(), Trace(), Trace()])</span>
<span class="sd">        &gt;&gt;&gt; len(stream)</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span></div>

    <span class="n">count</span> <span class="o">=</span> <span class="fm">__len__</span>

<div class="viewcode-block" id="Stream.__str__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__str__.html#obspy.core.stream.Stream.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extended</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return short summary string of the current stream.</span>

<span class="sd">        It will contain the number of Traces in the Stream and the return value</span>
<span class="sd">        of each Trace&#39;s :meth:`~obspy.core.trace.Trace.__str__` method.</span>

<span class="sd">        :type extended: bool, optional</span>
<span class="sd">        :param extended: This method will show only 20 traces by default.</span>
<span class="sd">            Enable this option to show all entries.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; stream = Stream([Trace(), Trace()])</span>
<span class="sd">        &gt;&gt;&gt; print(stream)  # doctest: +ELLIPSIS</span>
<span class="sd">        2 Trace(s) in Stream:</span>
<span class="sd">        ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get longest id</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="n">id_length</span> <span class="o">=</span> <span class="bp">self</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">id_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; Trace(s) in Stream:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">20</span> <span class="ow">or</span> <span class="n">extended</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_i</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(</span><span class="n">id_length</span><span class="p">)</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
                <span class="s1">&#39;...</span><span class="se">\n</span><span class="s1">(</span><span class="si">%i</span><span class="s1"> other traces)</span><span class="se">\n</span><span class="s1">...</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">[Use &quot;print(&#39;</span> <span class="o">+</span> \
                <span class="s1">&#39;Stream.__str__(extended=True))&quot; to print all Traces]&#39;</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Stream._repr_pretty_"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream._repr_pretty_.html#obspy.core.stream.Stream._repr_pretty_">[docs]</a>    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">verbose</span><span class="p">))</span></div>

<div class="viewcode-block" id="Stream.__eq__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__eq__.html#obspy.core.stream.Stream.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements rich comparison of Stream objects for &quot;==&quot; operator.</span>

<span class="sd">        :type other: :class:`~obspy.core.stream.Stream`</span>
<span class="sd">        :param other: Stream object for comparison.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :return: ``True`` if both Streams contain the same traces, i.e. after a</span>
<span class="sd">            sort operation going through both streams every trace should be</span>
<span class="sd">            equal according to Trace&#39;s</span>
<span class="sd">            :meth:`~obspy.core.trace.Trace.__eq__` operator.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; st2 = st.copy()</span>
<span class="sd">        &gt;&gt;&gt; st is st2</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; st == st2</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Stream</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># this is maybe still not 100% satisfactory, the question here is if</span>
        <span class="c1"># two streams should be the same in comparison if one of the streams</span>
        <span class="c1"># has a duplicate trace. Using sets at the moment, two equal traces</span>
        <span class="c1"># in one of the Streams would lead to two non-equal Streams.</span>
        <span class="c1"># This is a bit more conservative and most likely the expected behavior</span>
        <span class="c1"># in most cases.</span>
        <span class="n">self_sorted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="n">self_sorted</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">other_sorted</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="n">other_sorted</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">self_sorted</span><span class="o">.</span><span class="n">traces</span> <span class="o">!=</span> <span class="n">other_sorted</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Stream.__ne__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__ne__.html#obspy.core.stream.Stream.__ne__">[docs]</a>    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements rich comparison of Stream objects for &quot;!=&quot; operator.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; st2 = st.copy()</span>
<span class="sd">        &gt;&gt;&gt; st is st2</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; st != st2</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calls __eq__() and returns the opposite.</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.__lt__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__lt__.html#obspy.core.stream.Stream.__lt__">[docs]</a>    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Too ambiguous, throw an Error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Too ambiguous, therefore not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.__le__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__le__.html#obspy.core.stream.Stream.__le__">[docs]</a>    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Too ambiguous, throw an Error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Too ambiguous, therefore not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.__gt__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__gt__.html#obspy.core.stream.Stream.__gt__">[docs]</a>    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Too ambiguous, throw an Error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Too ambiguous, therefore not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.__ge__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__ge__.html#obspy.core.stream.Stream.__ge__">[docs]</a>    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Too ambiguous, throw an Error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Too ambiguous, therefore not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.__setitem__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__setitem__.html#obspy.core.stream.Stream.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __setitem__ method of obspy.Stream objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">trace</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.__getitem__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__getitem__.html#obspy.core.stream.Stream.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __getitem__ method of obspy.Stream objects.</span>

<span class="sd">        :return: Trace objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">traces</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.__delitem__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__delitem__.html#obspy.core.stream.Stream.__delitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Passes on the __delitem__ method to the underlying list of traces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.__getslice__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.__getslice__.html#obspy.core.stream.Stream.__getslice__">[docs]</a>    <span class="k">def</span> <span class="nf">__getslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __getslice__ method of obspy.Stream objects.</span>

<span class="sd">        :return: Stream object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># see also https://docs.python.org/3/reference/datamodel.html</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">traces</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span><span class="n">k</span><span class="p">])</span></div>

<div class="viewcode-block" id="Stream.append"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.append.html#obspy.core.stream.Stream.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a single Trace object to the current Stream object.</span>

<span class="sd">        :param trace: :class:`~obspy.core.stream.Trace` object.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, Trace</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; tr = Trace()</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.station = &#39;TEST&#39;</span>
<span class="sd">        &gt;&gt;&gt; st.append(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        4 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        .TEST..      | 1970-01-01T00:00:00.000000Z ... | 1.0 Hz, 0 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Append only supports a single Trace object as an argument.&#39;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.extend"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.extend.html#obspy.core.stream.Stream.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend the current Stream object with a list of Trace objects.</span>

<span class="sd">        :param trace_list: list of :class:`~obspy.core.trace.Trace` objects or</span>
<span class="sd">            :class:`~obspy.core.stream.Stream`.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, Trace</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; tr1 = Trace()</span>
<span class="sd">        &gt;&gt;&gt; tr1.stats.station = &#39;TEST1&#39;</span>
<span class="sd">        &gt;&gt;&gt; tr2 = Trace()</span>
<span class="sd">        &gt;&gt;&gt; tr2.stats.station = &#39;TEST2&#39;</span>
<span class="sd">        &gt;&gt;&gt; st.extend([tr1, tr2])  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        5 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        .TEST1..     | 1970-01-01T00:00:00.000000Z ... | 1.0 Hz, 0 samples</span>
<span class="sd">        .TEST2..     | 1970-01-01T00:00:00.000000Z ... | 1.0 Hz, 0 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">trace_list</span><span class="p">:</span>
                <span class="c1"># Make sure each item in the list is a trace.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_i</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Extend only accepts a list of Trace objects.&#39;</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">trace_list</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace_list</span><span class="p">,</span> <span class="n">Stream</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">trace_list</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Extend only supports a list of Trace objects as argument.&#39;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;&#39;getGaps&#39; has been renamed to &quot;</span>  <span class="c1"># noqa</span>
        <span class="s2">&quot;&#39;get_gaps&#39;. Use that instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getGaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        DEPRECATED: &#39;getGaps&#39; has been renamed to</span>
<span class="sd">        &#39;get_gaps&#39;. Use that instead.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gaps</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Stream.get_gaps"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.get_gaps.html#obspy.core.stream.Stream.get_gaps">[docs]</a>    <span class="k">def</span> <span class="nf">get_gaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_gap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_gap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine all trace gaps/overlaps of the Stream object.</span>

<span class="sd">        :param min_gap: All gaps smaller than this value will be omitted. The</span>
<span class="sd">            value is assumed to be in seconds. Defaults to None.</span>
<span class="sd">        :param max_gap: All gaps larger than this value will be omitted. The</span>
<span class="sd">            value is assumed to be in seconds. Defaults to None.</span>

<span class="sd">        The returned list contains one item in the following form for each gap/</span>
<span class="sd">        overlap: [network, station, location, channel, starttime of the gap,</span>
<span class="sd">        end time of the gap, duration of the gap, number of missing samples]</span>

<span class="sd">        Please be aware that no sorting and checking of stations, channels, ...</span>
<span class="sd">        is done. This method only compares the start and end times of the</span>
<span class="sd">        Traces.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        Our example stream has no gaps:</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, UTCDateTime</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; st.get_gaps()</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; st.print_gaps()  # doctest: +ELLIPSIS</span>
<span class="sd">        Source            Last Sample                 ...</span>
<span class="sd">        Total: 0 gap(s) and 0 overlap(s)</span>

<span class="sd">        So let&#39;s make a copy of the first trace and cut both so that we end up</span>
<span class="sd">        with a gappy stream:</span>

<span class="sd">        &gt;&gt;&gt; tr = st[0].copy()</span>
<span class="sd">        &gt;&gt;&gt; t = UTCDateTime(&quot;2009-08-24T00:20:13.0&quot;)</span>
<span class="sd">        &gt;&gt;&gt; st[0].trim(endtime=t)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.trim(starttime=t + 1)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.append(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.get_gaps()[0]  # doctest: +SKIP</span>
<span class="sd">        [[&#39;BW&#39;, &#39;RJOB&#39;, &#39;&#39;, &#39;EHZ&#39;, UTCDateTime(2009, 8, 24, 0, 20, 13),</span>
<span class="sd">          UTCDateTime(2009, 8, 24, 0, 20, 14), 1.0, 99]]</span>
<span class="sd">        &gt;&gt;&gt; st.print_gaps()  # doctest: +ELLIPSIS</span>
<span class="sd">        Source            Last Sample                 ...</span>
<span class="sd">        BW.RJOB..EHZ      2009-08-24T00:20:13.000000Z ...</span>
<span class="sd">        Total: 1 gap(s) and 0 overlap(s)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create shallow copy of the traces to be able to sort them later on.</span>
        <span class="n">copied_traces</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">gap_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># skip traces with different network, station, location or channel</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># different sampling rates should always result in a gap or overlap</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="n">same_sampling_rate</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">same_sampling_rate</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span>
            <span class="n">stime</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;endtime&#39;</span><span class="p">]</span>
            <span class="n">etime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;starttime&#39;</span><span class="p">]</span>
            <span class="c1"># last sample of earlier trace represents data up to time of last</span>
            <span class="c1"># sample (stats.endtime) plus one delta</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">etime</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">-</span> <span class="p">(</span><span class="n">stime</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">+</span> <span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
            <span class="c1"># Check that any overlap is not larger than the trace coverage</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;endtime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">-</span> \
                    <span class="n">etime</span><span class="o">.</span><span class="n">timestamp</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">temp</span>
            <span class="c1"># Check gap/overlap criteria</span>
            <span class="k">if</span> <span class="n">min_gap</span> <span class="ow">and</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">min_gap</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">max_gap</span> <span class="ow">and</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="n">max_gap</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Number of missing samples</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">compatibility</span><span class="o">.</span><span class="n">round_away</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">*</span>
                                                    <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;sampling_rate&#39;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nsamples</span> <span class="o">=</span> <span class="o">-</span><span class="n">nsamples</span>
            <span class="c1"># skip if is equal to delta (1 / sampling rate)</span>
            <span class="k">if</span> <span class="n">same_sampling_rate</span> <span class="ow">and</span> <span class="n">nsamples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">gap_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;station&#39;</span><span class="p">],</span>
                             <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">],</span>
                             <span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">])</span>
        <span class="c1"># Set the original traces to not alter the stream object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="n">copied_traces</span>
        <span class="k">return</span> <span class="n">gap_list</span></div>

<div class="viewcode-block" id="Stream.insert"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.insert.html#obspy.core.stream.Stream.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert either a single Trace or a list of Traces before index.</span>

<span class="sd">        :param position: The Trace will be inserted at position.</span>
<span class="sd">        :param object: Single Trace object or list of Trace objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># Make sure each item in the list is a trace.</span>
            <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">object</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_i</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Trace object or a list of Trace objects expected!&#39;</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># Insert each item of the list.</span>
            <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">object</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">position</span> <span class="o">+</span> <span class="n">_i</span><span class="p">,</span> <span class="nb">object</span><span class="p">[</span><span class="n">_i</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">Stream</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="nb">object</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Only accepts a Trace object or a list of Trace objects.&#39;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.plot"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.plot.html#obspy.core.stream.Stream.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a waveform plot of the current ObsPy Stream object.</span>

<span class="sd">        :param outfile: Output file string. Also used to automatically</span>
<span class="sd">            determine the output format. Supported file formats depend on your</span>
<span class="sd">            matplotlib backend. Most backends support png, pdf, ps, eps and</span>
<span class="sd">            svg. Defaults to ``None``.</span>
<span class="sd">        :param format: Format of the graph picture. If no format is given the</span>
<span class="sd">            outfile parameter will be used to try to automatically determine</span>
<span class="sd">            the output format. If no format is found it defaults to png output.</span>
<span class="sd">            If no outfile is specified but a format is, than a binary</span>
<span class="sd">            imagestring will be returned.</span>
<span class="sd">            Defaults to ``None``.</span>
<span class="sd">        :param starttime: Start time of the graph as a</span>
<span class="sd">            :class:`~obspy.core.utcdatetime.UTCDateTime` object. If not set</span>
<span class="sd">            the graph will be plotted from the beginning.</span>
<span class="sd">            Defaults to ``None``.</span>
<span class="sd">        :param endtime: End time of the graph as a</span>
<span class="sd">            :class:`~obspy.core.utcdatetime.UTCDateTime` object. If not set</span>
<span class="sd">            the graph will be plotted until the end.</span>
<span class="sd">            Defaults to ``None``.</span>
<span class="sd">        :param fig: Use an existing matplotlib figure instance.</span>
<span class="sd">            Defaults to ``None``.</span>
<span class="sd">        :param automerge: If automerge is True, Traces with the same id will be</span>
<span class="sd">            merged.</span>
<span class="sd">            Defaults to ``True``.</span>
<span class="sd">        :param size: Size tuple in pixel for the output file. This corresponds</span>
<span class="sd">            to the resolution of the graph for vector formats.</span>
<span class="sd">            Defaults to ``(800, 250)`` pixel per channel for ``type=&#39;normal&#39;``</span>
<span class="sd">            or ``type=&#39;relative&#39;``, ``(800, 600)`` for ``type=&#39;dayplot&#39;``, and</span>
<span class="sd">            ``(1000, 600)`` for ``type=&#39;section&#39;``.</span>
<span class="sd">        :param dpi: Dots per inch of the output file. This also affects the</span>
<span class="sd">            size of most elements in the graph (text, linewidth, ...).</span>
<span class="sd">            Defaults to ``100``.</span>
<span class="sd">        :param color: Color of the graph as a matplotlib color string as</span>
<span class="sd">            described below. If ``type=&#39;dayplot&#39;`` a list/tuple of color</span>
<span class="sd">            strings is expected that will be periodically repeated for each</span>
<span class="sd">            line plotted. If ``type=&#39;section&#39;`` then the values ``&#39;network&#39;``,</span>
<span class="sd">            ``&#39;station&#39;`` or ``&#39;channel&#39;`` are also accepted, and traces will</span>
<span class="sd">            be uniquely colored by the given information.</span>
<span class="sd">            Defaults to ``&#39;black&#39;`` or to ``(&#39;#B2000F&#39;, &#39;#004C12&#39;, &#39;#847200&#39;,</span>
<span class="sd">            &#39;#0E01FF&#39;)`` for ``type=&#39;dayplot&#39;``.</span>
<span class="sd">        :param bgcolor: Background color of the graph.</span>
<span class="sd">            Defaults to ``&#39;white&#39;``.</span>
<span class="sd">        :param face_color: Face color of the matplotlib canvas.</span>
<span class="sd">            Defaults to ``&#39;white&#39;``.</span>
<span class="sd">        :param transparent: Make all backgrounds transparent (True/False). This</span>
<span class="sd">            will override the ``bgcolor`` and ``face_color`` arguments.</span>
<span class="sd">            Defaults to ``False``.</span>
<span class="sd">        :param number_of_ticks: The number of ticks on the x-axis.</span>
<span class="sd">            Defaults to ``4``.</span>
<span class="sd">        :param tick_format: The way the time axis is formatted.</span>
<span class="sd">            Defaults to ``&#39;%H:%M:%S&#39;`` or ``&#39;%.2f&#39;`` if ``type=&#39;relative&#39;``.</span>
<span class="sd">        :param tick_rotation: Tick rotation in degrees.</span>
<span class="sd">            Defaults to ``0``.</span>
<span class="sd">        :param handle: Whether or not to return the matplotlib figure instance</span>
<span class="sd">            after the plot has been created.</span>
<span class="sd">            Defaults to ``False``.</span>
<span class="sd">        :param method: By default, all traces with more than 400,000 samples</span>
<span class="sd">            will be plotted with a fast method that cannot be zoomed.</span>
<span class="sd">            Setting this argument to ``&#39;full&#39;`` will straight up plot the data.</span>
<span class="sd">            This results in a potentially worse performance but the interactive</span>
<span class="sd">            matplotlib view can be used properly.</span>
<span class="sd">            Defaults to &#39;fast&#39;.</span>
<span class="sd">        :param type: Type may be set to either: ``&#39;normal&#39;`` to produce the</span>
<span class="sd">            standard plot; ``&#39;dayplot&#39;`` to create a one-day plot for a single</span>
<span class="sd">            Trace; ``&#39;relative&#39;`` to convert all date/time information to a</span>
<span class="sd">            relative scale starting the seismogram at 0 seconds; ``&#39;section&#39;``</span>
<span class="sd">            to plot all seismograms in a single coordinate system shifted</span>
<span class="sd">            according to their distance from a reference point. Defaults to</span>
<span class="sd">            ``&#39;normal&#39;``.</span>
<span class="sd">        :param equal_scale: If enabled all plots are equally scaled.</span>
<span class="sd">            Defaults to ``True``.</span>
<span class="sd">        :param show: If True, show the plot interactively after plotting. This</span>
<span class="sd">            is ignored if any of ``outfile``, ``format``, ``handle``, or</span>
<span class="sd">            ``fig`` are specified.</span>
<span class="sd">            Defaults to ``True``.</span>
<span class="sd">        :param draw: If True, the figure canvas is explicitly re-drawn, which</span>
<span class="sd">            ensures that *existing* figures are fresh. It makes no difference</span>
<span class="sd">            for figures that are not yet visible.</span>
<span class="sd">            Defaults to ``True``.</span>
<span class="sd">        :param block: If True block call to showing plot. Only works if the</span>
<span class="sd">            active matplotlib backend supports it.</span>
<span class="sd">            Defaults to ``True``.</span>
<span class="sd">        :param linewidth: Float value in points of the line width.</span>
<span class="sd">            Defaults to ``1.0``.</span>
<span class="sd">        :param linestyle: Line style.</span>
<span class="sd">            Defaults to ``&#39;-&#39;``</span>
<span class="sd">        :param grid_color: Color of the grid.</span>
<span class="sd">            Defaults to ``&#39;black&#39;``.</span>
<span class="sd">        :param grid_linewidth: Float value in points of the grid line width.</span>
<span class="sd">            Defaults to ``0.5``.</span>
<span class="sd">        :param grid_linestyle: Grid line style.</span>
<span class="sd">            Defaults to ``&#39;:&#39;``</span>

<span class="sd">        **Dayplot Parameters**</span>

<span class="sd">        The following parameters are only available if ``type=&#39;dayplot&#39;`` is</span>
<span class="sd">        set.</span>

<span class="sd">        :param vertical_scaling_range: Determines how each line is scaled in</span>
<span class="sd">            its given space. Every line will be centered around its mean value</span>
<span class="sd">            and then clamped to fit its given space. This argument is the range</span>
<span class="sd">            in data units that will be used to clamp the data. If the range is</span>
<span class="sd">            smaller than the actual range, the lines&#39; data may overshoot to</span>
<span class="sd">            other lines which is usually a desired effect. Larger ranges will</span>
<span class="sd">            result in a vertical padding.</span>
<span class="sd">            If ``0``, the actual range of the data will be used and no</span>
<span class="sd">            overshooting or additional padding will occur.</span>
<span class="sd">            If ``None`` the range will be chosen to be the 99.5-percentile of</span>
<span class="sd">            the actual range - so some values will overshoot.</span>
<span class="sd">            Defaults to ``None``.</span>
<span class="sd">        :param interval: This defines the interval length in minutes for one</span>
<span class="sd">            line.</span>
<span class="sd">            Defaults to ``15``.</span>
<span class="sd">        :param time_offset: Only used if ``type=&#39;dayplot&#39;``. The difference</span>
<span class="sd">            between the timezone of the data (specified with the kwarg</span>
<span class="sd">            ``timezone``) and UTC time in hours. Will be displayed in a string.</span>
<span class="sd">            Defaults to the current offset of the system time to UTC time.</span>
<span class="sd">        :param timezone: Defines the name of the user defined time scale. Will</span>
<span class="sd">            be displayed in a string together with the actual offset defined in</span>
<span class="sd">            the kwarg ``time_offset``.</span>
<span class="sd">            Defaults to ``&#39;local time&#39;``.</span>
<span class="sd">        :param localization_dict: Enables limited localization of the dayplot</span>
<span class="sd">            through the usage of a dictionary. To change the labels to, e.g.</span>
<span class="sd">            German, use the following::</span>

<span class="sd">                localization_dict={&#39;time in&#39;: &#39;Zeit in&#39;, &#39;seconds&#39;: &#39;Sekunden&#39;,</span>
<span class="sd">                                   &#39;minutes&#39;: &#39;Minuten&#39;, &#39;hours&#39;: &#39;Stunden&#39;}</span>

<span class="sd">        :param data_unit: If given, the scale of the data will be drawn on the</span>
<span class="sd">            right hand side in the form ``&quot;%f {data_unit}&quot;``. The unit is</span>
<span class="sd">            supposed to be a string containing the actual unit of the data. Can</span>
<span class="sd">            be a LaTeX expression if matplotlib has been built with LaTeX</span>
<span class="sd">            support, e.g., ``&quot;$\\\\frac{m}{s}$&quot;``. Be careful to escape the</span>
<span class="sd">            backslashes, or use r-prefixed strings, e.g.,</span>
<span class="sd">            ``r&quot;$\\\\frac{m}{s}$&quot;``.</span>
<span class="sd">            Defaults to ``None``, meaning no scale is drawn.</span>
<span class="sd">        :param events: An optional list of events can be drawn on the plot if</span>
<span class="sd">            given.  They will be displayed as yellow stars with optional</span>
<span class="sd">            annotations.  They are given as a list of dictionaries. Each</span>
<span class="sd">            dictionary at least needs to have a &quot;time&quot; key, containing a</span>
<span class="sd">            UTCDateTime object with the origin time of the event. Furthermore</span>
<span class="sd">            every event can have an optional &quot;text&quot; key which will then be</span>
<span class="sd">            displayed as an annotation.</span>
<span class="sd">            Example::</span>

<span class="sd">                events=[{&quot;time&quot;: UTCDateTime(...), &quot;text&quot;: &quot;Event A&quot;}, {...}]</span>

<span class="sd">            It can also be a :class:`~obspy.core.event.Catalog` object. In this</span>
<span class="sd">            case each event will be annotated with its corresponding</span>
<span class="sd">            Flinn-Engdahl region and the magnitude.</span>
<span class="sd">            Events can also be automatically downloaded with the help of</span>
<span class="sd">            obspy.clients.fdsn. Just pass a dictionary with a &quot;min_magnitude&quot;</span>
<span class="sd">            key, e.g. ::</span>

<span class="sd">                events={&quot;min_magnitude&quot;: 5.5}</span>

<span class="sd">            Defaults to ``[]``.</span>
<span class="sd">        :param x_labels_size: Size of x labels in points or fontsize.</span>
<span class="sd">            Defaults to ``8``.</span>
<span class="sd">        :param y_labels_size: Size of y labels in points or fontsize.</span>
<span class="sd">            Defaults to ``8``.</span>
<span class="sd">        :param title_size: Size of the title in points or fontsize.</span>
<span class="sd">            Defaults to ``10``.</span>
<span class="sd">        :param subplots_adjust_left: The left side of the subplots of the</span>
<span class="sd">            figure in fraction of the figure width.</span>
<span class="sd">            Defaults to ``0.12``.</span>
<span class="sd">        :param subplots_adjust_right: The right side of the subplots of the</span>
<span class="sd">            figure in fraction of the figure width.</span>
<span class="sd">            Defaults to ``0.88``.</span>
<span class="sd">        :param subplots_adjust_top: The top side of the subplots of the figure</span>
<span class="sd">            in fraction of the figure width.</span>
<span class="sd">            Defaults to ``0.95``.</span>
<span class="sd">        :param subplots_adjust_bottom: The bottom side of the subplots of the</span>
<span class="sd">            figure in fraction of the figure width.</span>
<span class="sd">            Defaults to ``0.1``.</span>
<span class="sd">        :param right_vertical_labels: Whether or not to display labels on the</span>
<span class="sd">            right side of the dayplot.</span>
<span class="sd">            Defaults to ``False``.</span>
<span class="sd">        :param one_tick_per_line: Whether or not to display one tick per line.</span>
<span class="sd">            Defaults to ``False``.</span>
<span class="sd">        :param show_y_UTC_label: Whether or not to display the Y UTC vertical</span>
<span class="sd">            label.</span>
<span class="sd">            Defaults to ``True``.</span>
<span class="sd">        :param title: The title to display on top of the plot.</span>
<span class="sd">            Defaults to ``self.stream[0].id``.</span>

<span class="sd">        **Section Parameters**</span>

<span class="sd">        These parameters are only available if ``type=&#39;section&#39;`` is set. To</span>
<span class="sd">        plot a record section the ObsPy header ``trace.stats.distance`` must be</span>
<span class="sd">        defined in meters (Default). Or ``trace.stats.coordinates.latitude`` &amp;</span>
<span class="sd">        ``trace.stats.coordinates.longitude`` must be set if plotted in</span>
<span class="sd">        azimuthal distances (``dist_degree=True``) along with ``ev_coord``.</span>

<span class="sd">        :type scale: float, optional</span>
<span class="sd">        :param scale: Scale the traces width with this factor.</span>
<span class="sd">            Defaults to ``1.0``.</span>
<span class="sd">        :type vred: float, optional</span>
<span class="sd">        :param vred: Perform velocity reduction, in m/s.</span>
<span class="sd">        :type norm_method: str, optional</span>
<span class="sd">        :param norm_method: Defines how the traces are normalized, either</span>
<span class="sd">            against each ``trace`` or against the global maximum ``stream``.</span>
<span class="sd">            Defaults to ``trace``.</span>
<span class="sd">        :type offset_min: float or None, optional</span>
<span class="sd">        :param offset_min: Minimum offset in meters to plot.</span>
<span class="sd">            Defaults to minimum offset of all traces.</span>
<span class="sd">        :type offset_max: float or None, optional</span>
<span class="sd">        :param offset_max: Maximum offset in meters to plot.</span>
<span class="sd">            Defaults to maximum offset of all traces.</span>
<span class="sd">        :type dist_degree: bool, optional</span>
<span class="sd">        :param dist_degree: Plot trace distance in degree from epicenter. If</span>
<span class="sd">            ``True``, parameter ``ev_coord`` has to be defined.</span>
<span class="sd">            Defaults to ``False``.</span>
<span class="sd">        :type ev_coord: tuple or None, optional</span>
<span class="sd">        :param ev_coord: Event&#39;s coordinates as tuple</span>
<span class="sd">            ``(latitude, longitude)``.</span>
<span class="sd">        :type plot_dx: int, optional</span>
<span class="sd">        :param plot_dx: Spacing of ticks on the spatial x-axis.</span>
<span class="sd">            Either m or degree, depending on ``dist_degree``.</span>
<span class="sd">        :type recordstart: int or float, optional</span>
<span class="sd">        :param recordstart: Seconds to crop from the beginning.</span>
<span class="sd">        :type recordlength: int or float, optional</span>
<span class="sd">        :param recordlength: Length of the record section in seconds.</span>
<span class="sd">        :type alpha: float, optional</span>
<span class="sd">        :param alpha: Transparency of the traces between 0.0 - 1.0.</span>
<span class="sd">            Defaults to ``0.5``.</span>
<span class="sd">        :type time_down: bool, optional</span>
<span class="sd">        :param time_down: Flip the plot horizontally, time goes down.</span>
<span class="sd">            Defaults to ``False``, i.e., time goes up.</span>
<span class="sd">        :type reftime: :class:`~obspy.core.utcdatetime.UTCDateTime`, optional</span>
<span class="sd">        :param reftime: The reference time to which the time scale will refer.</span>
<span class="sd">            Defaults to the minimum start time of the visible traces.</span>
<span class="sd">        :type orientation: str, optional</span>
<span class="sd">        :param orientation: The orientation of the time axis, either</span>
<span class="sd">            ``&#39;vertical&#39;`` or ``&#39;horizontal&#39;``. Defaults to ``&#39;vertical&#39;``.</span>

<span class="sd">        **Relative Parameters**</span>

<span class="sd">        The following parameters are only available if ``type=&#39;relative&#39;`` is</span>
<span class="sd">        set.</span>

<span class="sd">        :type reftime: :class:`~obspy.core.utcdatetime.UTCDateTime`, optional</span>
<span class="sd">        :param reftime: The reference time to which the relative scale will</span>
<span class="sd">            refer.</span>
<span class="sd">            Defaults to ``starttime``.</span>

<span class="sd">        .. rubric:: Color Options</span>

<span class="sd">        Colors can be specified as defined in the :mod:`matplotlib.colors`</span>
<span class="sd">        documentation.</span>

<span class="sd">        Short Version: For all color values, you can either use:</span>

<span class="sd">        * legal `HTML color names &lt;https://www.w3.org/TR/css3-color/#html4&gt;`_,</span>
<span class="sd">          e.g. ``&#39;blue&#39;``,</span>
<span class="sd">        * HTML hex strings, e.g. ``&#39;#EE00FF&#39;``,</span>
<span class="sd">        * pass an string of a R, G, B tuple, where each of the components is a</span>
<span class="sd">          float value in the range of 0 to 1, e.g. ``&#39;(1, 0.25, 0.5)&#39;``, or</span>
<span class="sd">        * use single letters for the basic built-in colors, such as ``&#39;b&#39;``</span>
<span class="sd">          (blue), ``&#39;g&#39;`` (green), ``&#39;r&#39;`` (red), ``&#39;c&#39;`` (cyan), ``&#39;m&#39;``</span>
<span class="sd">          (magenta), ``&#39;y&#39;`` (yellow), ``&#39;k&#39;`` (black), ``&#39;w&#39;`` (white).</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; st.plot()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read</span>
<span class="sd">            st = read()</span>
<span class="sd">            st.plot()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">obspy.imaging.waveform</span> <span class="k">import</span> <span class="n">WaveformPlotting</span>
        <span class="n">waveform</span> <span class="o">=</span> <span class="n">WaveformPlotting</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">waveform</span><span class="o">.</span><span class="n">plot_waveform</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.spectrogram"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.spectrogram.html#obspy.core.stream.Stream.spectrogram">[docs]</a>    <span class="k">def</span> <span class="nf">spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a spectrogram plot for each trace in the stream.</span>

<span class="sd">        For details on kwargs that can be used to customize the spectrogram</span>
<span class="sd">        plot see :func:`obspy.imaging.spectrogram.spectrogram`.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; st[0].spectrogram()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read</span>
<span class="sd">            st = read()</span>
<span class="sd">            st[0].spectrogram()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">spec_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec_list</span></div>

<div class="viewcode-block" id="Stream.pop"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.pop.html#obspy.core.stream.Stream.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove and return the Trace object specified by index from the Stream.</span>

<span class="sd">        If no index is given, remove the last Trace. Passes on the pop() to</span>
<span class="sd">        self.traces.</span>

<span class="sd">        :param index: Index of the Trace object to be returned and removed.</span>
<span class="sd">        :returns: Removed Trace.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; tr = st.pop()</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        2 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; print(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;&#39;printGaps&#39; has been renamed to &quot;</span>  <span class="c1"># noqa</span>
        <span class="s2">&quot;&#39;print_gaps&#39;. Use that instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">printGaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        DEPRECATED: &#39;printGaps&#39; has been renamed to</span>
<span class="sd">        &#39;print_gaps&#39;. Use that instead.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_gaps</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Stream.print_gaps"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.print_gaps.html#obspy.core.stream.Stream.print_gaps">[docs]</a>    <span class="k">def</span> <span class="nf">print_gaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_gap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_gap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print gap/overlap list summary information of the Stream object.</span>

<span class="sd">        :param min_gap: All gaps smaller than this value will be omitted. The</span>
<span class="sd">            value is assumed to be in seconds. Defaults to None.</span>
<span class="sd">        :param max_gap: All gaps larger than this value will be omitted. The</span>
<span class="sd">            value is assumed to be in seconds. Defaults to None.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        Our example stream has no gaps:</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, UTCDateTime</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; st.get_gaps()</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; st.print_gaps()  # doctest: +ELLIPSIS</span>
<span class="sd">        Source            Last Sample                 Next Sample ...</span>
<span class="sd">        Total: 0 gap(s) and 0 overlap(s)</span>

<span class="sd">        So let&#39;s make a copy of the first trace and cut both so that we end up</span>
<span class="sd">        with a gappy stream:</span>

<span class="sd">        &gt;&gt;&gt; tr = st[0].copy()</span>
<span class="sd">        &gt;&gt;&gt; t = UTCDateTime(&quot;2009-08-24T00:20:13.0&quot;)</span>
<span class="sd">        &gt;&gt;&gt; st[0].trim(endtime=t)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.trim(starttime=t+1)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.append(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.get_gaps()  # doctest: +ELLIPSIS</span>
<span class="sd">        [[..., UTCDateTime(2009, 8, 24, 0, 20, 13), ...</span>
<span class="sd">        &gt;&gt;&gt; st.print_gaps()  # doctest: +ELLIPSIS</span>
<span class="sd">        Source            Last Sample                 ...</span>
<span class="sd">        BW.RJOB..EHZ      2009-08-24T00:20:13.000000Z ...</span>
<span class="sd">        Total: 1 gap(s) and 0 overlap(s)</span>


<span class="sd">        And finally let us create some overlapping traces:</span>

<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; tr = st[0].copy()</span>
<span class="sd">        &gt;&gt;&gt; t = UTCDateTime(&quot;2009-08-24T00:20:13.0&quot;)</span>
<span class="sd">        &gt;&gt;&gt; st[0].trim(endtime=t)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.trim(starttime=t-1)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.append(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.get_gaps()  # doctest: +ELLIPSIS</span>
<span class="sd">        [[...&#39;EHZ&#39;, UTCDateTime(2009, 8, 24, 0, 20, 13), ...</span>
<span class="sd">        &gt;&gt;&gt; st.print_gaps()  # doctest: +ELLIPSIS</span>
<span class="sd">        Source            Last Sample                 ...</span>
<span class="sd">        BW.RJOB..EHZ      2009-08-24T00:20:13.000000Z ...</span>
<span class="sd">        Total: 0 gap(s) and 1 overlap(s)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gaps</span><span class="p">(</span><span class="n">min_gap</span><span class="p">,</span> <span class="n">max_gap</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%-17s</span><span class="s2"> </span><span class="si">%-27s</span><span class="s2"> </span><span class="si">%-27s</span><span class="s2"> </span><span class="si">%-15s</span><span class="s2"> </span><span class="si">%-8s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;Source&#39;</span><span class="p">,</span> <span class="s1">&#39;Last Sample&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;Next Sample&#39;</span><span class="p">,</span> <span class="s1">&#39;Delta&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;Samples&#39;</span><span class="p">))</span>
        <span class="n">gaps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">overlaps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gaps</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">overlaps</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%-17s</span><span class="s2"> </span><span class="si">%-27s</span><span class="s2"> </span><span class="si">%-27s</span><span class="s2"> </span><span class="si">%-15.6f</span><span class="s2"> </span><span class="si">%-8d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]),</span>
                                                      <span class="n">r</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">7</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total: </span><span class="si">%d</span><span class="s2"> gap(s) and </span><span class="si">%d</span><span class="s2"> overlap(s)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gaps</span><span class="p">,</span> <span class="n">overlaps</span><span class="p">))</span></div>

<div class="viewcode-block" id="Stream.remove"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.remove.html#obspy.core.stream.Stream.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the first occurrence of the specified Trace object in the</span>
<span class="sd">        Stream object. Passes on the remove() call to self.traces.</span>

<span class="sd">        :param trace: Trace object to be removed from Stream.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        This example shows how to delete all &quot;E&quot; component traces in a stream:</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; for tr in st.select(component=&quot;E&quot;):</span>
<span class="sd">        ...     st.remove(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        2 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.reverse"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.reverse.html#obspy.core.stream.Stream.reverse">[docs]</a>    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse the Traces of the Stream object in place.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; st.reverse()  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.sort"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.sort.html#obspy.core.stream.Stream.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">,</span> <span class="s1">&#39;station&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="s1">&#39;channel&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;starttime&#39;</span><span class="p">,</span> <span class="s1">&#39;endtime&#39;</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the traces in the Stream object.</span>

<span class="sd">        The traces will be sorted according to the keys list. It will be sorted</span>
<span class="sd">        by the first item first, then by the second and so on. It will always</span>
<span class="sd">        be sorted from low to high and from A to Z.</span>

<span class="sd">        :type keys: list, optional</span>
<span class="sd">        :param keys: List containing the values according to which the traces</span>
<span class="sd">             will be sorted. They will be sorted by the first item first and</span>
<span class="sd">             then by the second item and so on.</span>
<span class="sd">             Always available items: &#39;network&#39;, &#39;station&#39;, &#39;channel&#39;,</span>
<span class="sd">             &#39;location&#39;, &#39;starttime&#39;, &#39;endtime&#39;, &#39;sampling_rate&#39;, &#39;npts&#39;,</span>
<span class="sd">             &#39;dataquality&#39;</span>
<span class="sd">             Defaults to [&#39;network&#39;, &#39;station&#39;, &#39;location&#39;, &#39;channel&#39;,</span>
<span class="sd">             &#39;starttime&#39;, &#39;endtime&#39;].</span>
<span class="sd">        :type reverse: bool</span>
<span class="sd">        :param reverse: Reverts sorting order to descending.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; st.sort()  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if list</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;keys must be a list of strings. Always available items to &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;sort after: </span><span class="se">\n</span><span class="s2">&#39;network&#39;, &#39;station&#39;, &#39;channel&#39;, &#39;location&#39;, &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;&#39;starttime&#39;, &#39;endtime&#39;, &#39;sampling_rate&#39;, &#39;npts&#39;, &#39;dataquality&#39;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Loop over all keys in reversed order.</span>
        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.write"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.write.html#obspy.core.stream.Stream.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save stream into a file.</span>

<span class="sd">        :type filename: str</span>
<span class="sd">        :param filename: The name of the file to write.</span>
<span class="sd">        :type format: str</span>
<span class="sd">        :param format: The file format to use (e.g. ``&quot;MSEED&quot;``). See</span>
<span class="sd">            the `Supported Formats`_ section below for a list of supported</span>
<span class="sd">            formats.</span>
<span class="sd">        :param kwargs: Additional keyword arguments passed to the underlying</span>
<span class="sd">            waveform writer method.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; st.write(&quot;example.mseed&quot;, format=&quot;MSEED&quot;)  # doctest: +SKIP</span>

<span class="sd">        Writing single traces into files with meaningful filenames can be done</span>
<span class="sd">        e.g. using trace.id</span>

<span class="sd">        &gt;&gt;&gt; for tr in st: #doctest: +SKIP</span>
<span class="sd">        ...     tr.write(tr.id + &quot;.MSEED&quot;, format=&quot;MSEED&quot;) #doctest: +SKIP</span>

<span class="sd">        .. rubric:: _`Supported Formats`</span>

<span class="sd">        Additional ObsPy modules extend the parameters of the</span>
<span class="sd">        :meth:`~obspy.core.stream.Stream.write` method. The following</span>
<span class="sd">        table summarizes all known formats currently available for ObsPy.</span>

<span class="sd">        Please refer to the `Linked Function Call`_ of each module for any</span>
<span class="sd">        extra options available.</span>

<span class="sd">        %s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check all traces for masked arrays and raise exception.</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Masked array writing is not supported. You can use &#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39;np.array.filled() to convert the masked array to a &#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39;normal array.&#39;</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># get format specific entry point</span>
            <span class="n">format_ep</span> <span class="o">=</span> <span class="n">ENTRY_POINTS</span><span class="p">[</span><span class="s1">&#39;waveform_write&#39;</span><span class="p">][</span><span class="nb">format</span><span class="p">]</span>
            <span class="c1"># search writeFormat method for given entry point</span>
            <span class="n">write_format</span> <span class="o">=</span> <span class="n">load_entry_point</span><span class="p">(</span>
                <span class="n">format_ep</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">key</span><span class="p">,</span>
                <span class="s1">&#39;obspy.plugin.waveform.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">format_ep</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="s1">&#39;writeFormat&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Writing format </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2"> is not supported. Supported types: </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="nb">format</span><span class="p">,</span>
                                   <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ENTRY_POINTS</span><span class="p">[</span><span class="s1">&#39;waveform_write&#39;</span><span class="p">])))</span>
        <span class="n">write_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.trim"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.trim.html#obspy.core.stream.Stream.trim">[docs]</a>    <span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cut all traces of this Stream object to given start and end time.</span>

<span class="sd">        :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime`, optional</span>
<span class="sd">        :param starttime: Specify the start time.</span>
<span class="sd">        :type endtime: :class:`~obspy.core.utcdatetime.UTCDateTime`, optional</span>
<span class="sd">        :param endtime: Specify the end time.</span>
<span class="sd">        :type pad: bool, optional</span>
<span class="sd">        :param pad: Gives the possibility to trim at time points outside the</span>
<span class="sd">            time frame of the original trace, filling the trace with the</span>
<span class="sd">            given ``fill_value``. Defaults to ``False``.</span>
<span class="sd">        :type nearest_sample: bool, optional</span>
<span class="sd">        :param nearest_sample: If set to ``True``, the closest sample is</span>
<span class="sd">            selected, if set to ``False``, the inner (next sample for a</span>
<span class="sd">            start time border, previous sample for an end time border) sample</span>
<span class="sd">            containing the time is selected. Defaults to ``True``.</span>

<span class="sd">            Given the following trace containing 6 samples, &quot;|&quot; are the</span>
<span class="sd">            sample points, &quot;A&quot; is the requested starttime::</span>

<span class="sd">                |         |A        |         |       B |         |</span>
<span class="sd">                1         2         3         4         5         6</span>

<span class="sd">            ``nearest_sample=True`` will select samples 2-5,</span>
<span class="sd">            ``nearest_sample=False`` will select samples 3-4 only.</span>

<span class="sd">        :type fill_value: int, float or ``None``, optional</span>
<span class="sd">        :param fill_value: Fill value for gaps. Defaults to ``None``. Traces</span>
<span class="sd">            will be converted to NumPy masked arrays if no value is given and</span>
<span class="sd">            gaps are present.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data will no longer be accessible afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; dt = UTCDateTime(&quot;2009-08-24T00:20:20&quot;)</span>
<span class="sd">        &gt;&gt;&gt; st.trim(dt, dt + 5)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:20.000000Z ... | 100.0 Hz, 501 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:20.000000Z ... | 100.0 Hz, 501 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:20.000000Z ... | 100.0 Hz, 501 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># select start/end time fitting to a sample point of the first trace</span>
        <span class="k">if</span> <span class="n">nearest_sample</span><span class="p">:</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">starttime</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">compatibility</span><span class="o">.</span><span class="n">round_away</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">starttime</span> <span class="o">-</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
                <span class="n">starttime</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
            <span class="k">if</span> <span class="n">endtime</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">compatibility</span><span class="o">.</span><span class="n">round_away</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">endtime</span> <span class="o">-</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">)</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
                <span class="c1"># delta is negative!</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="n">trace</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span>
                       <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="c1"># remove empty traces after trimming</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="k">if</span> <span class="n">_i</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream._ltrim"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream._ltrim.html#obspy.core.stream.Stream._ltrim">[docs]</a>    <span class="k">def</span> <span class="nf">_ltrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cut all traces of this Stream object to given start time.</span>
<span class="sd">        For more info see :meth:`~obspy.core.trace.Trace._ltrim`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="n">trace</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span>
                       <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">)</span>
        <span class="c1"># remove empty traces after trimming</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">tr</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream._rtrim"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream._rtrim.html#obspy.core.stream.Stream._rtrim">[docs]</a>    <span class="k">def</span> <span class="nf">_rtrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cut all traces of this Stream object to given end time.</span>
<span class="sd">        For more info see :meth:`~obspy.core.trace.Trace._rtrim`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="n">trace</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">)</span>
        <span class="c1"># remove empty traces after trimming</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">tr</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.cutout"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.cutout.html#obspy.core.stream.Stream.cutout">[docs]</a>    <span class="k">def</span> <span class="nf">cutout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cut the given time range out of all traces of this Stream object.</span>

<span class="sd">        :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param starttime: Start of time span to remove from stream.</span>
<span class="sd">        :type endtime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param endtime: End of time span to remove from stream.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; t1 = UTCDateTime(&quot;2009-08-24T00:20:06&quot;)</span>
<span class="sd">        &gt;&gt;&gt; t2 = UTCDateTime(&quot;2009-08-24T00:20:11&quot;)</span>
<span class="sd">        &gt;&gt;&gt; st.cutout(t1, t2)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        6 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 301 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 301 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 301 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:11.000000Z ... | 100.0 Hz, 2200 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:11.000000Z ... | 100.0 Hz, 2200 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:11.000000Z ... | 100.0 Hz, 2200 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">endtime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">keep_empty_traces</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span> <span class="n">keep_empty_traces</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">traces</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.slice"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.slice.html#obspy.core.stream.Stream.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_empty_traces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new Stream object cut to the given start and end time.</span>

<span class="sd">        :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param starttime: Specify the start time of all traces.</span>
<span class="sd">        :type endtime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param endtime: Specify the end time of all traces.</span>
<span class="sd">        :type keep_empty_traces: bool, optional</span>
<span class="sd">        :param keep_empty_traces: Empty traces will be kept if set to ``True``.</span>
<span class="sd">            Defaults to ``False``.</span>
<span class="sd">        :type nearest_sample: bool, optional</span>
<span class="sd">        :param nearest_sample: If set to ``True``, the closest sample is</span>
<span class="sd">            selected, if set to ``False``, the inner (next sample for a</span>
<span class="sd">            start time border, previous sample for an end time border) sample</span>
<span class="sd">            containing the time is selected. Defaults to ``True``.</span>

<span class="sd">            Given the following trace containing 6 samples, &quot;|&quot; are the</span>
<span class="sd">            sample points, &quot;A&quot; is the requested starttime::</span>

<span class="sd">                |         |A        |         |       B |         |</span>
<span class="sd">                1         2         3         4         5         6</span>

<span class="sd">            ``nearest_sample=True`` will select samples 2-5,</span>
<span class="sd">            ``nearest_sample=False`` will select samples 3-4 only.</span>

<span class="sd">        :return: :class:`~obspy.core.stream.Stream`</span>

<span class="sd">        .. note::</span>

<span class="sd">            The basic idea of :meth:`~obspy.core.stream.Stream.slice`</span>
<span class="sd">            is to avoid copying the sample data in memory. So sample data in</span>
<span class="sd">            the resulting :class:`~obspy.core.stream.Stream` object contains</span>
<span class="sd">            only a reference to the original traces.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; dt = UTCDateTime(&quot;2009-08-24T00:20:20&quot;)</span>
<span class="sd">        &gt;&gt;&gt; st = st.slice(dt, dt + 5)</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:20.000000Z ... | 100.0 Hz, 501 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:20.000000Z ... | 100.0 Hz, 501 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:20.000000Z ... | 100.0 Hz, 501 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">sliced_trace</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span>
                                       <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keep_empty_traces</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sliced_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sliced_trace</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="Stream.slide"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.slide.html#obspy.core.stream.Stream.slide">[docs]</a>    <span class="k">def</span> <span class="nf">slide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_length</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
              <span class="n">include_partial_windows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator yielding equal length sliding windows of the Stream.</span>

<span class="sd">        Please keep in mind that it only returns a new view of the original</span>
<span class="sd">        data. Any modifications are applied to the original data as well. If</span>
<span class="sd">        you don&#39;t want this you have to create a copy of the yielded</span>
<span class="sd">        windows. Also be aware that if you modify the original data and you</span>
<span class="sd">        have overlapping windows, all following windows are affected as well.</span>

<span class="sd">        Not all yielded windows must have the same number of traces. The</span>
<span class="sd">        algorithm will determine the maximal temporal extents by analysing</span>
<span class="sd">        all Traces and then creates windows based on these times.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; import obspy</span>
<span class="sd">        &gt;&gt;&gt; st = obspy.read()</span>
<span class="sd">        &gt;&gt;&gt; for windowed_st in st.slide(window_length=10.0, step=10.0):</span>
<span class="sd">        ...     print(windowed_st)</span>
<span class="sd">        ...     print(&quot;---&quot;)  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        ... | 2009-08-24T00:20:03.000000Z - 2009-08-24T00:20:13.000000Z | ...</span>
<span class="sd">        ... | 2009-08-24T00:20:03.000000Z - 2009-08-24T00:20:13.000000Z | ...</span>
<span class="sd">        ... | 2009-08-24T00:20:03.000000Z - 2009-08-24T00:20:13.000000Z | ...</span>
<span class="sd">        ---</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        ... | 2009-08-24T00:20:13.000000Z - 2009-08-24T00:20:23.000000Z | ...</span>
<span class="sd">        ... | 2009-08-24T00:20:13.000000Z - 2009-08-24T00:20:23.000000Z | ...</span>
<span class="sd">        ... | 2009-08-24T00:20:13.000000Z - 2009-08-24T00:20:23.000000Z | ...</span>


<span class="sd">        :param window_length: The length of each window in seconds.</span>
<span class="sd">        :type window_length: float</span>
<span class="sd">        :param step: The step between the start times of two successive</span>
<span class="sd">            windows in seconds. Can be negative if an offset is given.</span>
<span class="sd">        :type step: float</span>
<span class="sd">        :param offset: The offset of the first window in seconds relative to</span>
<span class="sd">            the start time of the whole interval.</span>
<span class="sd">        :type offset: float</span>
<span class="sd">        :param include_partial_windows: Determines if windows that are</span>
<span class="sd">            shorter then 99.9 % of the desired length are returned.</span>
<span class="sd">        :type include_partial_windows: bool</span>
<span class="sd">        :param nearest_sample: If set to ``True``, the closest sample is</span>
<span class="sd">            selected, if set to ``False``, the inner (next sample for a</span>
<span class="sd">            start time border, previous sample for an end time border) sample</span>
<span class="sd">            containing the time is selected. Defaults to ``True``.</span>

<span class="sd">            Given the following trace containing 6 samples, &quot;|&quot; are the</span>
<span class="sd">            sample points, &quot;A&quot; is the requested starttime::</span>

<span class="sd">                |         |A        |         |       B |         |</span>
<span class="sd">                1         2         3         4         5         6</span>

<span class="sd">            ``nearest_sample=True`` will select samples 2-5,</span>
<span class="sd">            ``nearest_sample=False`` will select samples 3-4 only.</span>
<span class="sd">        :type nearest_sample: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="n">get_window_times</span><span class="p">(</span>
            <span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span>
            <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span>
            <span class="n">window_length</span><span class="o">=</span><span class="n">window_length</span><span class="p">,</span>
            <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">include_partial_windows</span><span class="o">=</span><span class="n">include_partial_windows</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span>
                              <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">)</span>
            <span class="c1"># It might happen that there is a time frame where there are no</span>
            <span class="c1"># windows, e.g. two traces separated by a large gap.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">temp</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="n">temp</span>

        <span class="k">raise</span> <span class="ne">StopIteration</span></div>

<div class="viewcode-block" id="Stream.select"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.select.html#obspy.core.stream.Stream.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">station</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">sampling_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new Stream object only with these traces that match the given</span>
<span class="sd">        stats criteria (e.g. all traces with ``channel=&quot;EHZ&quot;``).</span>

<span class="sd">        .. rubric:: Examples</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; st2 = st.select(station=&quot;R*&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(st2)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>

<span class="sd">        &gt;&gt;&gt; st2 = st.select(id=&quot;BW.RJOB..EHZ&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(st2)  # doctest: +ELLIPSIS</span>
<span class="sd">        1 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>

<span class="sd">        &gt;&gt;&gt; st2 = st.select(component=&quot;Z&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(st2)  # doctest: +ELLIPSIS</span>
<span class="sd">        1 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>

<span class="sd">        &gt;&gt;&gt; st2 = st.select(network=&quot;CZ&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(st2)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        0 Trace(s) in Stream:</span>

<span class="sd">        .. warning::</span>
<span class="sd">            A new Stream object is returned but the traces it contains are</span>
<span class="sd">            just aliases to the traces of the original stream. Does not copy</span>
<span class="sd">            the data but only passes a reference.</span>

<span class="sd">        All keyword arguments except for ``component`` are tested directly</span>
<span class="sd">        against the respective entry in the :class:`~obspy.core.trace.Stats`</span>
<span class="sd">        dictionary.</span>

<span class="sd">        If a string for ``component`` is given (should be a single letter) it</span>
<span class="sd">        is tested against the last letter of the ``Trace.stats.channel`` entry.</span>

<span class="sd">        Alternatively, ``channel`` may have the last one or two letters</span>
<span class="sd">        wildcarded (e.g. ``channel=&quot;EH*&quot;``) to select all components with a</span>
<span class="sd">        common band/instrument code.</span>

<span class="sd">        All other selection criteria that accept strings (network, station,</span>
<span class="sd">        location) may also contain Unix style wildcards (``*``, ``?``, ...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make given component letter uppercase (if e.g. &quot;z&quot; is given)</span>
        <span class="k">if</span> <span class="n">component</span> <span class="ow">and</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">component</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">channel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span> <span class="ow">and</span> <span class="n">component</span> <span class="o">!=</span> <span class="n">channel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Selection criteria for channel and component are &quot;</span> <span class="o">+</span> \
                      <span class="s2">&quot;mutually exclusive!&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">traces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># skip trace if any given criterion is not matched</span>
            <span class="k">if</span> <span class="nb">id</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="nb">id</span><span class="o">.</span><span class="n">upper</span><span class="p">()):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                                       <span class="n">network</span><span class="o">.</span><span class="n">upper</span><span class="p">()):</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">station</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                                       <span class="n">station</span><span class="o">.</span><span class="n">upper</span><span class="p">()):</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                                       <span class="n">location</span><span class="o">.</span><span class="n">upper</span><span class="p">()):</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                                       <span class="n">channel</span><span class="o">.</span><span class="n">upper</span><span class="p">()):</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">sampling_rate</span><span class="p">)</span> <span class="o">!=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">npts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span> <span class="o">!=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">component</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                                       <span class="n">component</span><span class="o">.</span><span class="n">upper</span><span class="p">()):</span>
                    <span class="k">continue</span>
            <span class="n">traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">traces</span><span class="o">=</span><span class="n">traces</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.verify"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.verify.html#obspy.core.stream.Stream.verify">[docs]</a>    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify all traces of current Stream against available meta data.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import Trace, Stream</span>
<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.array([1, 2, 3, 4]))</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.npts = 100</span>
<span class="sd">        &gt;&gt;&gt; st = Stream([tr])</span>
<span class="sd">        &gt;&gt;&gt; st.verify()  #doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        Exception: ntps(100) differs from data size(4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">trace</span><span class="o">.</span><span class="n">verify</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream._merge_checks"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream._merge_checks.html#obspy.core.stream.Stream._merge_checks">[docs]</a>    <span class="k">def</span> <span class="nf">_merge_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sanity checks for merging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">calib</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="c1"># skip empty traces</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Check sampling rate.</span>
            <span class="n">sr</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">!=</span> <span class="n">sr</span><span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Can&#39;t merge traces with same ids but differing &quot;</span> <span class="o">+</span> \
                      <span class="s2">&quot;sampling rates!&quot;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># Check dtype.</span>
            <span class="n">dtype</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Can&#39;t merge traces with same ids but differing &quot;</span> <span class="o">+</span> \
                      <span class="s2">&quot;data types!&quot;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># Check calibration factor.</span>
            <span class="n">calib</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">calib</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">calib</span> <span class="o">!=</span> <span class="n">calib</span><span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Can&#39;t merge traces with same ids but differing &quot;</span> <span class="o">+</span> \
                      <span class="s2">&quot;calibration factors.!&quot;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.merge"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.merge.html#obspy.core.stream.Stream.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolation_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge ObsPy Trace objects with same IDs.</span>

<span class="sd">        :type method: int, optional</span>
<span class="sd">        :param method: Methodology to handle overlaps/gaps of traces. Defaults</span>
<span class="sd">            to ``0``.</span>
<span class="sd">            See :meth:`obspy.core.trace.Trace.__add__` for details on</span>
<span class="sd">            methods ``0`` and ``1``,</span>
<span class="sd">            see :meth:`obspy.core.stream.Stream._cleanup` for details on</span>
<span class="sd">            method ``-1``. Any merge operation performs a cleanup merge as</span>
<span class="sd">            a first step (method ``-1``).</span>
<span class="sd">        :type fill_value: int, float, str or ``None``, optional</span>
<span class="sd">        :param fill_value: Fill value for gaps. Defaults to ``None``. Traces</span>
<span class="sd">            will be converted to NumPy masked arrays if no value is given and</span>
<span class="sd">            gaps are present. The value ``&#39;latest&#39;`` will use the latest value</span>
<span class="sd">            before the gap. If value ``&#39;interpolate&#39;`` is provided, missing</span>
<span class="sd">            values are linearly interpolated (not changing the data</span>
<span class="sd">            type e.g. of integer valued traces). Not used for ``method=-1``.</span>
<span class="sd">        :type interpolation_samples: int, optional</span>
<span class="sd">        :param interpolation_samples: Used only for ``method=1``. It specifies</span>
<span class="sd">            the number of samples which are used to interpolate between</span>
<span class="sd">            overlapping traces. Default to ``0``. If set to ``-1`` all</span>
<span class="sd">            overlapping samples are interpolated.</span>

<span class="sd">        Importing waveform data containing gaps or overlaps results into</span>
<span class="sd">        a :class:`~obspy.core.stream.Stream` object with multiple traces having</span>
<span class="sd">        the same identifier. This method tries to merge such traces inplace,</span>
<span class="sd">        thus returning nothing. Merged trace data will be converted into a</span>
<span class="sd">        NumPy :class:`~numpy.ma.MaskedArray` type if any gaps are present. This</span>
<span class="sd">        behavior may be prevented by setting the ``fill_value`` parameter.</span>
<span class="sd">        The ``method`` argument controls the handling of overlapping data</span>
<span class="sd">        values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">listsort</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Helper method for keeping trace&#39;s ordering</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># check sampling rates and dtypes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_checks</span><span class="p">()</span>
        <span class="c1"># remember order of traces</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">]</span>
        <span class="c1"># order matters!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">,</span> <span class="s1">&#39;station&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="s1">&#39;channel&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;starttime&#39;</span><span class="p">,</span> <span class="s1">&#39;endtime&#39;</span><span class="p">])</span>
        <span class="c1"># build up dictionary with with lists of traces with same ids</span>
        <span class="n">traces_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># using pop() and try-except saves memory</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># skip empty traces</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">_id</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">traces_dict</span><span class="p">:</span>
                    <span class="n">traces_dict</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">trace</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">traces_dict</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># clear traces of current stream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># loop through ids</span>
        <span class="k">for</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">traces_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">cur_trace</span> <span class="o">=</span> <span class="n">traces_dict</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># loop through traces of same id</span>
            <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">traces_dict</span><span class="p">[</span><span class="n">_id</span><span class="p">])):</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="n">traces_dict</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># disable sanity checks because there are already done</span>
                <span class="n">cur_trace</span> <span class="o">=</span> <span class="n">cur_trace</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span>
                    <span class="n">trace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">sanity_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">interpolation_samples</span><span class="o">=</span><span class="n">interpolation_samples</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_trace</span><span class="p">)</span>

        <span class="c1"># trying to restore order, newly created traces are placed at</span>
        <span class="c1"># start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">listsort</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.simulate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.simulate.html#obspy.core.stream.Stream.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paz_remove</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">paz_simulate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">remove_sensitivity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simulate_sensitivity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Correct for instrument response / Simulate new instrument response.</span>

<span class="sd">        :type paz_remove: dict, None</span>
<span class="sd">        :param paz_remove: Dictionary containing keys ``&#39;poles&#39;``, ``&#39;zeros&#39;``,</span>
<span class="sd">            ``&#39;gain&#39;`` (A0 normalization factor). Poles and zeros must be a</span>
<span class="sd">            list of complex floating point numbers, gain must be of type float.</span>
<span class="sd">            Poles and Zeros are assumed to correct to m/s, SEED convention.</span>
<span class="sd">            Use ``None`` for no inverse filtering.</span>
<span class="sd">            Use ``&#39;self&#39;`` to use paz AttribDict in ``trace.stats`` for every</span>
<span class="sd">            trace in stream.</span>
<span class="sd">        :type paz_simulate: dict, None</span>
<span class="sd">        :param paz_simulate: Dictionary containing keys ``&#39;poles&#39;``,</span>
<span class="sd">            ``&#39;zeros&#39;``, ``&#39;gain&#39;``. Poles and zeros must be a list of complex</span>
<span class="sd">            floating point numbers, gain must be of type float. Or ``None`` for</span>
<span class="sd">            no simulation.</span>
<span class="sd">        :type remove_sensitivity: bool</span>
<span class="sd">        :param remove_sensitivity: Determines if data is divided by</span>
<span class="sd">            ``paz_remove[&#39;sensitivity&#39;]`` to correct for overall sensitivity of</span>
<span class="sd">            recording instrument (seismometer/digitizer) during instrument</span>
<span class="sd">            correction.</span>
<span class="sd">        :type simulate_sensitivity: bool</span>
<span class="sd">        :param simulate_sensitivity: Determines if data is multiplied with</span>
<span class="sd">            ``paz_simulate[&#39;sensitivity&#39;]`` to simulate overall sensitivity of</span>
<span class="sd">            new instrument (seismometer/digitizer) during instrument</span>
<span class="sd">            simulation.</span>

<span class="sd">        This function corrects for the original instrument response given by</span>
<span class="sd">        ``paz_remove`` and/or simulates a new instrument response given by</span>
<span class="sd">        ``paz_simulate``.</span>

<span class="sd">        For additional information and more options to control the instrument</span>
<span class="sd">        correction/simulation (e.g. water level, demeaning, tapering, ...) see</span>
<span class="sd">        :func:`~obspy.signal.invsim.simulate_seismometer`.</span>

<span class="sd">        The keywords `paz_remove` and `paz_simulate` are expected to be</span>
<span class="sd">        dictionaries containing information on poles, zeros and gain (and</span>
<span class="sd">        usually also sensitivity).</span>

<span class="sd">        If both ``paz_remove`` and ``paz_simulate`` are specified, both steps</span>
<span class="sd">        are performed in one go in the frequency domain, otherwise only the</span>
<span class="sd">        specified step is performed.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Instead of the builtin deconvolution based on Poles and Zeros</span>
<span class="sd">            information, the deconvolution can be performed using evalresp</span>
<span class="sd">            instead by using the option `seedresp` (see documentation of</span>
<span class="sd">            :func:`~obspy.signal.invsim.simulate_seismometer` and the</span>
<span class="sd">            `ObsPy Tutorial</span>
<span class="sd">            &lt;https://docs.obspy.org/master/tutorial/code_snippets/\</span>
<span class="sd">seismometer_correction_simulation.html#using-a-resp-file&gt;`_.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of every trace.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; from obspy.signal.invsim import corn_freq_2_paz</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; paz_sts2 = {&#39;poles&#39;: [-0.037004+0.037016j, -0.037004-0.037016j,</span>
<span class="sd">        ...                       -251.33+0j,</span>
<span class="sd">        ...                       -131.04-467.29j, -131.04+467.29j],</span>
<span class="sd">        ...             &#39;zeros&#39;: [0j, 0j],</span>
<span class="sd">        ...             &#39;gain&#39;: 60077000.0,</span>
<span class="sd">        ...             &#39;sensitivity&#39;: 2516778400.0}</span>
<span class="sd">        &gt;&gt;&gt; paz_1hz = corn_freq_2_paz(1.0, damp=0.707)</span>
<span class="sd">        &gt;&gt;&gt; st.simulate(paz_remove=paz_sts2, paz_simulate=paz_1hz)</span>
<span class="sd">        ... # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.plot()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read</span>
<span class="sd">            from obspy.signal.invsim import corn_freq_2_paz</span>
<span class="sd">            st = read()</span>
<span class="sd">            paz_sts2 = {&#39;poles&#39;: [-0.037004+0.037016j, -0.037004-0.037016j,</span>
<span class="sd">                                  -251.33+0j,</span>
<span class="sd">                                  -131.04-467.29j, -131.04+467.29j],</span>
<span class="sd">                        &#39;zeros&#39;: [0j, 0j],</span>
<span class="sd">                        &#39;gain&#39;: 60077000.0,</span>
<span class="sd">                        &#39;sensitivity&#39;: 2516778400.0}</span>
<span class="sd">            paz_1hz = corn_freq_2_paz(1.0, damp=0.707)</span>
<span class="sd">            paz_1hz[&#39;sensitivity&#39;] = 1.0</span>
<span class="sd">            st.simulate(paz_remove=paz_sts2, paz_simulate=paz_1hz)</span>
<span class="sd">            st.plot()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">paz_remove</span><span class="o">=</span><span class="n">paz_remove</span><span class="p">,</span> <span class="n">paz_simulate</span><span class="o">=</span><span class="n">paz_simulate</span><span class="p">,</span>
                        <span class="n">remove_sensitivity</span><span class="o">=</span><span class="n">remove_sensitivity</span><span class="p">,</span>
                        <span class="n">simulate_sensitivity</span><span class="o">=</span><span class="n">simulate_sensitivity</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.filter"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.filter.html#obspy.core.stream.Stream.filter">[docs]</a>    <span class="nd">@raise_if_masked</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter the data of all traces in the Stream.</span>

<span class="sd">        :type type: str</span>
<span class="sd">        :param type: String that specifies which filter is applied (e.g.</span>
<span class="sd">            ``&quot;bandpass&quot;``). See the `Supported Filter`_ section below for</span>
<span class="sd">            further details.</span>
<span class="sd">        :param options: Necessary keyword arguments for the respective filter</span>
<span class="sd">            that will be passed on. (e.g. ``freqmin=1.0``, ``freqmax=20.0`` for</span>
<span class="sd">            ``&quot;bandpass&quot;``)</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of every trace.</span>

<span class="sd">        .. rubric:: _`Supported Filter`</span>

<span class="sd">        ``&#39;bandpass&#39;``</span>
<span class="sd">            Butterworth-Bandpass (uses :func:`obspy.signal.filter.bandpass`).</span>

<span class="sd">        ``&#39;bandstop&#39;``</span>
<span class="sd">            Butterworth-Bandstop (uses :func:`obspy.signal.filter.bandstop`).</span>

<span class="sd">        ``&#39;lowpass&#39;``</span>
<span class="sd">            Butterworth-Lowpass (uses :func:`obspy.signal.filter.lowpass`).</span>

<span class="sd">        ``&#39;highpass&#39;``</span>
<span class="sd">            Butterworth-Highpass (uses :func:`obspy.signal.filter.highpass`).</span>

<span class="sd">        ``&#39;lowpass_cheby_2&#39;``</span>
<span class="sd">            Cheby2-Lowpass (uses :func:`obspy.signal.filter.lowpass_cheby_2`).</span>

<span class="sd">        ``&#39;lowpass_fir&#39;`` (experimental)</span>
<span class="sd">            FIR-Lowpass (uses :func:`obspy.signal.filter.lowpass_fir`).</span>

<span class="sd">        ``&#39;remez_fir&#39;`` (experimental)</span>
<span class="sd">            Minimax optimal bandpass using Remez algorithm (uses</span>
<span class="sd">            :func:`obspy.signal.filter.remez_fir`).</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; st.filter(&quot;highpass&quot;, freq=1.0)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.plot()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read</span>
<span class="sd">            st = read()</span>
<span class="sd">            st.filter(&quot;highpass&quot;, freq=1.0)</span>
<span class="sd">            st.plot()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.trigger"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.trigger.html#obspy.core.stream.Stream.trigger">[docs]</a>    <span class="k">def</span> <span class="nf">trigger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run a triggering algorithm on all traces in the stream.</span>

<span class="sd">        :param type: String that specifies which trigger is applied (e.g.</span>
<span class="sd">            ``&#39;recstalta&#39;``). See the `Supported Trigger`_ section below for</span>
<span class="sd">            further details.</span>
<span class="sd">        :param options: Necessary keyword arguments for the respective</span>
<span class="sd">            trigger that will be passed on. (e.g. ``sta=3``, ``lta=10``)</span>
<span class="sd">            Arguments ``sta`` and ``lta`` (seconds) will be mapped to ``nsta``</span>
<span class="sd">            and ``nlta`` (samples) by multiplying with sampling rate of trace.</span>
<span class="sd">            (e.g. ``sta=3``, ``lta=10`` would call the trigger with 3 and 10</span>
<span class="sd">            seconds average, respectively)</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of every trace.</span>

<span class="sd">        .. rubric:: _`Supported Trigger`</span>

<span class="sd">        ``&#39;classicstalta&#39;``</span>
<span class="sd">            Computes the classic STA/LTA characteristic function (uses</span>
<span class="sd">            :func:`obspy.signal.trigger.classic_sta_lta`).</span>

<span class="sd">        ``&#39;recstalta&#39;``</span>
<span class="sd">            Recursive STA/LTA</span>
<span class="sd">            (uses :func:`obspy.signal.trigger.recursive_sta_lta`).</span>

<span class="sd">        ``&#39;recstaltapy&#39;``</span>
<span class="sd">            Recursive STA/LTA written in Python (uses</span>
<span class="sd">            :func:`obspy.signal.trigger.recursive_sta_lta_py`).</span>

<span class="sd">        ``&#39;delayedstalta&#39;``</span>
<span class="sd">            Delayed STA/LTA.</span>
<span class="sd">            (uses :func:`obspy.signal.trigger.delayed_sta_lta`).</span>

<span class="sd">        ``&#39;carlstatrig&#39;``</span>
<span class="sd">            Computes the carl_sta_trig characteristic function (uses</span>
<span class="sd">            :func:`obspy.signal.trigger.carl_sta_trig`).</span>

<span class="sd">        ``&#39;zdetect&#39;``</span>
<span class="sd">            Z-detector (uses :func:`obspy.signal.trigger.z_detect`).</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; st.filter(&quot;highpass&quot;, freq=1.0)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.plot()  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; st.trigger(&#39;recstalta&#39;, sta=1, lta=4)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.plot()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read</span>
<span class="sd">            st = read()</span>
<span class="sd">            st.filter(&quot;highpass&quot;, freq=1.0)</span>
<span class="sd">            st.plot()</span>
<span class="sd">            st.trigger(&#39;recstalta&#39;, sta=1, lta=4)</span>
<span class="sd">            st.plot()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">trigger</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.resample"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.resample.html#obspy.core.stream.Stream.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="n">no_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">strict_length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample data in all traces of stream using Fourier method.</span>

<span class="sd">        :type sampling_rate: float</span>
<span class="sd">        :param sampling_rate: The sampling rate of the resampled signal.</span>
<span class="sd">        :type window: array_like, callable, str, float, or tuple, optional</span>
<span class="sd">        :param window: Specifies the window applied to the signal in the</span>
<span class="sd">            Fourier domain. Defaults ``&#39;hanning&#39;`` window. See</span>
<span class="sd">            :func:`scipy.signal.resample` for details.</span>
<span class="sd">        :type no_filter: bool, optional</span>
<span class="sd">        :param no_filter: Deactivates automatic filtering if set to ``True``.</span>
<span class="sd">            Defaults to ``True``.</span>
<span class="sd">        :type strict_length: bool, optional</span>
<span class="sd">        :param strict_length: Leave traces unchanged for which end time of</span>
<span class="sd">            trace would change. Defaults to ``False``.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The :class:`~Stream` object has three different methods to change</span>
<span class="sd">            the sampling rate of its data: :meth:`~.resample`,</span>
<span class="sd">            :meth:`~.decimate`, and :meth:`~.interpolate`</span>

<span class="sd">            Make sure to choose the most appropriate one for the problem at</span>
<span class="sd">            hand.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of every trace.</span>

<span class="sd">        Uses :func:`scipy.signal.resample`. Because a Fourier method is used,</span>
<span class="sd">        the signal is assumed to be periodic.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; st.resample(10.0)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 10.0 Hz, 300 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03.000000Z ... | 10.0 Hz, 300 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03.000000Z ... | 10.0 Hz, 300 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">native_str</span><span class="p">(</span><span class="n">window</span><span class="p">),</span>
                        <span class="n">no_filter</span><span class="o">=</span><span class="n">no_filter</span><span class="p">,</span> <span class="n">strict_length</span><span class="o">=</span><span class="n">strict_length</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.decimate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.decimate.html#obspy.core.stream.Stream.decimate">[docs]</a>    <span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">no_filter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strict_length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Downsample data in all traces of stream by an integer factor.</span>

<span class="sd">        :type factor: int</span>
<span class="sd">        :param factor: Factor by which the sampling rate is lowered by</span>
<span class="sd">            decimation.</span>
<span class="sd">        :type no_filter: bool, optional</span>
<span class="sd">        :param no_filter: Deactivates automatic filtering if set to ``True``.</span>
<span class="sd">            Defaults to ``False``.</span>
<span class="sd">        :type strict_length: bool, optional</span>
<span class="sd">        :param strict_length: Leave traces unchanged for which end time of</span>
<span class="sd">            trace would change. Defaults to ``False``.</span>

<span class="sd">        Currently a simple integer decimation is implemented.</span>
<span class="sd">        Only every decimation_factor-th sample remains in the trace, all other</span>
<span class="sd">        samples are thrown away. Prior to decimation a lowpass filter is</span>
<span class="sd">        applied to ensure no aliasing artifacts are introduced. The automatic</span>
<span class="sd">        filtering can be deactivated with ``no_filter=True``.</span>

<span class="sd">        If the length of the data array modulo ``decimation_factor`` is not</span>
<span class="sd">        zero then the end time of the trace is changing on sub-sample scale. To</span>
<span class="sd">        abort downsampling in case of changing end times set</span>
<span class="sd">        ``strict_length=True``.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The :class:`~Stream` object has three different methods to change</span>
<span class="sd">            the sampling rate of its data: :meth:`~.resample`,</span>
<span class="sd">            :meth:`~.decimate`, and :meth:`~.interpolate`</span>

<span class="sd">            Make sure to choose the most appropriate one for the problem at</span>
<span class="sd">            hand.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of every trace.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        For the example we switch off the automatic pre-filtering so that</span>
<span class="sd">        the effect of the downsampling routine becomes clearer.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import Trace, Stream</span>
<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.arange(10))</span>
<span class="sd">        &gt;&gt;&gt; st = Stream(traces=[tr])</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.sampling_rate</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; tr.data</span>
<span class="sd">        array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">        &gt;&gt;&gt; st.decimate(4, strict_length=False, no_filter=True)</span>
<span class="sd">        ... # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.sampling_rate</span>
<span class="sd">        0.25</span>
<span class="sd">        &gt;&gt;&gt; tr.data</span>
<span class="sd">        array([0, 4, 8])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">no_filter</span><span class="o">=</span><span class="n">no_filter</span><span class="p">,</span>
                        <span class="n">strict_length</span><span class="o">=</span><span class="n">strict_length</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.max"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.max.html#obspy.core.stream.Stream.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the values of the absolute maximum amplitudes of all traces in the</span>
<span class="sd">        stream. See :meth:`~obspy.core.trace.Trace.max`.</span>

<span class="sd">        :return: List of values of absolute maxima of all traces</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import Trace, Stream</span>
<span class="sd">        &gt;&gt;&gt; tr1 = Trace(data=np.array([0, -3, 9, 6, 4]))</span>
<span class="sd">        &gt;&gt;&gt; tr2 = Trace(data=np.array([0, -3, -9, 6, 4]))</span>
<span class="sd">        &gt;&gt;&gt; tr3 = Trace(data=np.array([0.3, -3.5, 9.0, 6.4, 4.3]))</span>
<span class="sd">        &gt;&gt;&gt; st = Stream(traces=[tr1, tr2, tr3])</span>
<span class="sd">        &gt;&gt;&gt; st.max()</span>
<span class="sd">        [9, -9, 9.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span></div>

<div class="viewcode-block" id="Stream.differentiate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.differentiate.html#obspy.core.stream.Stream.differentiate">[docs]</a>    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;gradient&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Differentiate all traces with respect to time.</span>

<span class="sd">        :type method: str, optional</span>
<span class="sd">        :param method: Method to use for differentiation. Defaults to</span>
<span class="sd">            ``&#39;gradient&#39;``. See the `Supported Methods`_ section below for</span>
<span class="sd">            further details.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of every trace.</span>

<span class="sd">        .. rubric:: _`Supported Methods`</span>

<span class="sd">        ``&#39;gradient&#39;``</span>
<span class="sd">            The gradient is computed using central differences in the interior</span>
<span class="sd">            and first differences at the boundaries. The returned gradient</span>
<span class="sd">            hence has the same shape as the input array. (uses</span>
<span class="sd">            :func:`numpy.gradient`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">differentiate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.integrate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.integrate.html#obspy.core.stream.Stream.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cumtrapz&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integrate all traces with respect to time.</span>

<span class="sd">        For details see the corresponding</span>
<span class="sd">        :meth:`~obspy.core.trace.Trace.integrate` method of</span>
<span class="sd">        :class:`~obspy.core.trace.Trace`.</span>

<span class="sd">        :type method: str, optional</span>
<span class="sd">        :param type: Method to use for integration. Defaults to</span>
<span class="sd">            ``&#39;cumtrapz&#39;``. See :meth:`~obspy.core.trace.Trace.integrate` for</span>
<span class="sd">            further details.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of every trace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.detrend"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.detrend.html#obspy.core.stream.Stream.detrend">[docs]</a>    <span class="nd">@raise_if_masked</span>
    <span class="k">def</span> <span class="nf">detrend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a trend from all traces.</span>

<span class="sd">        For details see the corresponding</span>
<span class="sd">        :meth:`~obspy.core.trace.Trace.detrend` method of</span>
<span class="sd">        :class:`~obspy.core.trace.Trace`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.taper"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.taper.html#obspy.core.stream.Stream.taper">[docs]</a>    <span class="k">def</span> <span class="nf">taper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Taper all Traces in Stream.</span>

<span class="sd">        For details see the corresponding :meth:`~obspy.core.trace.Trace.taper`</span>
<span class="sd">        method of :class:`~obspy.core.trace.Trace`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">taper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.interpolate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.interpolate.html#obspy.core.stream.Stream.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate all Traces in a Stream.</span>

<span class="sd">        For details see the corresponding</span>
<span class="sd">        :meth:`~obspy.core.trace.Trace.interpolate` method of</span>
<span class="sd">        :class:`~obspy.core.trace.Trace`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The :class:`~Stream` object has three different methods to change</span>
<span class="sd">            the sampling rate of its data: :meth:`~.resample`,</span>
<span class="sd">            :meth:`~.decimate`, and :meth:`~.interpolate`</span>

<span class="sd">            Make sure to choose the most appropriate one for the problem at</span>
<span class="sd">            hand.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data will no longer be accessible afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03... - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03... - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03... - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; st.interpolate(sampling_rate=111.1)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;obspy.core.stream.Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        3 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03... - ... | 111.1 Hz, 3332 samples</span>
<span class="sd">        BW.RJOB..EHN | 2009-08-24T00:20:03... - ... | 111.1 Hz, 3332 samples</span>
<span class="sd">        BW.RJOB..EHE | 2009-08-24T00:20:03... - ... | 111.1 Hz, 3332 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.std"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.std.html#obspy.core.stream.Stream.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate standard deviations of all Traces in the Stream.</span>

<span class="sd">        Standard deviations are calculated by NumPy method</span>
<span class="sd">        :meth:`~numpy.ndarray.std` on ``trace.data`` for every trace in the</span>
<span class="sd">        stream.</span>

<span class="sd">        :return: List of standard deviations of all traces.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import Trace, Stream</span>
<span class="sd">        &gt;&gt;&gt; tr1 = Trace(data=np.array([0, -3, 9, 6, 4]))</span>
<span class="sd">        &gt;&gt;&gt; tr2 = Trace(data=np.array([0.3, -3.5, 9.0, 6.4, 4.3]))</span>
<span class="sd">        &gt;&gt;&gt; st = Stream(traces=[tr1, tr2])</span>
<span class="sd">        &gt;&gt;&gt; st.std()</span>
<span class="sd">        [4.2614551505325036, 4.4348618918744247]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tr</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span></div>

<div class="viewcode-block" id="Stream.normalize"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.normalize.html#obspy.core.stream.Stream.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">global_max</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize all Traces in the Stream.</span>

<span class="sd">        By default all traces are normalized separately to their respective</span>
<span class="sd">        absolute maximum. By setting ``global_max=True`` all traces get</span>
<span class="sd">        normalized to the global maximum of all traces.</span>

<span class="sd">        :param global_max: If set to ``True``, all traces are normalized with</span>
<span class="sd">                respect to the global maximum of all traces in the stream</span>
<span class="sd">                instead of normalizing every trace separately.</span>

<span class="sd">        .. note::</span>
<span class="sd">            If ``data.dtype`` of a trace was integer it is changing to float.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of every trace.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        Make a Stream with two Traces:</span>

<span class="sd">        &gt;&gt;&gt; from obspy import Trace, Stream</span>
<span class="sd">        &gt;&gt;&gt; tr1 = Trace(data=np.array([0, -3, 9, 6, 4]))</span>
<span class="sd">        &gt;&gt;&gt; tr2 = Trace(data=np.array([0.3, -0.5, -0.8, 0.4, 0.3]))</span>
<span class="sd">        &gt;&gt;&gt; st = Stream(traces=[tr1, tr2])</span>

<span class="sd">        All traces are normalized to their absolute maximum and processing</span>
<span class="sd">        information is added:</span>

<span class="sd">        &gt;&gt;&gt; st.normalize()  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st[0].data  # doctest: +ELLIPSIS</span>
<span class="sd">        array([ 0.        , -0.33333333,  1.        ,  0.66666667,  ...])</span>
<span class="sd">        &gt;&gt;&gt; print(st[0].stats.processing[0])  # doctest: +ELLIPSIS</span>
<span class="sd">        ObsPy ... normalize(norm=None)</span>
<span class="sd">        &gt;&gt;&gt; st[1].data</span>
<span class="sd">        array([ 0.375, -0.625, -1.   ,  0.5  ,  0.375])</span>
<span class="sd">        &gt;&gt;&gt; print(st[1].stats.processing[0])  # doctest: +ELLIPSIS</span>
<span class="sd">        ObsPy ...: normalize(norm=None)</span>

<span class="sd">        Now let&#39;s do it again normalize all traces to the stream&#39;s global</span>
<span class="sd">        maximum:</span>

<span class="sd">        &gt;&gt;&gt; tr1 = Trace(data=np.array([0, -3, 9, 6, 4]))</span>
<span class="sd">        &gt;&gt;&gt; tr2 = Trace(data=np.array([0.3, -0.5, -0.8, 0.4, 0.3]))</span>
<span class="sd">        &gt;&gt;&gt; st = Stream(traces=[tr1, tr2])</span>

<span class="sd">        &gt;&gt;&gt; st.normalize(global_max=True)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st[0].data  # doctest: +ELLIPSIS</span>
<span class="sd">        array([ 0.        , -0.33333333,  1.        ,  0.66666667,  ...])</span>
<span class="sd">        &gt;&gt;&gt; print(st[0].stats.processing[0])  # doctest: +ELLIPSIS</span>
<span class="sd">        ObsPy ...: normalize(norm=9)</span>
<span class="sd">        &gt;&gt;&gt; st[1].data  # doctest: +ELLIPSIS</span>
<span class="sd">        array([ 0.03333333, -0.05555556, -0.08888889,  0.04444444,  ...])</span>
<span class="sd">        &gt;&gt;&gt; print(st[1].stats.processing[0])  # doctest: +ELLIPSIS</span>
<span class="sd">        ObsPy ...: normalize(norm=9)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use the same value for normalization on all traces?</span>
        <span class="k">if</span> <span class="n">global_max</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># normalize all traces</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.rotate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.rotate.html#obspy.core.stream.Stream.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">back_azimuth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inclination</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate stream objects.</span>

<span class="sd">        :type method: str</span>
<span class="sd">        :param method: Determines the rotation method.</span>

<span class="sd">            ``&#39;NE-&gt;RT&#39;``: Rotates the North- and East-components of a</span>
<span class="sd">                seismogram to radial and transverse components.</span>
<span class="sd">            ``&#39;RT-&gt;NE&#39;``: Rotates the radial and transverse components of a</span>
<span class="sd">                seismogram to North- and East-components.</span>
<span class="sd">            ``&#39;ZNE-&gt;LQT&#39;``: Rotates from left-handed Z, North, and  East system</span>
<span class="sd">                to LQT, e.g. right-handed ray coordinate system.</span>
<span class="sd">            ``&#39;LQT-&gt;ZNE&#39;``: Rotates from LQT, e.g. right-handed ray coordinate</span>
<span class="sd">                system to left handed Z, North, and East system.</span>

<span class="sd">        :type back_azimuth: float, optional</span>
<span class="sd">        :param back_azimuth: Depends on the chosen method.</span>
<span class="sd">            A single float, the back azimuth from station to source in degrees.</span>
<span class="sd">            If not given, ``stats.back_azimuth`` will be used. It will also be</span>
<span class="sd">            written after the rotation is done.</span>
<span class="sd">        :type inclination: float, optional</span>
<span class="sd">        :param inclination: Inclination of the ray at the station in degrees.</span>
<span class="sd">            Only necessary for three component rotations. If not given,</span>
<span class="sd">            ``stats.inclination`` will be used. It will also be written after</span>
<span class="sd">            the rotation is done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;NE-&gt;RT&quot;</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="s2">&quot;rotate_ne_rt&quot;</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;RT-&gt;NE&quot;</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="s2">&quot;rotate_rt_ne&quot;</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;ZNE-&gt;LQT&quot;</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="s2">&quot;rotate_zne_lqt&quot;</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;LQT-&gt;ZNE&quot;</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="s2">&quot;rotate_lqt_zne&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Method has to be one of (&#39;NE-&gt;RT&#39;, &#39;RT-&gt;NE&#39;, &quot;</span>
                             <span class="s2">&quot;&#39;ZNE-&gt;LQT&#39;, or &#39;LQT-&gt;ZNE&#39;).&quot;</span><span class="p">)</span>
        <span class="c1"># Retrieve function call from entry points</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_get_function_from_entry_point</span><span class="p">(</span><span class="s2">&quot;rotate&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="c1"># Split to get the components. No need for further checks for the</span>
        <span class="c1"># method as invalid methods will be caught by previous conditional.</span>
        <span class="n">input_components</span><span class="p">,</span> <span class="n">output_components</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">)</span>
        <span class="c1"># Figure out inclination and back-azimuth.</span>
        <span class="k">if</span> <span class="n">back_azimuth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">back_azimuth</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">back_azimuth</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No back-azimuth specified.&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">inclination</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">inclination</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">inclination</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No inclination specified.&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Do one of the two-component rotations.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">input_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">input_components</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">input_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">input_components</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i_1</span><span class="p">,</span> <span class="n">i_2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_1</span><span class="p">,</span> <span class="n">input_2</span><span class="p">):</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_2</span><span class="p">))</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span> <span class="n">i_2</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dt</span><span class="p">)</span> \
                        <span class="ow">or</span> <span class="p">(</span><span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">!=</span>
                            <span class="n">i_2</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;All components need to have the same time span.&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i_1</span><span class="p">,</span> <span class="n">i_2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_1</span><span class="p">,</span> <span class="n">input_2</span><span class="p">):</span>
                <span class="n">output_1</span><span class="p">,</span> <span class="n">output_2</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">i_1</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">i_2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">back_azimuth</span><span class="p">)</span>
                <span class="n">i_1</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">output_1</span>
                <span class="n">i_2</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">output_2</span>
                <span class="c1"># Rename the components.</span>
                <span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="n">output_components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">i_2</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">i_2</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="n">output_components</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Add the azimuth and inclination to the stats object.</span>
                <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i_1</span><span class="p">,</span> <span class="n">i_2</span><span class="p">):</span>
                    <span class="n">comp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">back_azimuth</span> <span class="o">=</span> <span class="n">back_azimuth</span>
        <span class="c1"># Do one of the three-component rotations.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">input_components</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">input_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">input_components</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">input_3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">input_components</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i_1</span><span class="p">,</span> <span class="n">i_2</span><span class="p">,</span> <span class="n">i_3</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_1</span><span class="p">,</span> <span class="n">input_2</span><span class="p">,</span> <span class="n">input_3</span><span class="p">):</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_2</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_3</span><span class="p">))</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span>
                             <span class="n">i_2</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dt</span><span class="p">)</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span>
                             <span class="n">i_3</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dt</span><span class="p">)</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">!=</span>
                            <span class="n">i_2</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">!=</span> <span class="n">i_3</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;All components need to have the same time span.&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i_1</span><span class="p">,</span> <span class="n">i_2</span><span class="p">,</span> <span class="n">i_3</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_1</span><span class="p">,</span> <span class="n">input_2</span><span class="p">,</span> <span class="n">input_3</span><span class="p">):</span>
                <span class="n">output_1</span><span class="p">,</span> <span class="n">output_2</span><span class="p">,</span> <span class="n">output_3</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span>
                    <span class="n">i_1</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">i_2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">i_3</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">back_azimuth</span><span class="p">,</span> <span class="n">inclination</span><span class="p">)</span>
                <span class="n">i_1</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">output_1</span>
                <span class="n">i_2</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">output_2</span>
                <span class="n">i_3</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">output_3</span>
                <span class="c1"># Rename the components.</span>
                <span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">i_1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="n">output_components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">i_2</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">i_2</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="n">output_components</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">i_3</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">i_3</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="n">output_components</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># Add the azimuth and inclination to the stats object.</span>
                <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i_1</span><span class="p">,</span> <span class="n">i_2</span><span class="p">,</span> <span class="n">i_3</span><span class="p">):</span>
                    <span class="n">comp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">back_azimuth</span> <span class="o">=</span> <span class="n">back_azimuth</span>
                    <span class="n">comp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">inclination</span> <span class="o">=</span> <span class="n">inclination</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.copy"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.copy.html#obspy.core.stream.Stream.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deepcopy of the Stream object.</span>

<span class="sd">        :rtype: :class:`~obspy.core.stream.Stream`</span>
<span class="sd">        :return: Copy of current stream.</span>

<span class="sd">        .. rubric:: Examples</span>

<span class="sd">        1. Create a Stream and copy it</span>

<span class="sd">            &gt;&gt;&gt; from obspy import read</span>
<span class="sd">            &gt;&gt;&gt; st = read()</span>
<span class="sd">            &gt;&gt;&gt; st2 = st.copy()</span>

<span class="sd">           The two objects are not the same:</span>

<span class="sd">            &gt;&gt;&gt; st is st2</span>
<span class="sd">            False</span>

<span class="sd">           But they have equal data (before applying further processing):</span>

<span class="sd">            &gt;&gt;&gt; st == st2</span>
<span class="sd">            True</span>

<span class="sd">        2. The following example shows how to make an alias but not copy the</span>
<span class="sd">           data. Any changes on ``st3`` would also change the contents of</span>
<span class="sd">           ``st``.</span>

<span class="sd">            &gt;&gt;&gt; st3 = st</span>
<span class="sd">            &gt;&gt;&gt; st is st3</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; st == st3</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.clear"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.clear.html#obspy.core.stream.Stream.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear trace list (convenience method).</span>

<span class="sd">        Replaces Stream&#39;s trace list by an empty one creating an empty</span>
<span class="sd">        Stream object. Useful if there are references to the current</span>
<span class="sd">        Stream object that should not break. Otherwise simply use a new</span>
<span class="sd">        Stream() instance.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; len(st)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; st.clear()  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.traces</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream._cleanup"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream._cleanup.html#obspy.core.stream.Stream._cleanup">[docs]</a>    <span class="k">def</span> <span class="nf">_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">misalignment_threshold</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge consistent trace objects but leave everything else alone.</span>

<span class="sd">        This can mean traces with matching header that are directly adjacent or</span>
<span class="sd">        are contained/equal/overlapping traces with exactly the same waveform</span>
<span class="sd">        data in the overlapping part.</span>
<span class="sd">        If option `misalignment_threshold` is non-zero then</span>
<span class="sd">        contained/overlapping/directly adjacent traces with the sampling points</span>
<span class="sd">        misaligned by less than `misalignment_threshold` times the sampling</span>
<span class="sd">        interval are aligned on the same sampling points (see example below).</span>

<span class="sd">        .. rubric:: Notes</span>

<span class="sd">        Traces with overlapping data parts that do not match are not merged::</span>

<span class="sd">            before:</span>
<span class="sd">            Trace 1: AAAAAAAA</span>
<span class="sd">            Trace 2:     BBBBBBBB</span>

<span class="sd">            after:</span>
<span class="sd">            Trace 1: AAAAAAAA</span>
<span class="sd">            Trace 2:     BBBBBBBB</span>

<span class="sd">        Traces with overlapping data parts that do match are merged::</span>

<span class="sd">            before:</span>
<span class="sd">            Trace 1: AAAAAAAA</span>
<span class="sd">            Trace 2:     AAAABBBB</span>

<span class="sd">            after:</span>
<span class="sd">            Trace 1: AAAAAAAABBBB</span>

<span class="sd">        Contained traces are handled the same way.</span>
<span class="sd">        If common data does not match, nothing is done::</span>

<span class="sd">            before:</span>
<span class="sd">            Trace 1: AAAAAAAAAAAA</span>
<span class="sd">            Trace 2:     BBBB</span>

<span class="sd">            after:</span>
<span class="sd">            Trace 1: AAAAAAAAAAAA</span>
<span class="sd">            Trace 2:     BBBB</span>

<span class="sd">        If the common data part matches they are merged::</span>

<span class="sd">            before:</span>
<span class="sd">            Trace 1: AAAAAAAAAAAA</span>
<span class="sd">            Trace 2:     AAAA</span>

<span class="sd">            after:</span>
<span class="sd">            Trace 1: AAAAAAAAAAAA</span>

<span class="sd">        Directly adjacent traces are merged::</span>

<span class="sd">            before:</span>
<span class="sd">            Trace 1: AAAAAAA</span>
<span class="sd">            Trace 2:        BBBBB</span>

<span class="sd">            after:</span>
<span class="sd">            Trace 1: AAAAAAABBBBB</span>

<span class="sd">        Misaligned traces are aligned, depending on set parameters, e.g. for a</span>
<span class="sd">        directly adjacent trace with slight misalignment (with two common</span>
<span class="sd">        samples at start of Trace 2 for better visualization)::</span>

<span class="sd">            before:</span>
<span class="sd">            Trace 1: A---------A---------A</span>
<span class="sd">            Trace 2:            A---------A---------B---------B</span>

<span class="sd">            after:</span>
<span class="sd">            Trace 1: A---------A---------A---------B---------B</span>

<span class="sd">        :type misalignment_threshold: float</span>
<span class="sd">        :param misalignment_threshold: Threshold value for sub-sample</span>
<span class="sd">            misalignments of sampling points of two traces that should be</span>
<span class="sd">            merged together (fraction of sampling interval, from 0 to 0.5).</span>
<span class="sd">            ``0`` means traces with even just the slightest misalignment will</span>
<span class="sd">            not be merged together, ``0.5`` means traces will be merged</span>
<span class="sd">            together disregarding of any sub-sample shifts of sampling points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first of all throw away all empty traces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="k">if</span> <span class="n">_i</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">]</span>
        <span class="c1"># check sampling rates and dtypes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_merge_checks</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;Can&#39;t merge traces with same ids but&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Incompatible traces (sampling_rate, dtype, ...) &quot;</span> <span class="o">+</span> \
                      <span class="s2">&quot;with same id detected. Doing nothing.&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="c1"># order matters!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">,</span> <span class="s1">&#39;station&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="s1">&#39;channel&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;starttime&#39;</span><span class="p">,</span> <span class="s1">&#39;endtime&#39;</span><span class="p">])</span>
        <span class="c1"># build up dictionary with lists of traces with same ids</span>
        <span class="n">traces_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># using pop() and try-except saves memory</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># add trace to respective list or create that list</span>
                <span class="n">traces_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># clear traces of current stream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># loop through ids</span>
        <span class="k">for</span> <span class="n">id_</span> <span class="ow">in</span> <span class="n">traces_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">trace_list</span> <span class="o">=</span> <span class="n">traces_dict</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span>
            <span class="n">cur_trace</span> <span class="o">=</span> <span class="n">trace_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">cur_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
            <span class="n">allowed_micro_shift</span> <span class="o">=</span> <span class="n">misalignment_threshold</span> <span class="o">*</span> <span class="n">delta</span>
            <span class="c1"># work through all traces of same id</span>
            <span class="k">while</span> <span class="n">trace_list</span><span class="p">:</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="n">trace_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># `gap` is the deviation (in seconds) of the actual start</span>
                <span class="c1"># time of the second trace from the expected start time</span>
                <span class="c1"># (for the ideal case of directly adjacent and perfectly</span>
                <span class="c1"># aligned traces).</span>
                <span class="n">gap</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span> <span class="p">(</span><span class="n">cur_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span>
                <span class="c1"># if `gap` is larger than the designated allowed shift,</span>
                <span class="c1"># we treat it as a real gap and leave as is.</span>
                <span class="k">if</span> <span class="n">misalignment_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">gap</span> <span class="o">&lt;=</span> <span class="n">allowed_micro_shift</span><span class="p">:</span>
                    <span class="c1"># `gap` is smaller than allowed shift (or equal),</span>
                    <span class="c1">#  the traces could be</span>
                    <span class="c1">#  - overlapping without being misaligned or..</span>
                    <span class="c1">#  - overlapping with misalignment or..</span>
                    <span class="c1">#  - misaligned with a micro gap</span>
                    <span class="c1"># check if the sampling points are misaligned:</span>
                    <span class="n">misalignment</span> <span class="o">=</span> <span class="n">gap</span> <span class="o">%</span> <span class="n">delta</span>
                    <span class="k">if</span> <span class="n">misalignment</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># determine the position of the second trace&#39;s</span>
                        <span class="c1"># sampling points in the interval between two</span>
                        <span class="c1"># sampling points of first trace.</span>
                        <span class="c1"># a `misalign_percentage` of close to 0.0 means a</span>
                        <span class="c1"># sampling point of the first trace is just a bit</span>
                        <span class="c1"># to the left of our sampling point:</span>
                        <span class="c1">#</span>
                        <span class="c1">#  Trace 1: --|---------|---------|---------|--</span>
                        <span class="c1">#  Trace 2: ---|---------|---------|---------|-</span>
                        <span class="c1"># misalign_percentage:  0.........1</span>
                        <span class="c1">#</span>
                        <span class="c1"># a `misalign_percentage` of close to 1.0 means a</span>
                        <span class="c1"># sampling point of the first trace is just a bit</span>
                        <span class="c1"># to the right of our sampling point:</span>
                        <span class="c1">#</span>
                        <span class="c1">#  Trace 1: --|---------|---------|---------|--</span>
                        <span class="c1">#  Trace 2: -|---------|---------|---------|---</span>
                        <span class="c1"># misalign_percentage:  0.........1</span>
                        <span class="n">misalign_percentage</span> <span class="o">=</span> <span class="n">misalignment</span> <span class="o">/</span> <span class="n">delta</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">misalign_percentage</span> <span class="o">&lt;=</span> <span class="n">misalignment_threshold</span> <span class="ow">or</span>
                                <span class="n">misalign_percentage</span> <span class="o">&gt;=</span>
                                <span class="mi">1</span> <span class="o">-</span> <span class="n">misalignment_threshold</span><span class="p">):</span>
                            <span class="c1"># now we align the sampling points of both traces</span>
                            <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">cur_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span>
                                <span class="nb">round</span><span class="p">((</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span>
                                       <span class="n">cur_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span>
                                <span class="n">delta</span><span class="p">)</span>
                <span class="c1"># we have some common parts: check if consistent</span>
                <span class="c1"># (but only if sampling points are matching to specified</span>
                <span class="c1">#  accuracy, which is checked and conditionally corrected in</span>
                <span class="c1">#  previous code block)</span>
                <span class="n">subsample_shift_percentage</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">-</span>
                    <span class="n">cur_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">%</span> <span class="n">delta</span> <span class="o">/</span> <span class="n">delta</span>
                <span class="n">subsample_shift_percentage</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="n">subsample_shift_percentage</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">subsample_shift_percentage</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">&lt;=</span> <span class="n">cur_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="ow">and</span>
                        <span class="n">subsample_shift_percentage</span> <span class="o">&lt;</span> <span class="n">misalignment_threshold</span><span class="p">):</span>
                    <span class="c1"># check if common time slice [t1 --&gt; t2] is equal:</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cur_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">,</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">)</span>
                    <span class="c1"># if consistent: add them together</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">cur_trace</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                      <span class="n">trace</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
                        <span class="n">cur_trace</span> <span class="o">+=</span> <span class="n">trace</span>
                    <span class="c1"># if not consistent: leave them alone</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_trace</span><span class="p">)</span>
                        <span class="n">cur_trace</span> <span class="o">=</span> <span class="n">trace</span>
                <span class="c1"># traces are perfectly adjacent: add them together</span>
                <span class="k">elif</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">==</span> <span class="n">cur_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">+</span> \
                        <span class="n">cur_trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="n">cur_trace</span> <span class="o">+=</span> <span class="n">trace</span>
                <span class="c1"># no common parts (gap):</span>
                <span class="c1"># leave traces alone and add current to list</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_trace</span><span class="p">)</span>
                    <span class="n">cur_trace</span> <span class="o">=</span> <span class="n">trace</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_trace</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">tr</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.split"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.split.html#obspy.core.stream.Stream.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split any trace containing gaps into contiguous unmasked traces.</span>

<span class="sd">        :rtype: :class:`obspy.core.stream.Stream`</span>
<span class="sd">        :returns: Returns a new stream object containing only contiguous</span>
<span class="sd">            unmasked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="n">new_stream</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">new_stream</span></div>

<div class="viewcode-block" id="Stream.attach_response"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.attach_response.html#obspy.core.stream.Stream.attach_response">[docs]</a>    <span class="nd">@map_example_filename</span><span class="p">(</span><span class="s2">&quot;inventories&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">attach_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inventories</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for and attach channel response to each trace as</span>
<span class="sd">        trace.stats.response. Does not raise an exception but shows a warning</span>
<span class="sd">        if response information can not be found for all traces. Returns a</span>
<span class="sd">        list of traces for which no response could be found.</span>
<span class="sd">        To subsequently deconvolve the instrument response use</span>
<span class="sd">        :meth:`Stream.remove_response`.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, read_inventory</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; inv = read_inventory()</span>
<span class="sd">        &gt;&gt;&gt; st.attach_response(inv)</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; tr = st[0]</span>
<span class="sd">        &gt;&gt;&gt; print(tr.stats.response)  \</span>
<span class="sd">                # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE</span>
<span class="sd">        Channel Response</span>
<span class="sd">           From M/S (Velocity in Meters per Second) to COUNTS (Digital Counts)</span>
<span class="sd">           Overall Sensitivity: 2.5168e+09 defined at 0.020 Hz</span>
<span class="sd">           4 stages:</span>
<span class="sd">              Stage 1: PolesZerosResponseStage from M/S to V, gain: 1500</span>
<span class="sd">              Stage 2: CoefficientsTypeResponseStage from V to COUNTS, ...</span>
<span class="sd">              Stage 3: FIRResponseStage from COUNTS to COUNTS, gain: 1</span>
<span class="sd">              Stage 4: FIRResponseStage from COUNTS to COUNTS, gain: 1</span>

<span class="sd">        :type inventories: :class:`~obspy.core.inventory.inventory.Inventory`</span>
<span class="sd">            or :class:`~obspy.core.inventory.network.Network` or a list</span>
<span class="sd">            containing objects of these types.</span>
<span class="sd">        :param inventories: Station metadata to use in search for response for</span>
<span class="sd">            each trace in the stream.</span>
<span class="sd">        :rtype: list of :class:`~obspy.core.trace.Trace`</span>
<span class="sd">        :returns: list of traces for which no response information could be</span>
<span class="sd">            found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">skipped_traces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">attach_response</span><span class="p">(</span><span class="n">inventories</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;No matching response information found.&quot;</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                    <span class="n">skipped_traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>
        <span class="k">return</span> <span class="n">skipped_traces</span></div>

<div class="viewcode-block" id="Stream.remove_response"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.remove_response.html#obspy.core.stream.Stream.remove_response">[docs]</a>    <span class="k">def</span> <span class="nf">remove_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deconvolve instrument response for all Traces in Stream.</span>

<span class="sd">        For details see the corresponding</span>
<span class="sd">        :meth:`~obspy.core.trace.Trace.remove_response` method of</span>
<span class="sd">        :class:`~obspy.core.trace.Trace`.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, read_inventory</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; inv = read_inventory()</span>
<span class="sd">        &gt;&gt;&gt; st.remove_response(inventory=inv)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; st.plot()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read, read_inventory</span>
<span class="sd">            st = read()</span>
<span class="sd">            inv = read_inventory()</span>
<span class="sd">            st.remove_response(inventory=inv)</span>
<span class="sd">            st.plot()</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">remove_response</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.remove_sensitivity"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream.Stream.remove_sensitivity.html#obspy.core.stream.Stream.remove_sensitivity">[docs]</a>    <span class="k">def</span> <span class="nf">remove_sensitivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove instrument sensitivity for all Traces in Stream.</span>

<span class="sd">        For details see the corresponding</span>
<span class="sd">        :meth:`~obspy.core.trace.Trace.remove_sensitivity` method of</span>
<span class="sd">        :class:`~obspy.core.trace.Trace`.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, read_inventory</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; inv = read_inventory()</span>
<span class="sd">        &gt;&gt;&gt; st.remove_sensitivity(inv)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Stream object at 0x...&gt;</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.stream.Stream.copy` to create</span>
<span class="sd">            a copy of your stream object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">remove_sensitivity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Renamed to &#39;_is_pickle&#39;. Use that instead.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isPickle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># noqa</span>
    <span class="k">return</span> <span class="n">_is_pickle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Renamed to &#39;_read_pickle&#39;. Use that instead.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">readPickle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># noqa</span>
    <span class="k">return</span> <span class="n">_read_pickle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Renamed to &#39;_write_pickle&#39;. Use that instead.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">writePickle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># noqa</span>
    <span class="k">return</span> <span class="n">_write_pickle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="_is_pickle"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream._is_pickle.html#obspy.core.stream._is_pickle">[docs]</a><span class="k">def</span> <span class="nf">_is_pickle</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>  <span class="c1"># @UnusedVariable</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether a file is a pickled ObsPy Stream file.</span>

<span class="sd">    :type filename: str</span>
<span class="sd">    :param filename: Name of the pickled ObsPy Stream file to be checked.</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    :return: ``True`` if pickled file.</span>

<span class="sd">    .. rubric:: Example</span>

<span class="sd">    &gt;&gt;&gt; _is_pickle(&#39;/path/to/pickle.file&#39;)  # doctest: +SKIP</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">native_str</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">Stream</span><span class="p">)</span></div>


<div class="viewcode-block" id="_read_pickle"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream._read_pickle.html#obspy.core.stream._read_pickle">[docs]</a><span class="k">def</span> <span class="nf">_read_pickle</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># @UnusedVariable</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read and return Stream from pickled ObsPy Stream file.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This function should NOT be called directly, it registers via the</span>
<span class="sd">        ObsPy :func:`~obspy.core.stream.read` function, call this instead.</span>

<span class="sd">    :type filename: str</span>
<span class="sd">    :param filename: Name of the pickled ObsPy Stream file to be read.</span>
<span class="sd">    :rtype: :class:`~obspy.core.stream.Stream`</span>
<span class="sd">    :return: A ObsPy Stream object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">native_str</span><span class="p">)):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="_write_pickle"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.stream._write_pickle.html#obspy.core.stream._write_pickle">[docs]</a><span class="k">def</span> <span class="nf">_write_pickle</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># @UnusedVariable</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write a Python pickle of current stream.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Writing into PICKLE format allows to store additional attributes</span>
<span class="sd">        appended to the current Stream object or any contained Trace.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This function should NOT be called directly, it registers via the</span>
<span class="sd">        the :meth:`~obspy.core.stream.Stream.write` method of an</span>
<span class="sd">        ObsPy :class:`~obspy.core.stream.Stream` object, call this instead.</span>

<span class="sd">    :type stream: :class:`~obspy.core.stream.Stream`</span>
<span class="sd">    :param stream: The ObsPy Stream object to write.</span>
<span class="sd">    :type filename: str</span>
<span class="sd">    :param filename: Name of file to write.</span>
<span class="sd">    :type protocol: int, optional</span>
<span class="sd">    :param protocol: Pickle protocol, defaults to ``2``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">native_str</span><span class="p">)):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">exclude_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

</div>

<footer>
<p class="text-muted small">
By the <a href="https://github.com/orgs/obspy/people">ObsPy
Development Team</a> and many <a href="#contributers" role="button"
data-toggle="modal" data-target="#contributers">Awesome Contributors</a>™ &nbsp;|&nbsp; Built with
<a href="http://getbootstrap.com/">Bootstrap</a> and
<a href="http://glyphicons.com//">Glyphicons</a> &nbsp;|&nbsp; Copyright 2008-2016
</p>
</footer>
<div id="contributers" class="modal fade" tabindex="-1"
role="dialog" aria-labelledby="contributersLabel" aria-hidden="true">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<button type="button" class="close" data-dismiss="modal"
aria-hidden="true">&times;</button>
<h3 class="modal-title" id="contributersLabel">Thank you!</h3>
</div>
<div class="modal-body">
<p>We would like to thank our contributors, whose efforts make
this software what it is. These people have helped by writing code
and documentation, and by testing. They have created and
maintained this product, its associated libraries and
applications, our build tools and our web sites.</p>
<h4>Contributors</h4>
<div class="container-fluid">
<div class="row">
<div class="col-md-6">
<ul>
<li>Ammon, Charles J.</li>
<li>Arnarsson, Ólafur St.</li>
<li>Barsch, Robert</li>
<li>Bernardi, Fabrizio</li>
<li>Beyreuther, Moritz</li>
<li>Carothers, Lloyd</li>
<li>Egdorf, Sven</li>
<li>Ermert, Laura</li>
<li>Fabbri, Tommaso</li>
<li>Grunberg, Marc</li>
<li>Heimann, Sebastian</li>
<li>Hope, Gaute</li>
<li>Inza, Adolfo</li>
<li>Ketchum, David</li>
<li>Kremers, Simon</li>
<li>Krieger, Lars</li>
<li>Käufl, Paul</li>
<li>Lecocq, Thomas</li>
<li>Lesage, Philippe</li>
<li>Lopes, Rui L.</li>
<li>Maggi, Alessia</li>
<li>Megies, Tobias</li>
<li>Michelini, Alberto</li>
<li>Morgenstern, Bernhard</li>
<li>Panning, Mark P.</li>
<li>Reyes, Celso</li>
<li>Rothenhäusler, Nicolas</li>
<li>Sales de Andrade, Elliott</li>
<li>Saul, Joachim</li>
<li>Sippl, Christian</li>
<li>Stange, Stefan</li>
<li>Trabant, Chad</li>
<li>Walker, Andrew</li>
<li>Wassermann, Joachim</li>
<li>Winkelman, Andrew</li>
<li>van Driel, Martin</li>
</ul>
</div>
<div class="col-md-6">
<ul>
<li>Antunes, Emanuel</li>
<li>Bank, Markus</li>
<li>Behr, Yannik</li>
<li>Bernauer, Felix</li>
<li>Bonaimé, Sébastien</li>
<li>Danecek, Peter</li>
<li>Engels, Fabian</li>
<li>Eulenfeld, Tom</li>
<li>Grellier, Clément</li>
<li>Hammer, Conny</li>
<li>Heiniger, Lukas</li>
<li>Igel, Heiner</li>
<li>Isken, Marius</li>
<li>Koymans, Mathijs</li>
<li>Kress, Victor</li>
<li>Krischer, Lion</li>
<li>Köhler, Andreas</li>
<li>Leeman, John</li>
<li>Lomax, Anthony</li>
<li>MacCarthy, Jonathan</li>
<li>Martin, Henri</li>
<li>Meschede, Matthias</li>
<li>Miller, Nathaniel C.</li>
<li>Nof, Ran Novitsky</li>
<li>Rapagnani, Giovanni</li>
<li>Ringler, Adam</li>
<li>Russo, Emiliano</li>
<li>Satriano, Claudio</li>
<li>Scheingraber, Chris</li>
<li>Snoke, Arthur</li>
<li>Sullivan, Benjamin</li>
<li>Uieda, Leonardo</li>
<li>Walther, Marcus</li>
<li>Williams, Mark C.</li>
<li>Zad, Seyed Kasra Hosseini</li>
</ul>
</div>
</div>
</div>
<h4>Funds</h4>
<p>ObsPy was partially funded by the</p>
<ul>
<li>German Science Foundation (DFG) via grant DFG IG 16/9-1</li>
<li>German Ministry for Education and Research (BMBF), GEOTECHNOLOGIEN grant 03G0646H.</li>
<li>NERA project (Network of European Research Infrastructures for Earthquake Risk Assessment and Mitigation) under the European Community&#39;s Seventh Framework Programme (FP7/2007-2013) grant agreement n° 262330</li>
<li>Leibniz Institute for Applied Geophysics (LIAG)</li>
<li>VERCE EU-FP7 project (no. 283543)</li>
</ul>
</div>
<div class="modal-footer">
<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
</div>
</div>
</div>
</div>

</div>


  </body>
</html>