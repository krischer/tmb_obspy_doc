<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>obspy.core.trace &#8212; ObsPy Documentation (1.0.3)</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/font.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/base.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript">
  var shiftWindow = function() { scrollBy(0, -70) };
  if (location.hash) shiftWindow();
  window.addEventListener("hashchange", shiftWindow);
</script>

  </head>
  <body>
<div id="wrapper">
<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
<div class="container-fluid">
<div class="navbar-header">
<button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a href="/" class="navbar-brand" title="Home"><span class="icon-obspy"></span>&nbsp;ObsPy</a>
</div>
<div class="navbar-collapse collapse">
<form class="navbar-form navbar-right" role="search" method="get" action="http://docs.obspy.org/search.html">
<div class="form-group">
<input type="text" class="form-control" placeholder="Search Docs" name="q">
</div>
</form>
<ul class="nav navbar-nav navbar-right">
<li><a href="https://github.com/obspy/obspy/" title="GitHub"><span class="icon-github iconx2"></span><span class="hidden-sm">&nbsp;GitHub</span></a></li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Documentation"><span class="glyphicon glyphicon-book iconx2"></span><span class="hidden-sm">&nbsp;Documentation</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Getting&nbsp;Started</li>
<li><a href="https://github.com/obspy/obspy/wiki#installation">Installation</a></li>
<li><a href="https://tutorial.obspy.org/">Tutorial</a></li>
<li><a href="http://gallery.obspy.org/">Gallery</a></li>
<li><a href="https://docs.obspy.org/">API&nbsp;Documentation&nbsp;(latest&nbsp;release)</a></li>
<li><a href="https://docs.obspy.org/master/">API&nbsp;Documentation&nbsp;(current&nbsp;master)</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Mailing&nbsp;Lists"><span class="glyphicon glyphicon-envelope iconx2"></span><span class="hidden-sm">&nbsp;Mailing&nbsp;Lists</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Announcements&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-announcements"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-announcements/"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archive</a></li>
<li class="divider"></li>
<li class="dropdown-header">Users&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-users"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-users"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archives</a></li>
<li><a href="mailto:users@obspy.org"><span class="glyphicon glyphicon-envelope"></span>&nbsp;Post&nbsp;a&nbsp;message</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Developer&nbsp;Resources"><span class="glyphicon glyphicon-cog iconx2"></span><span class="hidden-sm">&nbsp;Developer&nbsp;Resources</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li><a href="https://gitter.im/obspy/obspy">Gitter</a></li>
<li><a href="https://github.com/obspy/obspy/blob/master/.github/CONTRIBUTING.md">How&nbsp;to&nbsp;contribute</a></li>
<li><a href="http://docs.obspy.org/coding_style.html">Coding&nbsp;Style&nbsp;Guide</a></li>
<li><a href="https://github.com/obspy/obspy/releases/">All&nbsp;Releases</a></li>
<li class="divider"></li>
<li class="dropdown-header">Code&nbsp;Analysis</li>
<li><a href="http://docs.obspy.org/master/pep8/index.html">PEP8</a></li>
<li><a href="http://docs.obspy.org/master/coverage/index.html">Python&nbsp;Coverage</a></li>
<li><a href="http://docs.obspy.org/master/c_coverage/index.html">C&nbsp;Coverage</a></li>
<li><a href="https://coveralls.io/r/obspy/obspy?branch=master">Coveralls</a></li>
<li class="divider"></li>
<li class="dropdown-header">Continuous&nbsp;Integration</li>
<li><a href="http://tests.obspy.org/">Test&nbsp;Reports</a></li>
<li><a href="https://travis-ci.org/obspy/obspy/"><span class="icon-travis"></span>&nbsp;Travis&nbsp;CI</a></li>
<li><a href="https://ci.appveyor.com/project/obspy/obspy"><span class="icon-appveyor"></span>&nbsp;AppVeyor</a></li>
</ul>
</li>
</ul>
</div>
</div>
</nav>

<div id="content" class="container">
  
    <div class="breadcrumb pull-right"><a href="../../../genindex.html" title="General Index"
         accesskey="I">index</a><span style="color: #ccc; padding: 0 5px;">| </span><a href="../../../py-modindex.html" title="Python Module Index"
         >modules</a>
    </div>
    <ol class="breadcrumb">
        <li><a href="../../../contents.html">ObsPy Documentation (1.0.3)</a></li>
        <li><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ol>
  
  <h1>Source code for obspy.core.trace</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for handling ObsPy Trace objects.</span>

<span class="sd">:copyright:</span>
<span class="sd">    The ObsPy Development Team (devs@obspy.org)</span>
<span class="sd">:license:</span>
<span class="sd">    GNU Lesser General Public License, Version 3</span>
<span class="sd">    (https://www.gnu.org/copyleft/lesser.html)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">future.builtins</span> <span class="k">import</span> <span class="o">*</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">future.utils</span> <span class="k">import</span> <span class="n">native_str</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">decorator</span> <span class="k">import</span> <span class="n">decorator</span>

<span class="kn">from</span> <span class="nn">obspy.core</span> <span class="k">import</span> <span class="n">compatibility</span>
<span class="kn">from</span> <span class="nn">obspy.core.utcdatetime</span> <span class="k">import</span> <span class="n">UTCDateTime</span>
<span class="kn">from</span> <span class="nn">obspy.core.util</span> <span class="k">import</span> <span class="n">AttribDict</span><span class="p">,</span> <span class="n">create_empty_data_chunk</span>
<span class="kn">from</span> <span class="nn">obspy.core.util.base</span> <span class="k">import</span> <span class="n">_get_function_from_entry_point</span>
<span class="kn">from</span> <span class="nn">obspy.core.util.decorator</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">deprecated</span><span class="p">,</span> <span class="n">raise_if_masked</span><span class="p">,</span> <span class="n">skip_if_no_data</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">obspy.core.util.misc</span> <span class="k">import</span> <span class="p">(</span><span class="n">flat_not_masked_contiguous</span><span class="p">,</span> <span class="n">get_window_times</span><span class="p">,</span>
                                  <span class="n">limit_numpy_fft_cache</span><span class="p">)</span>


<div class="viewcode-block" id="Stats"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Stats.html#obspy.core.trace.Stats">[docs]</a><span class="k">class</span> <span class="nc">Stats</span><span class="p">(</span><span class="n">AttribDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A container for additional header information of a ObsPy Trace object.</span>

<span class="sd">    A ``Stats`` object may contain all header information (also known as meta</span>
<span class="sd">    data) of a :class:`~obspy.core.trace.Trace` object. Those headers may be</span>
<span class="sd">    accessed or modified either in the dictionary style or directly via a</span>
<span class="sd">    corresponding attribute. There are various default attributes which are</span>
<span class="sd">    required by every waveform import and export modules within ObsPy such as</span>
<span class="sd">    :mod:`obspy.io.mseed`.</span>

<span class="sd">    :type header: dict or :class:`~obspy.core.trace.Stats`, optional</span>
<span class="sd">    :param header: Dictionary containing meta information of a single</span>
<span class="sd">        :class:`~obspy.core.trace.Trace` object. Possible keywords are</span>
<span class="sd">        summarized in the following `Default Attributes`_ section.</span>

<span class="sd">    .. rubric:: Basic Usage</span>

<span class="sd">    &gt;&gt;&gt; stats = Stats()</span>
<span class="sd">    &gt;&gt;&gt; stats.network = &#39;BW&#39;</span>
<span class="sd">    &gt;&gt;&gt; print(stats[&#39;network&#39;])</span>
<span class="sd">    BW</span>
<span class="sd">    &gt;&gt;&gt; stats[&#39;station&#39;] = &#39;MANZ&#39;</span>
<span class="sd">    &gt;&gt;&gt; print(stats.station)</span>
<span class="sd">    MANZ</span>

<span class="sd">    .. rubric:: _`Default Attributes`</span>

<span class="sd">    ``sampling_rate`` : float, optional</span>
<span class="sd">        Sampling rate in hertz (default value is 1.0).</span>
<span class="sd">    ``delta`` : float, optional</span>
<span class="sd">        Sample distance in seconds (default value is 1.0).</span>
<span class="sd">    ``calib`` : float, optional</span>
<span class="sd">        Calibration factor (default value is 1.0).</span>
<span class="sd">    ``npts`` : int, optional</span>
<span class="sd">        Number of sample points (default value is 0, which implies that no data</span>
<span class="sd">        is present).</span>
<span class="sd">    ``network`` : string, optional</span>
<span class="sd">        Network code (default is an empty string).</span>
<span class="sd">    ``location`` : string, optional</span>
<span class="sd">        Location code (default is an empty string).</span>
<span class="sd">    ``station`` : string, optional</span>
<span class="sd">        Station code (default is an empty string).</span>
<span class="sd">    ``channel`` : string, optional</span>
<span class="sd">        Channel code (default is an empty string).</span>
<span class="sd">    ``starttime`` : :class:`~obspy.core.utcdatetime.UTCDateTime`, optional</span>
<span class="sd">        Date and time of the first data sample given in UTC (default value is</span>
<span class="sd">        &quot;1970-01-01T00:00:00.0Z&quot;).</span>
<span class="sd">    ``endtime`` : :class:`~obspy.core.utcdatetime.UTCDateTime`, optional</span>
<span class="sd">        Date and time of the last data sample given in UTC</span>
<span class="sd">        (default value is &quot;1970-01-01T00:00:00.0Z&quot;).</span>

<span class="sd">    .. rubric:: Notes</span>

<span class="sd">    (1) The attributes ``sampling_rate`` and ``delta`` are linked to each</span>
<span class="sd">        other. If one of the attributes is modified the other will be</span>
<span class="sd">        recalculated.</span>

<span class="sd">        &gt;&gt;&gt; stats = Stats()</span>
<span class="sd">        &gt;&gt;&gt; stats.sampling_rate</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; stats.delta = 0.005</span>
<span class="sd">        &gt;&gt;&gt; stats.sampling_rate</span>
<span class="sd">        200.0</span>

<span class="sd">    (2) The attributes ``starttime``, ``npts``, ``sampling_rate`` and ``delta``</span>
<span class="sd">        are monitored and used to automatically calculate the ``endtime``.</span>

<span class="sd">        &gt;&gt;&gt; stats = Stats()</span>
<span class="sd">        &gt;&gt;&gt; stats.npts = 60</span>
<span class="sd">        &gt;&gt;&gt; stats.delta = 1.0</span>
<span class="sd">        &gt;&gt;&gt; stats.starttime = UTCDateTime(2009, 1, 1, 12, 0, 0)</span>
<span class="sd">        &gt;&gt;&gt; stats.endtime</span>
<span class="sd">        UTCDateTime(2009, 1, 1, 12, 0, 59)</span>
<span class="sd">        &gt;&gt;&gt; stats.delta = 0.5</span>
<span class="sd">        &gt;&gt;&gt; stats.endtime</span>
<span class="sd">        UTCDateTime(2009, 1, 1, 12, 0, 29, 500000)</span>

<span class="sd">    (3) The attribute ``endtime`` is read only and can not be modified.</span>

<span class="sd">        &gt;&gt;&gt; stats = Stats()</span>
<span class="sd">        &gt;&gt;&gt; stats.endtime = UTCDateTime(2009, 1, 1, 12, 0, 0)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AttributeError: Attribute &quot;endtime&quot; in Stats object is read only!</span>
<span class="sd">        &gt;&gt;&gt; stats[&#39;endtime&#39;] = UTCDateTime(2009, 1, 1, 12, 0, 0)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AttributeError: Attribute &quot;endtime&quot; in Stats object is read only!</span>

<span class="sd">    (4)</span>
<span class="sd">        The attribute ``npts`` will be automatically updated from the</span>
<span class="sd">        :class:`~obspy.core.trace.Trace` object.</span>

<span class="sd">        &gt;&gt;&gt; trace = Trace()</span>
<span class="sd">        &gt;&gt;&gt; trace.stats.npts</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; trace.data = np.array([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; trace.stats.npts</span>
<span class="sd">        4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">readonly</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;endtime&#39;</span><span class="p">]</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;sampling_rate&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="s1">&#39;delta&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="s1">&#39;starttime&#39;</span><span class="p">:</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="s1">&#39;endtime&#39;</span><span class="p">:</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="s1">&#39;npts&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;calib&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="s1">&#39;network&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;station&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;location&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;channel&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="p">}</span>

<div class="viewcode-block" id="Stats.__init__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Stats.__init__.html#obspy.core.trace.Stats.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Stats</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">header</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stats.__setitem__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Stats.__setitem__.html#obspy.core.trace.Stats.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># keys which need to refresh derived values</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">,</span> <span class="s1">&#39;sampling_rate&#39;</span><span class="p">,</span> <span class="s1">&#39;starttime&#39;</span><span class="p">,</span> <span class="s1">&#39;npts&#39;</span><span class="p">]:</span>
            <span class="c1"># ensure correct data type</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;delta&#39;</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;sampling_rate&#39;</span>
                <span class="n">value</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;sampling_rate&#39;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;starttime&#39;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;npts&#39;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="c1"># set current key</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Stats</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># set derived value: delta</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span>
            <span class="c1"># set derived value: endtime</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">timediff</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">timediff</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;endtime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> <span class="n">timediff</span>
            <span class="k">return</span>
        <span class="c1"># prevent a calibration factor of 0</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;calib&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Calibration factor set to 0.0!&#39;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="c1"># all other keys</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Stats</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AttribDict</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Stats</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="fm">__setitem__</span>

<div class="viewcode-block" id="Stats.__str__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Stats.__str__.html#obspy.core.trace.Stats.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return better readable string representation of Stats object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">priorized_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;network&#39;</span><span class="p">,</span> <span class="s1">&#39;station&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="s1">&#39;channel&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;starttime&#39;</span><span class="p">,</span> <span class="s1">&#39;endtime&#39;</span><span class="p">,</span> <span class="s1">&#39;sampling_rate&#39;</span><span class="p">,</span> <span class="s1">&#39;delta&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;npts&#39;</span><span class="p">,</span> <span class="s1">&#39;calib&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pretty_str</span><span class="p">(</span><span class="n">priorized_keys</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stats._repr_pretty_"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Stats._repr_pretty_.html#obspy.core.trace.Stats._repr_pretty_">[docs]</a>    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="_add_processing_info"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace._add_processing_info.html#obspy.core.trace._add_processing_info">[docs]</a><span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">_add_processing_info</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a decorator that attaches information about a processing call as a</span>
<span class="sd">    string to the Trace.stats.processing list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">callargs</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getcallargs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">callargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">)</span>
    <span class="n">kwargs_</span> <span class="o">=</span> <span class="n">callargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;kwargs&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">__version__</span>
    <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;ObsPy </span><span class="si">{version}</span><span class="s2">: </span><span class="si">{function}</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">version</span><span class="o">=</span><span class="n">__version__</span><span class="p">,</span>
        <span class="n">function</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">arguments</span> <span class="o">+=</span> \
        <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">native_str</span><span class="p">)</span> <span class="k">else</span>
         <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">callargs</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">arguments</span> <span class="o">+=</span> \
        <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">native_str</span><span class="p">)</span> <span class="k">else</span>
         <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs_</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">arguments</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">info</span> <span class="o">%</span> <span class="s2">&quot;::&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
    <span class="bp">self</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Attach after executing the function to avoid having it attached</span>
    <span class="c1"># while the operation failed.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_internal_add_processing_info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Trace"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.html#obspy.core.trace.Trace">[docs]</a><span class="k">class</span> <span class="nc">Trace</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An object containing data of a continuous series, such as a seismic trace.</span>

<span class="sd">    :type data: :class:`~numpy.ndarray` or :class:`~numpy.ma.MaskedArray`</span>
<span class="sd">    :param data: Array of data samples</span>
<span class="sd">    :type header: dict or :class:`~obspy.core.trace.Stats`</span>
<span class="sd">    :param header: Dictionary containing header fields</span>

<span class="sd">    :var id: A SEED compatible identifier of the trace.</span>
<span class="sd">    :var stats: A container :class:`~obspy.core.trace.Stats` for additional</span>
<span class="sd">        header information of the trace.</span>
<span class="sd">    :var data: Data samples in a :class:`~numpy.ndarray` or</span>
<span class="sd">        :class:`~numpy.ma.MaskedArray`</span>

<span class="sd">    .. rubric:: Supported Operations</span>

<span class="sd">    ``trace = traceA + traceB``</span>
<span class="sd">        Merges traceA and traceB into one new trace object.</span>
<span class="sd">        See also: :meth:`Trace.__add__`.</span>
<span class="sd">    ``len(trace)``</span>
<span class="sd">        Returns the number of samples contained in the trace. That is</span>
<span class="sd">        it es equal to ``len(trace.data)``.</span>
<span class="sd">        See also: :meth:`Trace.__len__`.</span>
<span class="sd">    ``str(trace)``</span>
<span class="sd">        Returns basic information about the trace object.</span>
<span class="sd">        See also: :meth:`Trace.__str__`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Trace.__init__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__init__.html#obspy.core.trace.Trace.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># make sure Trace gets initialized with suitable ndarray as self.data</span>
        <span class="c1"># otherwise we could end up with e.g. a list object in self.data</span>
        <span class="n">_data_sanity_checks</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># set some defaults if not set yet</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">header</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;npts&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">Stats</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="c1"># set data without changing npts in stats object (for headonly option)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Trace</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span>

    <span class="nd">@meta</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="Trace.__eq__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__eq__.html#obspy.core.trace.Trace.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements rich comparison of Trace objects for &quot;==&quot; operator.</span>

<span class="sd">        Traces are the same, if both their data and stats are the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if other object is a Trace</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># comparison of Stats objects is supported by underlying AttribDict</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">stats</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># comparison of ndarrays is supported by NumPy</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Trace.__ne__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__ne__.html#obspy.core.trace.Trace.__ne__">[docs]</a>    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements rich comparison of Trace objects for &quot;!=&quot; operator.</span>

<span class="sd">        Calls __eq__() and returns the opposite.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.__lt__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__lt__.html#obspy.core.trace.Trace.__lt__">[docs]</a>    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Too ambiguous, throw an Error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Too ambiguous, therefore not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.__le__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__le__.html#obspy.core.trace.Trace.__le__">[docs]</a>    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Too ambiguous, throw an Error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Too ambiguous, therefore not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.__gt__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__gt__.html#obspy.core.trace.Trace.__gt__">[docs]</a>    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Too ambiguous, throw an Error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Too ambiguous, therefore not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.__ge__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__ge__.html#obspy.core.trace.Trace.__ge__">[docs]</a>    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Too ambiguous, throw an Error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Too ambiguous, therefore not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.__nonzero__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__nonzero__.html#obspy.core.trace.Trace.__nonzero__">[docs]</a>    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        No data means no trace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return short summary string of the current trace.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        :return: Short summary string of the current trace containing the SEED</span>
<span class="sd">            identifier, start time, end time, sampling rate and number of</span>
<span class="sd">            points of the current trace.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(header={&#39;station&#39;:&#39;FUR&#39;, &#39;network&#39;:&#39;GR&#39;})</span>
<span class="sd">        &gt;&gt;&gt; str(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        &#39;GR.FUR.. | 1970-01-01T00:00:00.000000Z - ... | 1.0 Hz, 0 samples&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set fixed id width</span>
        <span class="k">if</span> <span class="n">id_length</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%%</span><span class="s2">-</span><span class="si">%d</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">id_length</span><span class="p">)</span>
            <span class="n">trace_id</span> <span class="o">=</span> <span class="n">out</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trace_id</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="c1"># output depending on delta or sampling rate bigger than one</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="s1">&#39;preview&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">preview</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="s1">&#39; | &#39;</span>\
                    <span class="s2">&quot;</span><span class="si">%(starttime)s</span><span class="s2"> - </span><span class="si">%(endtime)s</span><span class="s2"> | &quot;</span> <span class="o">+</span> \
                    <span class="s2">&quot;</span><span class="si">%(delta).1f</span><span class="s2"> s, </span><span class="si">%(npts)d</span><span class="s2"> samples [preview]&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="s1">&#39; | &#39;</span>\
                    <span class="s2">&quot;</span><span class="si">%(starttime)s</span><span class="s2"> - </span><span class="si">%(endtime)s</span><span class="s2"> | &quot;</span> <span class="o">+</span> \
                    <span class="s2">&quot;</span><span class="si">%(delta).1f</span><span class="s2"> s, </span><span class="si">%(npts)d</span><span class="s2"> samples&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="s1">&#39;preview&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">preview</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="s1">&#39; | &#39;</span>\
                    <span class="s2">&quot;</span><span class="si">%(starttime)s</span><span class="s2"> - </span><span class="si">%(endtime)s</span><span class="s2"> | &quot;</span> <span class="o">+</span> \
                    <span class="s2">&quot;</span><span class="si">%(sampling_rate).1f</span><span class="s2"> Hz, </span><span class="si">%(npts)d</span><span class="s2"> samples [preview]&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="s1">&#39; | &#39;</span>\
                    <span class="s2">&quot;</span><span class="si">%(starttime)s</span><span class="s2"> - </span><span class="si">%(endtime)s</span><span class="s2"> | &quot;</span> <span class="o">+</span> \
                    <span class="s2">&quot;</span><span class="si">%(sampling_rate).1f</span><span class="s2"> Hz, </span><span class="si">%(npts)d</span><span class="s2"> samples&quot;</span>
        <span class="c1"># check for masked array</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">count_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s1">&#39; (masked)&#39;</span>
        <span class="k">return</span> <span class="n">trace_id</span> <span class="o">+</span> <span class="n">out</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>

<div class="viewcode-block" id="Trace._repr_pretty_"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace._repr_pretty_.html#obspy.core.trace.Trace._repr_pretty_">[docs]</a>    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Trace.__len__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__len__.html#obspy.core.trace.Trace.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of data samples of the current trace.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        :return: Number of data samples.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; trace = Trace(data=np.array([1, 2, 3, 4]))</span>
<span class="sd">        &gt;&gt;&gt; trace.count()</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; len(trace)</span>
<span class="sd">        4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

    <span class="n">count</span> <span class="o">=</span> <span class="fm">__len__</span>

<div class="viewcode-block" id="Trace.__setattr__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__setattr__.html#obspy.core.trace.Trace.__setattr__">[docs]</a>    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __setattr__ method of Trace object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># any change in Trace.data will dynamically set Trace.stats.npts</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;data&#39;</span><span class="p">:</span>
            <span class="n">_data_sanity_checks</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Trace</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.__getitem__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__getitem__.html#obspy.core.trace.Trace.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __getitem__ method of Trace object.</span>

<span class="sd">        :rtype: list</span>
<span class="sd">        :return: List of data points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>

<div class="viewcode-block" id="Trace.__mul__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__mul__.html#obspy.core.trace.Trace.__mul__">[docs]</a>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Stream containing num copies of this trace.</span>

<span class="sd">        :type num: int</span>
<span class="sd">        :param num: Number of copies.</span>
<span class="sd">        :returns: New ObsPy Stream object.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; tr = read()[0]</span>
<span class="sd">        &gt;&gt;&gt; st = tr * 5</span>
<span class="sd">        &gt;&gt;&gt; len(st)</span>
<span class="sd">        5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Integer expected&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">Stream</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">st</span></div>

<div class="viewcode-block" id="Trace.__div__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__div__.html#obspy.core.trace.Trace.__div__">[docs]</a>    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split Trace into new Stream containing num Traces of the same size.</span>

<span class="sd">        :type num: int</span>
<span class="sd">        :param num: Number of traces in returned Stream. Last trace may contain</span>
<span class="sd">            lesser samples.</span>
<span class="sd">        :returns: New ObsPy Stream object.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; tr = read()[0]</span>
<span class="sd">        &gt;&gt;&gt; print(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; st = tr / 7</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        7 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 429 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:07.290000Z ... | 100.0 Hz, 429 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:11.580000Z ... | 100.0 Hz, 429 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:15.870000Z ... | 100.0 Hz, 429 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:20.160000Z ... | 100.0 Hz, 429 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:24.450000Z ... | 100.0 Hz, 429 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:28.740000Z ... | 100.0 Hz, 426 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Integer expected&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">Stream</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">rest_length</span> <span class="o">=</span> <span class="n">total_length</span> <span class="o">%</span> <span class="n">num</span>
        <span class="k">if</span> <span class="n">rest_length</span><span class="p">:</span>
            <span class="n">packet_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_length</span> <span class="o">//</span> <span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">packet_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_length</span> <span class="o">//</span> <span class="n">num</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
        <span class="n">tend</span> <span class="o">=</span> <span class="n">tstart</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">packet_length</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">tend</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
            <span class="n">tend</span> <span class="o">=</span> <span class="n">tstart</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">packet_length</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">st</span></div>

    <span class="c1"># Py3k: &#39;/&#39; does not map to __div__ anymore in Python 3</span>
    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>

<div class="viewcode-block" id="Trace.__mod__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__mod__.html#obspy.core.trace.Trace.__mod__">[docs]</a>    <span class="k">def</span> <span class="nf">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split Trace into new Stream containing Traces with num samples.</span>

<span class="sd">        :type num: int</span>
<span class="sd">        :param num: Number of samples in each trace in returned Stream. Last</span>
<span class="sd">            trace may contain lesser samples.</span>
<span class="sd">        :returns: New ObsPy Stream object.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; tr = read()[0]</span>
<span class="sd">        &gt;&gt;&gt; print(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; st = tr % 800</span>
<span class="sd">        &gt;&gt;&gt; print(st)  # doctest: +ELLIPSIS</span>
<span class="sd">        4 Trace(s) in Stream:</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03.000000Z ... | 100.0 Hz, 800 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:11.000000Z ... | 100.0 Hz, 800 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:19.000000Z ... | 100.0 Hz, 800 samples</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:27.000000Z ... | 100.0 Hz, 600 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Integer expected&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Positive Integer expected&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">Stream</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">total_length</span><span class="p">:</span>
            <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">st</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
        <span class="n">tend</span> <span class="o">=</span> <span class="n">tstart</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">tend</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
            <span class="n">tend</span> <span class="o">=</span> <span class="n">tstart</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">tstart</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">st</span></div>

<div class="viewcode-block" id="Trace.__add__"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.__add__.html#obspy.core.trace.Trace.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">interpolation_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sanity_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add another Trace object to current trace.</span>

<span class="sd">        :type method: int, optional</span>
<span class="sd">        :param method: Method to handle overlaps of traces. Defaults to ``0``.</span>
<span class="sd">            See the `Handling Overlaps`_ section below for further details.</span>
<span class="sd">        :type fill_value: int, float, str or ``None``, optional</span>
<span class="sd">        :param fill_value: Fill value for gaps. Defaults to ``None``. Traces</span>
<span class="sd">            will be converted to NumPy masked arrays if no value is given and</span>
<span class="sd">            gaps are present. If the keyword ``&#39;latest&#39;`` is provided it will</span>
<span class="sd">            use the latest value before the gap. If keyword ``&#39;interpolate&#39;``</span>
<span class="sd">            is provided, missing values are linearly interpolated (not</span>
<span class="sd">            changing the data type e.g. of integer valued traces).</span>
<span class="sd">            See the `Handling Gaps`_ section below for further details.</span>
<span class="sd">        :type interpolation_samples: int, optional</span>
<span class="sd">        :param interpolation_samples: Used only for ``method=1``. It specifies</span>
<span class="sd">            the number of samples which are used to interpolate between</span>
<span class="sd">            overlapping traces. Defaults to ``0``. If set to ``-1`` all</span>
<span class="sd">            overlapping samples are interpolated.</span>
<span class="sd">        :type sanity_checks: bool, optional</span>
<span class="sd">        :param sanity_checks: Enables some sanity checks before merging traces.</span>
<span class="sd">            Defaults to ``True``.</span>

<span class="sd">        Trace data will be converted into a NumPy masked array data type if</span>
<span class="sd">        any gaps are present. This behavior may be prevented by setting the</span>
<span class="sd">        ``fill_value`` parameter. The ``method`` argument controls the</span>
<span class="sd">        handling of overlapping data values.</span>

<span class="sd">        Sampling rate, data type and trace.id of both traces must match.</span>

<span class="sd">        .. rubric:: _`Handling Overlaps`</span>

<span class="sd">        ======  ===============================================================</span>
<span class="sd">        Method  Description</span>
<span class="sd">        ======  ===============================================================</span>
<span class="sd">        0       Discard overlapping data. Overlaps are essentially treated the</span>
<span class="sd">                same way as gaps::</span>

<span class="sd">                    Trace 1: AAAAAAAA</span>
<span class="sd">                    Trace 2:     FFFFFFFF</span>
<span class="sd">                    1 + 2  : AAAA----FFFF</span>

<span class="sd">                Contained traces with differing data will be marked as gap::</span>

<span class="sd">                    Trace 1: AAAAAAAAAAAA</span>
<span class="sd">                    Trace 2:     FF</span>
<span class="sd">                    1 + 2  : AAAA--AAAAAA</span>

<span class="sd">                Missing data can be merged in from a different trace::</span>

<span class="sd">                    Trace 1: AAAA--AAAAAA (contained trace, missing samples)</span>
<span class="sd">                    Trace 2:     FF</span>
<span class="sd">                    1 + 2  : AAAAFFAAAAAA</span>
<span class="sd">        1       Discard data of the previous trace assuming the following trace</span>
<span class="sd">                contains data with a more correct time value. The parameter</span>
<span class="sd">                ``interpolation_samples`` specifies the number of samples used</span>
<span class="sd">                to linearly interpolate between the two traces in order to</span>
<span class="sd">                prevent steps. Note that if there are gaps inside, the</span>
<span class="sd">                returned array is still a masked array, only if ``fill_value``</span>
<span class="sd">                is set, the returned array is a normal array and gaps are</span>
<span class="sd">                filled with fill value.</span>

<span class="sd">                No interpolation (``interpolation_samples=0``)::</span>

<span class="sd">                    Trace 1: AAAAAAAA</span>
<span class="sd">                    Trace 2:     FFFFFFFF</span>
<span class="sd">                    1 + 2  : AAAAFFFFFFFF</span>

<span class="sd">                Interpolate first two samples (``interpolation_samples=2``)::</span>

<span class="sd">                    Trace 1: AAAAAAAA</span>
<span class="sd">                    Trace 2:     FFFFFFFF</span>
<span class="sd">                    1 + 2  : AAAACDFFFFFF (interpolation_samples=2)</span>

<span class="sd">                Interpolate all samples (``interpolation_samples=-1``)::</span>

<span class="sd">                    Trace 1: AAAAAAAA</span>
<span class="sd">                    Trace 2:     FFFFFFFF</span>
<span class="sd">                    1 + 2  : AAAABCDEFFFF</span>

<span class="sd">                Any contained traces with different data will be discarded::</span>

<span class="sd">                    Trace 1: AAAAAAAAAAAA (contained trace)</span>
<span class="sd">                    Trace 2:     FF</span>
<span class="sd">                    1 + 2  : AAAAAAAAAAAA</span>

<span class="sd">                Missing data can be merged in from a different trace::</span>

<span class="sd">                    Trace 1: AAAA--AAAAAA (contained trace, missing samples)</span>
<span class="sd">                    Trace 2:     FF</span>
<span class="sd">                    1 + 2  : AAAAFFAAAAAA</span>
<span class="sd">        ======  ===============================================================</span>

<span class="sd">        .. rubric:: _`Handling gaps`</span>

<span class="sd">        1. Traces with gaps and ``fill_value=None`` (default)::</span>

<span class="sd">            Trace 1: AAAA</span>
<span class="sd">            Trace 2:         FFFF</span>
<span class="sd">            1 + 2  : AAAA----FFFF</span>

<span class="sd">        2. Traces with gaps and given ``fill_value=0``::</span>

<span class="sd">            Trace 1: AAAA</span>
<span class="sd">            Trace 2:         FFFF</span>
<span class="sd">            1 + 2  : AAAA0000FFFF</span>

<span class="sd">        3. Traces with gaps and given ``fill_value=&#39;latest&#39;``::</span>

<span class="sd">            Trace 1: ABCD</span>
<span class="sd">            Trace 2:         FFFF</span>
<span class="sd">            1 + 2  : ABCDDDDDFFFF</span>

<span class="sd">        4. Traces with gaps and given ``fill_value=&#39;interpolate&#39;``::</span>

<span class="sd">            Trace 1: AAAA</span>
<span class="sd">            Trace 2:         FFFF</span>
<span class="sd">            1 + 2  : AAAABCDEFFFF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sanity_checks</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="c1">#  check id</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span> <span class="o">!=</span> <span class="n">trace</span><span class="o">.</span><span class="n">get_id</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Trace ID differs&quot;</span><span class="p">)</span>
            <span class="c1">#  check sample rate</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">!=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Sampling rate differs&quot;</span><span class="p">)</span>
            <span class="c1">#  check calibration factor</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">calib</span> <span class="o">!=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">calib</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Calibration factor differs&quot;</span><span class="p">)</span>
            <span class="c1"># check data type</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">trace</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Data type differs&quot;</span><span class="p">)</span>
        <span class="c1"># check times</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">&lt;=</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">:</span>
            <span class="n">lt</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">trace</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">lt</span> <span class="o">=</span> <span class="n">trace</span>
        <span class="c1"># check whether to use the latest value to fill a gap</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="o">==</span> <span class="s2">&quot;latest&quot;</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">fill_value</span> <span class="o">==</span> <span class="s2">&quot;interpolate&quot;</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">sr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">rt</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span> <span class="n">lt</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">)</span> <span class="o">*</span> <span class="n">sr</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">compatibility</span><span class="o">.</span><span class="n">round_away</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">delta_endtime</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">-</span> <span class="n">rt</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span>
        <span class="c1"># create the returned trace</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">lt</span><span class="o">.</span><span class="n">stats</span><span class="p">))</span>
        <span class="c1"># check if overlap or gap</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">delta_endtime</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># overlap</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="n">delta</span><span class="p">:],</span> <span class="n">rt</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">delta</span><span class="p">])):</span>
                <span class="c1"># check if data are the same</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">delta</span><span class="p">],</span> <span class="n">rt</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="n">create_empty_data_chunk</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                                  <span class="n">fill_value</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">delta</span><span class="p">],</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">rt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">delta</span><span class="p">:]]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">interpolation_samples</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ls</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="n">delta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">ls</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">interpolation_samples</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">interpolation_samples</span> <span class="o">=</span> <span class="n">delta</span>
                <span class="k">elif</span> <span class="n">interpolation_samples</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                    <span class="n">interpolation_samples</span> <span class="o">=</span> <span class="n">delta</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">rs</span> <span class="o">=</span> <span class="n">rt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">interpolation_samples</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># contained trace</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># include left and right sample (delta + 2)</span>
                    <span class="n">interpolation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span>
                                                <span class="n">interpolation_samples</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="c1"># cut ls and rs and ensure correct data type</span>
                    <span class="n">interpolation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">interpolation</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                               <span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">delta</span><span class="p">],</span> <span class="n">interpolation</span><span class="p">,</span>
                            <span class="n">rt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">interpolation_samples</span><span class="p">:]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">elif</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">delta_endtime</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># contained trace</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
            <span class="n">lenrt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lt</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">lenrt</span>
            <span class="c1"># check if data are the same</span>
            <span class="n">data_equal</span> <span class="o">=</span> <span class="p">(</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">t1</span><span class="p">:</span><span class="n">t2</span><span class="p">]</span> <span class="o">==</span> <span class="n">rt</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># force a masked array and fill it for check of equality of valid</span>
            <span class="c1"># data points</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data_equal</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">()):</span>
                <span class="c1"># if all (unmasked) data are equal,</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_equal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">t1</span><span class="p">:</span><span class="n">t2</span><span class="p">])</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">rt</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                    <span class="n">data_same</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">y</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">data_same</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="c1"># convert back to maximum dtype of original data</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">t1</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">t2</span><span class="p">:]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gap</span> <span class="o">=</span> <span class="n">create_empty_data_chunk</span><span class="p">(</span><span class="n">lenrt</span><span class="p">,</span> <span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">t1</span><span class="p">],</span> <span class="n">gap</span><span class="p">,</span> <span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">t2</span><span class="p">:]]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">elif</span> <span class="n">delta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># exact fit - merge both traces</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rt</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># gap</span>
            <span class="c1"># use fixed value or interpolate in between</span>
            <span class="n">gap</span> <span class="o">=</span> <span class="n">create_empty_data_chunk</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">gap</span><span class="p">,</span> <span class="n">rt</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
        <span class="c1"># merge traces depending on NumPy array type</span>
        <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">)</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">lt</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Check if we can downgrade to normal ndarray</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">count_masked</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="n">out</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;&#39;getId&#39; has been renamed to &quot;</span>  <span class="c1"># noqa</span>
        <span class="s2">&quot;&#39;get_id&#39;. Use that instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getId</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        DEPRECATED: &#39;getId&#39; has been renamed to</span>
<span class="sd">        &#39;get_id&#39;. Use that instead.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_id</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Trace.get_id"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.get_id.html#obspy.core.trace.Trace.get_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a SEED compatible identifier of the trace.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        :return: SEED identifier</span>

<span class="sd">        The SEED identifier contains the network, station, location and channel</span>
<span class="sd">        code for the current Trace object.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; meta = {&#39;station&#39;: &#39;MANZ&#39;, &#39;network&#39;: &#39;BW&#39;, &#39;channel&#39;: &#39;EHZ&#39;}</span>
<span class="sd">        &gt;&gt;&gt; tr = Trace(header=meta)</span>
<span class="sd">        &gt;&gt;&gt; print(tr.get_id())</span>
<span class="sd">        BW.MANZ..EHZ</span>
<span class="sd">        &gt;&gt;&gt; print(tr.id)</span>
<span class="sd">        BW.MANZ..EHZ</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%(network)s</span><span class="s2">.</span><span class="si">%(station)s</span><span class="s2">.</span><span class="si">%(location)s</span><span class="s2">.</span><span class="si">%(channel)s</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span></div>

    <span class="nb">id</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_id</span><span class="p">)</span>

<div class="viewcode-block" id="Trace.plot"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.plot.html#obspy.core.trace.Trace.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a simple graph of the current trace.</span>

<span class="sd">        Various options are available to change the appearance of the waveform</span>
<span class="sd">        plot. Please see :meth:`~obspy.core.stream.Stream.plot` method for all</span>
<span class="sd">        possible options.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; tr = st[0]</span>
<span class="sd">        &gt;&gt;&gt; tr.plot()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read</span>
<span class="sd">            st = read()</span>
<span class="sd">            tr = st[0]</span>
<span class="sd">            tr.plot()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">obspy.imaging.waveform</span> <span class="k">import</span> <span class="n">WaveformPlotting</span>
        <span class="n">waveform</span> <span class="o">=</span> <span class="n">WaveformPlotting</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">waveform</span><span class="o">.</span><span class="n">plot_waveform</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.spectrogram"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.spectrogram.html#obspy.core.trace.Trace.spectrogram">[docs]</a>    <span class="k">def</span> <span class="nf">spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a spectrogram plot of the trace.</span>

<span class="sd">        For details on kwargs that can be used to customize the spectrogram</span>
<span class="sd">        plot see :func:`~obspy.imaging.spectrogram.spectrogram`.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; tr = st[0]</span>
<span class="sd">        &gt;&gt;&gt; tr.spectrogram()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read</span>
<span class="sd">            st = read()</span>
<span class="sd">            tr = st[0]</span>
<span class="sd">            tr.spectrogram(sphinx=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set some default values</span>
        <span class="k">if</span> <span class="s1">&#39;samp_rate&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;samp_rate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="k">if</span> <span class="s1">&#39;title&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">obspy.imaging.spectrogram</span> <span class="k">import</span> <span class="n">spectrogram</span>
        <span class="k">return</span> <span class="n">spectrogram</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.write"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.write.html#obspy.core.trace.Trace.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save current trace into a file.</span>

<span class="sd">        :type filename: str</span>
<span class="sd">        :param filename: The name of the file to write.</span>
<span class="sd">        :type format: str</span>
<span class="sd">        :param format: The format to write must be specified. See</span>
<span class="sd">            :meth:`obspy.core.stream.Stream.write` method for possible</span>
<span class="sd">            formats.</span>
<span class="sd">        :param kwargs: Additional keyword arguments passed to the underlying</span>
<span class="sd">            waveform writer method.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace()</span>
<span class="sd">        &gt;&gt;&gt; tr.write(&quot;out.mseed&quot;, format=&quot;MSEED&quot;)  # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we need to import here in order to prevent a circular import of</span>
        <span class="c1"># Stream and Trace classes</span>
        <span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">Stream</span>
        <span class="n">Stream</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace._ltrim"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace._ltrim.html#obspy.core.trace.Trace._ltrim">[docs]</a>    <span class="k">def</span> <span class="nf">_ltrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cut current trace to given start time. For more info see</span>
<span class="sd">        :meth:`~obspy.core.trace.Trace.trim`.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.arange(0, 10))</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.delta = 1.0</span>
<span class="sd">        &gt;&gt;&gt; tr._ltrim(tr.stats.starttime + 8)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.data</span>
<span class="sd">        array([8, 9])</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.starttime</span>
<span class="sd">        UTCDateTime(1970, 1, 1, 0, 0, 8)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">org_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">starttime</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">+</span> <span class="n">starttime</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="c1"># check if in boundary</span>
        <span class="k">if</span> <span class="n">nearest_sample</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">compatibility</span><span class="o">.</span><span class="n">round_away</span><span class="p">(</span>
                <span class="p">(</span><span class="n">starttime</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
            <span class="c1"># due to rounding and npts starttime must always be right of</span>
            <span class="c1"># self.stats.starttime, rtrim relies on it</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pad</span><span class="p">:</span>
                <span class="n">npts</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>  <span class="c1"># use this as a start</span>
                <span class="n">newstarttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span> <span class="n">npts</span> <span class="o">/</span> \
                    <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
                <span class="n">newdelta</span> <span class="o">=</span> <span class="n">compatibility</span><span class="o">.</span><span class="n">round_away</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">starttime</span> <span class="o">-</span> <span class="n">newstarttime</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">newdelta</span> <span class="o">-</span> <span class="n">npts</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span> <span class="n">starttime</span><span class="p">)</span> <span class="o">*</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="mi">7</span><span class="p">)))</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># Adjust starttime only if delta is greater than zero or if the values</span>
        <span class="c1"># are padded with masked arrays.</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">pad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+=</span> <span class="n">delta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pad</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pad</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">gap</span> <span class="o">=</span> <span class="n">create_empty_data_chunk</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                              <span class="n">fill_value</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># create_empty_data_chunk returns negative ValueError ?? for</span>
                <span class="c1"># too large number of points, e.g. 189336539799</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Time offset between starttime and &quot;</span>
                                <span class="s2">&quot;trace.starttime too large&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">starttime</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">org_dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">delta</span><span class="p">:]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="c1"># a huge numbers for delta raises an IndexError</span>
                <span class="c1"># here we just create empty array with same dtype</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">org_dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace._rtrim"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace._rtrim.html#obspy.core.trace.Trace._rtrim">[docs]</a>    <span class="k">def</span> <span class="nf">_rtrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cut current trace to given end time. For more info see</span>
<span class="sd">        :meth:`~obspy.core.trace.Trace.trim`.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.arange(0, 10))</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.delta = 1.0</span>
<span class="sd">        &gt;&gt;&gt; tr._rtrim(tr.stats.starttime + 2)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.data</span>
<span class="sd">        array([0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.endtime</span>
<span class="sd">        UTCDateTime(1970, 1, 1, 0, 0, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">org_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endtime</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endtime</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">endtime</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">)</span> <span class="o">-</span> <span class="n">endtime</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endtime</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="c1"># check if in boundary</span>
        <span class="k">if</span> <span class="n">nearest_sample</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">compatibility</span><span class="o">.</span><span class="n">round_away</span><span class="p">(</span>
                <span class="p">(</span><span class="n">endtime</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span> <span class="o">*</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># solution for #127, however some tests need to be changed</span>
            <span class="c1"># delta = -1*int(math.floor(compatibility.round_away(</span>
            <span class="c1">#     (self.stats.endtime - endtime) * \</span>
            <span class="c1">#     self.stats.sampling_rate, 7)))</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">endtime</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">)</span> <span class="o">*</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="mi">7</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pad</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pad</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">gap</span> <span class="o">=</span> <span class="n">create_empty_data_chunk</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                              <span class="n">fill_value</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># create_empty_data_chunk returns negative ValueError ?? for</span>
                <span class="c1"># too large number of points, e.g. 189336539799</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Time offset between starttime and &quot;</span> <span class="o">+</span>
                                <span class="s2">&quot;trace.starttime too large&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">gap</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">endtime</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">+</span> \
                <span class="n">delta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">org_dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="c1"># cut from right</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta</span>
        <span class="k">if</span> <span class="n">endtime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">total</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.trim"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.trim.html#obspy.core.trace.Trace.trim">[docs]</a>    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cut current trace to given start and end time.</span>

<span class="sd">        :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime`, optional</span>
<span class="sd">        :param starttime: Specify the start time.</span>
<span class="sd">        :type endtime: :class:`~obspy.core.utcdatetime.UTCDateTime`, optional</span>
<span class="sd">        :param endtime: Specify the end time.</span>
<span class="sd">        :type pad: bool, optional</span>
<span class="sd">        :param pad: Gives the possibility to trim at time points outside the</span>
<span class="sd">            time frame of the original trace, filling the trace with the</span>
<span class="sd">            given ``fill_value``. Defaults to ``False``.</span>
<span class="sd">        :type nearest_sample: bool, optional</span>
<span class="sd">        :param nearest_sample: If set to ``True``, the closest sample is</span>
<span class="sd">            selected, if set to ``False``, the inner (next sample for a</span>
<span class="sd">            start time border, previous sample for an end time border) sample</span>
<span class="sd">            containing the time is selected. Defaults to ``True``.</span>

<span class="sd">            Given the following trace containing 6 samples, &quot;|&quot; are the</span>
<span class="sd">            sample points, &quot;A&quot; is the requested starttime::</span>

<span class="sd">                |         |A        |         |       B |         |</span>
<span class="sd">                1         2         3         4         5         6</span>

<span class="sd">            ``nearest_sample=True`` will select samples 2-5,</span>
<span class="sd">            ``nearest_sample=False`` will select samples 3-4 only.</span>

<span class="sd">        :type fill_value: int, float or ``None``, optional</span>
<span class="sd">        :param fill_value: Fill value for gaps. Defaults to ``None``. Traces</span>
<span class="sd">            will be converted to NumPy masked arrays if no value is given and</span>
<span class="sd">            gaps are present.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.arange(0, 10))</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.delta = 1.0</span>
<span class="sd">        &gt;&gt;&gt; t = tr.stats.starttime</span>
<span class="sd">        &gt;&gt;&gt; tr.trim(t + 2.000001, t + 7.999999)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.data</span>
<span class="sd">        array([2, 3, 4, 5, 6, 7, 8])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check time order and swap eventually</span>
        <span class="k">if</span> <span class="n">starttime</span> <span class="ow">and</span> <span class="n">endtime</span> <span class="ow">and</span> <span class="n">starttime</span> <span class="o">&gt;</span> <span class="n">endtime</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;startime is larger than endtime&quot;</span><span class="p">)</span>
        <span class="c1"># cut it</span>
        <span class="k">if</span> <span class="n">starttime</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ltrim</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">,</span>
                        <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">endtime</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rtrim</span><span class="p">(</span><span class="n">endtime</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">,</span>
                        <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="c1"># if pad=True and fill_value is given convert to NumPy ndarray</span>
        <span class="k">if</span> <span class="n">pad</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># numpy.ndarray object has no attribute &#39;filled&#39; - ignoring</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.slice"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.slice.html#obspy.core.trace.Trace.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Trace object with data going from start to end time.</span>

<span class="sd">        :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param starttime: Specify the start time of slice.</span>
<span class="sd">        :type endtime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param endtime: Specify the end time of slice.</span>
<span class="sd">        :type nearest_sample: bool, optional</span>
<span class="sd">        :param nearest_sample: If set to ``True``, the closest sample is</span>
<span class="sd">            selected, if set to ``False``, the inner (next sample for a</span>
<span class="sd">            start time border, previous sample for an end time border) sample</span>
<span class="sd">            containing the time is selected. Defaults to ``True``.</span>

<span class="sd">            Given the following trace containing 6 samples, &quot;|&quot; are the</span>
<span class="sd">            sample points, &quot;A&quot; is the requested starttime::</span>

<span class="sd">                |         |A        |         |       B |         |</span>
<span class="sd">                1         2         3         4         5         6</span>

<span class="sd">            ``nearest_sample=True`` will select samples 2-5,</span>
<span class="sd">            ``nearest_sample=False`` will select samples 3-4 only.</span>

<span class="sd">        :return: New :class:`~obspy.core.trace.Trace` object. Does not copy</span>
<span class="sd">            data but just passes a reference to it.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.arange(0, 10))</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.delta = 1.0</span>
<span class="sd">        &gt;&gt;&gt; t = tr.stats.starttime</span>
<span class="sd">        &gt;&gt;&gt; tr2 = tr.slice(t + 2, t + 8)</span>
<span class="sd">        &gt;&gt;&gt; tr2.data</span>
<span class="sd">        array([2, 3, 4, 5, 6, 7, 8])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span>
                <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tr</span></div>

<div class="viewcode-block" id="Trace.slide"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.slide.html#obspy.core.trace.Trace.slide">[docs]</a>    <span class="k">def</span> <span class="nf">slide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_length</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
              <span class="n">include_partial_windows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nearest_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator yielding equal length sliding windows of the Trace.</span>

<span class="sd">        Please keep in mind that it only returns a new view of the original</span>
<span class="sd">        data. Any modifications are applied to the original data as well. If</span>
<span class="sd">        you don&#39;t want this you have to create a copy of the yielded</span>
<span class="sd">        windows. Also be aware that if you modify the original data and you</span>
<span class="sd">        have overlapping windows, all following windows are affected as well.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; import obspy</span>
<span class="sd">        &gt;&gt;&gt; tr = obspy.read()[0]</span>
<span class="sd">        &gt;&gt;&gt; for windowed_tr in tr.slide(window_length=10.0, step=10.0):</span>
<span class="sd">        ...     print(&quot;---&quot;)  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS</span>
<span class="sd">        ...     print(windowed_tr)</span>
<span class="sd">        ---</span>
<span class="sd">        ... | 2009-08-24T00:20:03.000000Z - 2009-08-24T00:20:13.000000Z | ...</span>
<span class="sd">        ---</span>
<span class="sd">        ... | 2009-08-24T00:20:13.000000Z - 2009-08-24T00:20:23.000000Z | ...</span>


<span class="sd">        :param window_length: The length of each window in seconds.</span>
<span class="sd">        :type window_length: float</span>
<span class="sd">        :param step: The step between the start times of two successive</span>
<span class="sd">            windows in seconds. Can be negative if an offset is given.</span>
<span class="sd">        :type step: float</span>
<span class="sd">        :param offset: The offset of the first window in seconds relative to</span>
<span class="sd">            the start time of the whole interval.</span>
<span class="sd">        :type offset: float</span>
<span class="sd">        :param include_partial_windows: Determines if windows that are</span>
<span class="sd">            shorter then 99.9 % of the desired length are returned.</span>
<span class="sd">        :type include_partial_windows: bool</span>
<span class="sd">        :param nearest_sample: If set to ``True``, the closest sample is</span>
<span class="sd">            selected, if set to ``False``, the inner (next sample for a</span>
<span class="sd">            start time border, previous sample for an end time border) sample</span>
<span class="sd">            containing the time is selected. Defaults to ``True``.</span>

<span class="sd">            Given the following trace containing 6 samples, &quot;|&quot; are the</span>
<span class="sd">            sample points, &quot;A&quot; is the requested starttime::</span>

<span class="sd">                |         |A        |         |       B |         |</span>
<span class="sd">                1         2         3         4         5         6</span>

<span class="sd">            ``nearest_sample=True`` will select samples 2-5,</span>
<span class="sd">            ``nearest_sample=False`` will select samples 3-4 only.</span>
<span class="sd">        :type nearest_sample: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="n">get_window_times</span><span class="p">(</span>
            <span class="n">starttime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
            <span class="n">endtime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">,</span>
            <span class="n">window_length</span><span class="o">=</span><span class="n">window_length</span><span class="p">,</span>
            <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">include_partial_windows</span><span class="o">=</span><span class="n">include_partial_windows</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span>
                             <span class="n">nearest_sample</span><span class="o">=</span><span class="n">nearest_sample</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">StopIteration</span></div>

<div class="viewcode-block" id="Trace.verify"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.verify.html#obspy.core.trace.Trace.verify">[docs]</a>    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify current trace object against available meta data.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.array([1,2,3,4]))</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.npts = 100</span>
<span class="sd">        &gt;&gt;&gt; tr.verify()  #doctest: +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        Exception: ntps(100) differs from data size(4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;ntps(</span><span class="si">%d</span><span class="s2">) differs from data size(</span><span class="si">%d</span><span class="s2">)&quot;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;End time(</span><span class="si">%s</span><span class="s2">) before start time(</span><span class="si">%s</span><span class="s2">)&quot;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">))</span>
        <span class="n">sr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">compatibility</span><span class="o">.</span><span class="n">round_away</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="n">sr</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Sample rate(</span><span class="si">%f</span><span class="s2">) * time delta(</span><span class="si">%.4lf</span><span class="s2">) + 1 != data len(</span><span class="si">%d</span><span class="s2">)&quot;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
            <span class="c1"># Check if the endtime fits the starttime, npts and sampling_rate.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;End time is not the time of the last sample.&quot;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Data size should be 0, but is </span><span class="si">%d</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">Stats</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Attribute stats must be an instance of obspy.core.Stats&quot;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Trace data should be stored as numpy.ndarray in the &quot;</span> <span class="o">+</span> \
                  <span class="s2">&quot;system specific byte order.&quot;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.simulate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.simulate.html#obspy.core.trace.Trace.simulate">[docs]</a>    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paz_remove</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">paz_simulate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">remove_sensitivity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simulate_sensitivity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Correct for instrument response / Simulate new instrument response.</span>

<span class="sd">        :type paz_remove: dict, None</span>
<span class="sd">        :param paz_remove: Dictionary containing keys ``&#39;poles&#39;``, ``&#39;zeros&#39;``,</span>
<span class="sd">            ``&#39;gain&#39;`` (A0 normalization factor). Poles and zeros must be a</span>
<span class="sd">            list of complex floating point numbers, gain must be of type float.</span>
<span class="sd">            Poles and Zeros are assumed to correct to m/s, SEED convention.</span>
<span class="sd">            Use ``None`` for no inverse filtering.</span>
<span class="sd">        :type paz_simulate: dict, None</span>
<span class="sd">        :param paz_simulate: Dictionary containing keys ``&#39;poles&#39;``,</span>
<span class="sd">            ``&#39;zeros&#39;``, ``&#39;gain&#39;``. Poles and zeros must be a list of complex</span>
<span class="sd">            floating point numbers, gain must be of type float. Or ``None`` for</span>
<span class="sd">            no simulation.</span>
<span class="sd">        :type remove_sensitivity: bool</span>
<span class="sd">        :param remove_sensitivity: Determines if data is divided by</span>
<span class="sd">            ``paz_remove[&#39;sensitivity&#39;]`` to correct for overall sensitivity of</span>
<span class="sd">            recording instrument (seismometer/digitizer) during instrument</span>
<span class="sd">            correction.</span>
<span class="sd">        :type simulate_sensitivity: bool</span>
<span class="sd">        :param simulate_sensitivity: Determines if data is multiplied with</span>
<span class="sd">            ``paz_simulate[&#39;sensitivity&#39;]`` to simulate overall sensitivity of</span>
<span class="sd">            new instrument (seismometer/digitizer) during instrument</span>
<span class="sd">            simulation.</span>

<span class="sd">        This function corrects for the original instrument response given by</span>
<span class="sd">        `paz_remove` and/or simulates a new instrument response given by</span>
<span class="sd">        `paz_simulate`.</span>
<span class="sd">        For additional information and more options to control the instrument</span>
<span class="sd">        correction/simulation (e.g. water level, demeaning, tapering, ...) see</span>
<span class="sd">        :func:`~obspy.signal.invsim.simulate_seismometer`.</span>

<span class="sd">        `paz_remove` and `paz_simulate` are expected to be dictionaries</span>
<span class="sd">        containing information on poles, zeros and gain (and usually also</span>
<span class="sd">        sensitivity).</span>

<span class="sd">        If both `paz_remove` and `paz_simulate` are specified, both steps are</span>
<span class="sd">        performed in one go in the frequency domain, otherwise only the</span>
<span class="sd">        specified step is performed.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Instead of the builtin deconvolution based on Poles and Zeros</span>
<span class="sd">            information, the deconvolution can be performed using evalresp</span>
<span class="sd">            instead by using the option `seedresp` (see documentation of</span>
<span class="sd">            :func:`~obspy.signal.invsim.simulate_seismometer` and the `ObsPy</span>
<span class="sd">            Tutorial &lt;https://docs.obspy.org/master/tutorial/code_snippets/\</span>
<span class="sd">seismometer_correction_simulation.html#using-a-resp-file&gt;`_.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of this trace.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; from obspy.signal.invsim import corn_freq_2_paz</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; tr = st[0]</span>
<span class="sd">        &gt;&gt;&gt; paz_sts2 = {&#39;poles&#39;: [-0.037004+0.037016j, -0.037004-0.037016j,</span>
<span class="sd">        ...                       -251.33+0j,</span>
<span class="sd">        ...                       -131.04-467.29j, -131.04+467.29j],</span>
<span class="sd">        ...             &#39;zeros&#39;: [0j, 0j],</span>
<span class="sd">        ...             &#39;gain&#39;: 60077000.0,</span>
<span class="sd">        ...             &#39;sensitivity&#39;: 2516778400.0}</span>
<span class="sd">        &gt;&gt;&gt; paz_1hz = corn_freq_2_paz(1.0, damp=0.707)</span>
<span class="sd">        &gt;&gt;&gt; paz_1hz[&#39;sensitivity&#39;] = 1.0</span>
<span class="sd">        &gt;&gt;&gt; tr.simulate(paz_remove=paz_sts2, paz_simulate=paz_1hz)</span>
<span class="sd">        ... # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.plot()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read</span>
<span class="sd">            from obspy.signal.invsim import corn_freq_2_paz</span>
<span class="sd">            st = read()</span>
<span class="sd">            tr = st[0]</span>
<span class="sd">            paz_sts2 = {&#39;poles&#39;: [-0.037004+0.037016j, -0.037004-0.037016j,</span>
<span class="sd">                                  -251.33+0j,</span>
<span class="sd">                                  -131.04-467.29j, -131.04+467.29j],</span>
<span class="sd">                        &#39;zeros&#39;: [0j, 0j],</span>
<span class="sd">                        &#39;gain&#39;: 60077000.0,</span>
<span class="sd">                        &#39;sensitivity&#39;: 2516778400.0}</span>
<span class="sd">            paz_1hz = corn_freq_2_paz(1.0, damp=0.707)</span>
<span class="sd">            paz_1hz[&#39;sensitivity&#39;] = 1.0</span>
<span class="sd">            tr.simulate(paz_remove=paz_sts2, paz_simulate=paz_1hz)</span>
<span class="sd">            tr.plot()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX accepting string &quot;self&quot; and using attached PAZ then</span>
        <span class="k">if</span> <span class="n">paz_remove</span> <span class="o">==</span> <span class="s1">&#39;self&#39;</span><span class="p">:</span>
            <span class="n">paz_remove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">paz</span>

        <span class="c1"># some convenience handling for evalresp type instrument correction</span>
        <span class="k">if</span> <span class="s2">&quot;seedresp&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">seedresp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;seedresp&quot;</span><span class="p">]</span>
            <span class="c1"># if date is missing use trace&#39;s starttime</span>
            <span class="n">seedresp</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span>
            <span class="c1"># if a Parser object is provided, get corresponding RESP</span>
            <span class="c1"># information</span>
            <span class="kn">from</span> <span class="nn">obspy.io.xseed</span> <span class="k">import</span> <span class="n">Parser</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seedresp</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">],</span> <span class="n">Parser</span><span class="p">):</span>
                <span class="n">seedresp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">seedresp</span><span class="p">)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seedresp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seedresp</span>
                <span class="n">resp_key</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s2">&quot;RESP&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">stringio</span> <span class="ow">in</span> <span class="n">seedresp</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get_resp</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">resp_key</span><span class="p">:</span>
                        <span class="n">stringio</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">seedresp</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stringio</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Response for </span><span class="si">%s</span><span class="s2"> not found in Parser&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># Set the SEED identifiers!</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">,</span> <span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;channel&quot;</span><span class="p">]:</span>
                <span class="n">seedresp</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

        <span class="kn">from</span> <span class="nn">obspy.signal.invsim</span> <span class="k">import</span> <span class="n">simulate_seismometer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">simulate_seismometer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">paz_remove</span><span class="o">=</span><span class="n">paz_remove</span><span class="p">,</span>
            <span class="n">paz_simulate</span><span class="o">=</span><span class="n">paz_simulate</span><span class="p">,</span> <span class="n">remove_sensitivity</span><span class="o">=</span><span class="n">remove_sensitivity</span><span class="p">,</span>
            <span class="n">simulate_sensitivity</span><span class="o">=</span><span class="n">simulate_sensitivity</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.filter"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.filter.html#obspy.core.trace.Trace.filter">[docs]</a>    <span class="nd">@_add_processing_info</span>
    <span class="nd">@raise_if_masked</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter the data of the current trace.</span>

<span class="sd">        :type type: str</span>
<span class="sd">        :param type: String that specifies which filter is applied (e.g.</span>
<span class="sd">            ``&quot;bandpass&quot;``). See the `Supported Filter`_ section below for</span>
<span class="sd">            further details.</span>
<span class="sd">        :param options: Necessary keyword arguments for the respective filter</span>
<span class="sd">            that will be passed on. (e.g. ``freqmin=1.0``, ``freqmax=20.0`` for</span>
<span class="sd">            ``&quot;bandpass&quot;``)</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of this trace.</span>

<span class="sd">        .. rubric:: _`Supported Filter`</span>

<span class="sd">        ``&#39;bandpass&#39;``</span>
<span class="sd">            Butterworth-Bandpass (uses :func:`obspy.signal.filter.bandpass`).</span>

<span class="sd">        ``&#39;bandstop&#39;``</span>
<span class="sd">            Butterworth-Bandstop (uses :func:`obspy.signal.filter.bandstop`).</span>

<span class="sd">        ``&#39;lowpass&#39;``</span>
<span class="sd">            Butterworth-Lowpass (uses :func:`obspy.signal.filter.lowpass`).</span>

<span class="sd">        ``&#39;highpass&#39;``</span>
<span class="sd">            Butterworth-Highpass (uses :func:`obspy.signal.filter.highpass`).</span>

<span class="sd">        ``&#39;lowpass_cheby_2&#39;``</span>
<span class="sd">            Cheby2-Lowpass (uses :func:`obspy.signal.filter.lowpass_cheby_2`).</span>

<span class="sd">        ``&#39;lowpass_fir&#39;`` (experimental)</span>
<span class="sd">            FIR-Lowpass (uses :func:`obspy.signal.filter.lowpass_fir`).</span>

<span class="sd">        ``&#39;remez_fir&#39;`` (experimental)</span>
<span class="sd">            Minimax optimal bandpass using Remez algorithm (uses</span>
<span class="sd">            :func:`obspy.signal.filter.remez_fir`).</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; tr = st[0]</span>
<span class="sd">        &gt;&gt;&gt; tr.filter(&quot;highpass&quot;, freq=1.0)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.plot()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read</span>
<span class="sd">            st = read()</span>
<span class="sd">            tr = st[0]</span>
<span class="sd">            tr.filter(&quot;highpass&quot;, freq=1.0)</span>
<span class="sd">            tr.plot()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># retrieve function call from entry points</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_get_function_from_entry_point</span><span class="p">(</span><span class="s1">&#39;filter&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="c1"># filtering</span>
        <span class="c1"># the options dictionary is passed as kwargs to the function that is</span>
        <span class="c1"># mapped according to the filter_functions dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.trigger"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.trigger.html#obspy.core.trace.Trace.trigger">[docs]</a>    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">trigger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run a triggering algorithm on the data of the current trace.</span>

<span class="sd">        :param type: String that specifies which trigger is applied (e.g.</span>
<span class="sd">            ``&#39;recstalta&#39;``). See the `Supported Trigger`_ section below for</span>
<span class="sd">            further details.</span>
<span class="sd">        :param options: Necessary keyword arguments for the respective trigger</span>
<span class="sd">            that will be passed on.</span>
<span class="sd">            (e.g. ``sta=3``, ``lta=10``)</span>
<span class="sd">            Arguments ``sta`` and ``lta`` (seconds) will be mapped to ``nsta``</span>
<span class="sd">            and ``nlta`` (samples) by multiplying with sampling rate of trace.</span>
<span class="sd">            (e.g. ``sta=3``, ``lta=10`` would call the trigger with 3 and 10</span>
<span class="sd">            seconds average, respectively)</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of this trace.</span>

<span class="sd">        .. rubric:: _`Supported Trigger`</span>

<span class="sd">        ``&#39;classicstalta&#39;``</span>
<span class="sd">            Computes the classic STA/LTA characteristic function (uses</span>
<span class="sd">            :func:`obspy.signal.trigger.classic_sta_lta`).</span>

<span class="sd">        ``&#39;recstalta&#39;``</span>
<span class="sd">            Recursive STA/LTA</span>
<span class="sd">            (uses :func:`obspy.signal.trigger.recursive_sta_lta`).</span>

<span class="sd">        ``&#39;recstaltapy&#39;``</span>
<span class="sd">            Recursive STA/LTA written in Python (uses</span>
<span class="sd">            :func:`obspy.signal.trigger.recursive_sta_lta_py`).</span>

<span class="sd">        ``&#39;delayedstalta&#39;``</span>
<span class="sd">            Delayed STA/LTA.</span>
<span class="sd">            (uses :func:`obspy.signal.trigger.delayed_sta_lta`).</span>

<span class="sd">        ``&#39;carlstatrig&#39;``</span>
<span class="sd">            Computes the carl_sta_trig characteristic function (uses</span>
<span class="sd">            :func:`obspy.signal.trigger.carl_sta_trig`).</span>

<span class="sd">        ``&#39;zdetect&#39;``</span>
<span class="sd">            Z-detector (uses :func:`obspy.signal.trigger.z_detect`).</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; tr = st[0]</span>
<span class="sd">        &gt;&gt;&gt; tr.filter(&quot;highpass&quot;, freq=1.0)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.plot()  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; tr.trigger(&quot;recstalta&quot;, sta=1, lta=4)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.plot()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read</span>
<span class="sd">            st = read()</span>
<span class="sd">            tr = st[0]</span>
<span class="sd">            tr.filter(&quot;highpass&quot;, freq=1.0)</span>
<span class="sd">            tr.plot()</span>
<span class="sd">            tr.trigger(&#39;recstalta&#39;, sta=1, lta=4)</span>
<span class="sd">            tr.plot()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># retrieve function call from entry points</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_get_function_from_entry_point</span><span class="p">(</span><span class="s1">&#39;trigger&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="c1"># convert the two arguments sta and lta to nsta and nlta as used by</span>
        <span class="c1"># actual triggering routines (needs conversion to int, as samples are</span>
        <span class="c1"># used in length of trigger averages)...</span>
        <span class="n">spr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sta&#39;</span><span class="p">,</span> <span class="s1">&#39;lta&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
                <span class="n">options</span><span class="p">[</span><span class="s1">&#39;n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">*</span> <span class="n">spr</span><span class="p">)</span>
        <span class="c1"># triggering</span>
        <span class="c1"># the options dictionary is passed as kwargs to the function that is</span>
        <span class="c1"># mapped according to the trigger_functions dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.resample"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.resample.html#obspy.core.trace.Trace.resample">[docs]</a>    <span class="nd">@skip_if_no_data</span>
    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="n">no_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">strict_length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample trace data using Fourier method. Spectra are linearly</span>
<span class="sd">        interpolated if required.</span>

<span class="sd">        :type sampling_rate: float</span>
<span class="sd">        :param sampling_rate: The sampling rate of the resampled signal.</span>
<span class="sd">        :type window: array_like, callable, str, float, or tuple, optional</span>
<span class="sd">        :param window: Specifies the window applied to the signal in the</span>
<span class="sd">            Fourier domain. Defaults to ``&#39;hanning&#39;`` window. See</span>
<span class="sd">            :func:`scipy.signal.resample` for details.</span>
<span class="sd">        :type no_filter: bool, optional</span>
<span class="sd">        :param no_filter: Deactivates automatic filtering if set to ``True``.</span>
<span class="sd">            Defaults to ``True``.</span>
<span class="sd">        :type strict_length: bool, optional</span>
<span class="sd">        :param strict_length: Leave traces unchanged for which end time of</span>
<span class="sd">            trace would change. Defaults to ``False``.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The :class:`~Trace` object has three different methods to change</span>
<span class="sd">            the sampling rate of its data: :meth:`~.resample`,</span>
<span class="sd">            :meth:`~.decimate`, and :meth:`~.interpolate`</span>

<span class="sd">            Make sure to choose the most appropriate one for the problem at</span>
<span class="sd">            hand.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of this trace.</span>

<span class="sd">        Uses :func:`scipy.signal.resample`. Because a Fourier method is used,</span>
<span class="sd">        the signal is assumed to be periodic.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.array([0.5, 0, 0.5, 1, 0.5, 0, 0.5, 1]))</span>
<span class="sd">        &gt;&gt;&gt; len(tr)</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.sampling_rate</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; tr.resample(4.0)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; len(tr)</span>
<span class="sd">        32</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.sampling_rate</span>
<span class="sd">        4.0</span>
<span class="sd">        &gt;&gt;&gt; tr.data  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS</span>
<span class="sd">        array([ 0.5       ,  0.40432914,  0.3232233 ,  0.26903012,  0.25 ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">get_window</span>
        <span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="k">import</span> <span class="n">rfft</span><span class="p">,</span> <span class="n">irfft</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sampling_rate</span><span class="p">)</span>
        <span class="c1"># check if end time changes and this is not explicitly allowed</span>
        <span class="k">if</span> <span class="n">strict_length</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="n">factor</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;End time of trace would change and strict_length=True.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># do automatic lowpass filtering</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">no_filter</span><span class="p">:</span>
            <span class="c1"># be sure filter still behaves good</span>
            <span class="k">if</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Automatic filter design is unstable for resampling &quot;</span> <span class="o">+</span> \
                      <span class="s2">&quot;factors (current sampling rate/new sampling rate) &quot;</span> <span class="o">+</span> \
                      <span class="s2">&quot;above 16. Manual resampling is necessary.&quot;</span>
                <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s1">&#39;lowpass_cheby_2&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">maxorder</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

        <span class="c1"># resample in the frequency domain. Make sure the byteorder is native.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">rfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">))</span>
        <span class="c1"># Cast the value to be inserted to the same dtype as the array to avoid</span>
        <span class="c1"># issues with numpy rule &#39;safe&#39;.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">x_r</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">x_i</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
                <span class="n">large_w</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">window</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">,):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Window has the wrong shape. Window length must &quot;</span> <span class="o">+</span> \
                          <span class="s2">&quot;equal the number of points.&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">large_w</span> <span class="o">=</span> <span class="n">window</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">large_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">get_window</span><span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="n">window</span><span class="p">),</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">))</span>
            <span class="n">x_r</span> <span class="o">*=</span> <span class="n">large_w</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">x_i</span> <span class="o">*=</span> <span class="n">large_w</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># interpolate</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">/</span> <span class="n">factor</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">d_large_f</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">num</span> <span class="o">*</span> <span class="n">sampling_rate</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">df</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">n_large_f</span> <span class="o">=</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">large_f</span> <span class="o">=</span> <span class="n">d_large_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_large_f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">large_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_large_f</span><span class="p">))</span>
        <span class="n">large_y</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">large_f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x_r</span><span class="p">)</span>
        <span class="n">large_y</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">large_f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x_i</span><span class="p">)</span>

        <span class="n">large_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">large_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">large_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">large_y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">irfft</span><span class="p">(</span><span class="n">large_y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">sampling_rate</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.decimate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.decimate.html#obspy.core.trace.Trace.decimate">[docs]</a>    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">no_filter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strict_length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Downsample trace data by an integer factor.</span>

<span class="sd">        :type factor: int</span>
<span class="sd">        :param factor: Factor by which the sampling rate is lowered by</span>
<span class="sd">            decimation.</span>
<span class="sd">        :type no_filter: bool, optional</span>
<span class="sd">        :param no_filter: Deactivates automatic filtering if set to ``True``.</span>
<span class="sd">            Defaults to ``False``.</span>
<span class="sd">        :type strict_length: bool, optional</span>
<span class="sd">        :param strict_length: Leave traces unchanged for which end time of</span>
<span class="sd">            trace would change. Defaults to ``False``.</span>

<span class="sd">        Currently a simple integer decimation is implemented.</span>
<span class="sd">        Only every ``decimation_factor``-th sample remains in the trace, all</span>
<span class="sd">        other samples are thrown away. Prior to decimation a lowpass filter is</span>
<span class="sd">        applied to ensure no aliasing artifacts are introduced. The automatic</span>
<span class="sd">        filtering can be deactivated with ``no_filter=True``.</span>

<span class="sd">        If the length of the data array modulo ``decimation_factor`` is not</span>
<span class="sd">        zero then the end time of the trace is changing on sub-sample scale. To</span>
<span class="sd">        abort downsampling in case of changing end times set</span>
<span class="sd">        ``strict_length=True``.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The :class:`~Trace` object has three different methods to change</span>
<span class="sd">            the sampling rate of its data: :meth:`~.resample`,</span>
<span class="sd">            :meth:`~.decimate`, and :meth:`~.interpolate`</span>

<span class="sd">            Make sure to choose the most appropriate one for the problem at</span>
<span class="sd">            hand.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of this trace.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        For the example we switch off the automatic pre-filtering so that</span>
<span class="sd">        the effect of the downsampling routine becomes clearer:</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.arange(10))</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.sampling_rate</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; tr.data</span>
<span class="sd">        array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">        &gt;&gt;&gt; tr.decimate(4, strict_length=False,</span>
<span class="sd">        ...    no_filter=True)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.stats.sampling_rate</span>
<span class="sd">        0.25</span>
<span class="sd">        &gt;&gt;&gt; tr.data</span>
<span class="sd">        array([0, 4, 8])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if end time changes and this is not explicitly allowed</span>
        <span class="k">if</span> <span class="n">strict_length</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="n">factor</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;End time of trace would change and strict_length=True.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># do automatic lowpass filtering</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">no_filter</span><span class="p">:</span>
            <span class="c1"># be sure filter still behaves good</span>
            <span class="k">if</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Automatic filter design is unstable for decimation &quot;</span> <span class="o">+</span> \
                      <span class="s2">&quot;factors above 16. Manual decimation is necessary.&quot;</span>
                <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s1">&#39;lowpass_cheby_2&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">maxorder</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

        <span class="c1"># actual downsampling, as long as sampling_rate is a float we would not</span>
        <span class="c1"># need to convert to float, but let&#39;s do it as a safety measure</span>
        <span class="kn">from</span> <span class="nn">obspy.signal.filter</span> <span class="k">import</span> <span class="n">integer_decimation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">integer_decimation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.max"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.max.html#obspy.core.trace.Trace.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value of the absolute maximum amplitude in the trace.</span>

<span class="sd">        :return: Value of absolute maximum of ``trace.data``.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.array([0, -3, 9, 6, 4]))</span>
<span class="sd">        &gt;&gt;&gt; tr.max()</span>
<span class="sd">        9</span>
<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.array([0, -3, -9, 6, 4]))</span>
<span class="sd">        &gt;&gt;&gt; tr.max()</span>
<span class="sd">        -9</span>
<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.array([0.3, -3.5, 9.0, 6.4, 4.3]))</span>
<span class="sd">        &gt;&gt;&gt; tr.max()</span>
<span class="sd">        9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_min</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">_min</span>
        <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Trace.std"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.std.html#obspy.core.trace.Trace.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to get the standard deviation of amplitudes in the trace.</span>

<span class="sd">        :return: Standard deviation of ``trace.data``.</span>

<span class="sd">        Standard deviation is calculated by NumPy method</span>
<span class="sd">        :meth:`~numpy.ndarray.std` on ``trace.data``.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.array([0, -3, 9, 6, 4]))</span>
<span class="sd">        &gt;&gt;&gt; tr.std()</span>
<span class="sd">        4.2614551505325036</span>
<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.array([0.3, -3.5, 9.0, 6.4, 4.3]))</span>
<span class="sd">        &gt;&gt;&gt; tr.std()</span>
<span class="sd">        4.4348618918744247</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span></div>

<div class="viewcode-block" id="Trace.differentiate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.differentiate.html#obspy.core.trace.Trace.differentiate">[docs]</a>    <span class="nd">@skip_if_no_data</span>
    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;gradient&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Differentiate the trace with respect to time.</span>

<span class="sd">        :type method: str, optional</span>
<span class="sd">        :param method: Method to use for differentiation. Defaults to</span>
<span class="sd">            ``&#39;gradient&#39;``. See the `Supported Methods`_ section below for</span>
<span class="sd">            further details.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of this trace.</span>

<span class="sd">        .. rubric:: _`Supported Methods`</span>

<span class="sd">        ``&#39;gradient&#39;``</span>
<span class="sd">            The gradient is computed using central differences in the interior</span>
<span class="sd">            and first differences at the boundaries. The returned gradient</span>
<span class="sd">            hence has the same shape as the input array. (uses</span>
<span class="sd">            :func:`numpy.gradient`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># retrieve function call from entry points</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_get_function_from_entry_point</span><span class="p">(</span><span class="s1">&#39;differentiate&#39;</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="c1"># differentiate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.integrate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.integrate.html#obspy.core.trace.Trace.integrate">[docs]</a>    <span class="nd">@skip_if_no_data</span>
    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;cumtrapz&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integrate the trace with respect to time.</span>

<span class="sd">        .. rubric:: _`Supported Methods`</span>

<span class="sd">        ``&#39;cumtrapz&#39;``</span>
<span class="sd">            First order integration of data using the trapezoidal rule. Uses</span>
<span class="sd">            :func:`obspy.signal.differentiate_and_integrate.integrate_cumtrapz`</span>

<span class="sd">        ``&#39;spline&#39;``</span>
<span class="sd">            Integrates by generating an interpolating spline and integrating</span>
<span class="sd">            that. Uses</span>
<span class="sd">            :func:`obspy.signal.differentiate_and_integrate.integrate_spline`</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of this trace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># retrieve function call from entry points</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_get_function_from_entry_point</span><span class="p">(</span><span class="s1">&#39;integrate&#39;</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.detrend"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.detrend.html#obspy.core.trace.Trace.detrend">[docs]</a>    <span class="nd">@skip_if_no_data</span>
    <span class="nd">@raise_if_masked</span>
    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">detrend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a trend from the trace.</span>

<span class="sd">        :type type: str, optional</span>
<span class="sd">        :param type: Method to use for detrending. Defaults to ``&#39;simple&#39;``.</span>
<span class="sd">            See the `Supported Methods`_ section below for further details.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of this trace.</span>

<span class="sd">        .. rubric:: _`Supported Methods`</span>

<span class="sd">        ``&#39;simple&#39;``</span>
<span class="sd">            Subtracts a linear function defined by first/last sample of the</span>
<span class="sd">            trace (uses :func:`obspy.signal.detrend.simple`).</span>

<span class="sd">        ``&#39;linear&#39;``</span>
<span class="sd">            Fitting a linear function to the trace with least squares and</span>
<span class="sd">            subtracting it (uses :func:`scipy.signal.detrend`).</span>

<span class="sd">        ``&#39;constant&#39;`` or ``&#39;demean&#39;``</span>
<span class="sd">            Mean of data is subtracted (uses :func:`scipy.signal.detrend`).</span>

<span class="sd">        ``&#39;polynomial&#39;``</span>
<span class="sd">            Subtracts a polynomial of a given order.</span>
<span class="sd">            (uses :func:`obspy.signal.detrend.polynomial`).</span>

<span class="sd">        ``&#39;spline&#39;``</span>
<span class="sd">            Subtracts a spline of a given order with a given number of</span>
<span class="sd">            samples between spline nodes.</span>
<span class="sd">            (uses :func:`obspy.signal.detrend.spline`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># retrieve function call from entry points</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_get_function_from_entry_point</span><span class="p">(</span><span class="s1">&#39;detrend&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

        <span class="c1"># handle function specific settings</span>
        <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;scipy&#39;</span><span class="p">):</span>
            <span class="c1"># SciPy need to set the type keyword</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;demean&#39;</span><span class="p">:</span>
                <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span>
            <span class="n">options</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span>
            <span class="n">original_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># detrending</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="c1"># Ugly workaround for old scipy versions that might unnecessarily</span>
        <span class="c1"># change the dtype of the data.</span>
        <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;scipy&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">original_dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.taper"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.taper.html#obspy.core.trace.Trace.taper">[docs]</a>    <span class="nd">@skip_if_no_data</span>
    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">taper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_percentage</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Taper the trace.</span>

<span class="sd">        Optional (and sometimes necessary) options to the tapering function can</span>
<span class="sd">        be provided as kwargs. See respective function definitions in</span>
<span class="sd">        `Supported Methods`_ section below.</span>

<span class="sd">        :type type: str</span>
<span class="sd">        :param type: Type of taper to use for detrending. Defaults to</span>
<span class="sd">            ``&#39;hann&#39;``.  See the `Supported Methods`_ section below for</span>
<span class="sd">            further details.</span>
<span class="sd">        :type max_percentage: None, float</span>
<span class="sd">        :param max_percentage: Decimal percentage of taper at one end (ranging</span>
<span class="sd">            from 0. to 0.5).</span>
<span class="sd">        :type max_length: None, float</span>
<span class="sd">        :param max_length: Length of taper at one end in seconds.</span>
<span class="sd">        :type side: str</span>
<span class="sd">        :param side: Specify if both sides should be tapered (default, &quot;both&quot;)</span>
<span class="sd">            or if only the left half (&quot;left&quot;) or right half (&quot;right&quot;) should be</span>
<span class="sd">            tapered.</span>

<span class="sd">        .. note::</span>

<span class="sd">            To get the same results as the default taper in SAC, use</span>
<span class="sd">            `max_percentage=0.05` and leave `type` as `hann`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If both `max_percentage` and `max_length` are set to a float, the</span>
<span class="sd">            shorter tape length is used. If both `max_percentage` and</span>
<span class="sd">            `max_length` are set to `None`, the whole trace will be tapered.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of this trace.</span>

<span class="sd">        .. rubric:: _`Supported Methods`</span>

<span class="sd">        ``&#39;cosine&#39;``</span>
<span class="sd">            Cosine taper, for additional options like taper percentage see:</span>
<span class="sd">            :func:`obspy.signal.invsim.cosine_taper`.</span>
<span class="sd">        ``&#39;barthann&#39;``</span>
<span class="sd">            Modified Bartlett-Hann window. (uses:</span>
<span class="sd">            :func:`scipy.signal.barthann`)</span>
<span class="sd">        ``&#39;bartlett&#39;``</span>
<span class="sd">            Bartlett window. (uses: :func:`scipy.signal.bartlett`)</span>
<span class="sd">        ``&#39;blackman&#39;``</span>
<span class="sd">            Blackman window. (uses: :func:`scipy.signal.blackman`)</span>
<span class="sd">        ``&#39;blackmanharris&#39;``</span>
<span class="sd">            Minimum 4-term Blackman-Harris window. (uses:</span>
<span class="sd">            :func:`scipy.signal.blackmanharris`)</span>
<span class="sd">        ``&#39;bohman&#39;``</span>
<span class="sd">            Bohman window. (uses: :func:`scipy.signal.bohman`)</span>
<span class="sd">        ``&#39;boxcar&#39;``</span>
<span class="sd">            Boxcar window. (uses: :func:`scipy.signal.boxcar`)</span>
<span class="sd">        ``&#39;chebwin&#39;``</span>
<span class="sd">            Dolph-Chebyshev window. (uses: :func:`scipy.signal.chebwin`)</span>
<span class="sd">        ``&#39;flattop&#39;``</span>
<span class="sd">            Flat top window. (uses: :func:`scipy.signal.flattop`)</span>
<span class="sd">        ``&#39;gaussian&#39;``</span>
<span class="sd">            Gaussian window with standard-deviation std. (uses:</span>
<span class="sd">            :func:`scipy.signal.gaussian`)</span>
<span class="sd">        ``&#39;general_gaussian&#39;``</span>
<span class="sd">            Generalized Gaussian window. (uses:</span>
<span class="sd">            :func:`scipy.signal.general_gaussian`)</span>
<span class="sd">        ``&#39;hamming&#39;``</span>
<span class="sd">            Hamming window. (uses: :func:`scipy.signal.hamming`)</span>
<span class="sd">        ``&#39;hann&#39;``</span>
<span class="sd">            Hann window. (uses: :func:`scipy.signal.hann`)</span>
<span class="sd">        ``&#39;kaiser&#39;``</span>
<span class="sd">            Kaiser window with shape parameter beta. (uses:</span>
<span class="sd">            :func:`scipy.signal.kaiser`)</span>
<span class="sd">        ``&#39;nuttall&#39;``</span>
<span class="sd">            Minimum 4-term Blackman-Harris window according to Nuttall.</span>
<span class="sd">            (uses: :func:`scipy.signal.nuttall`)</span>
<span class="sd">        ``&#39;parzen&#39;``</span>
<span class="sd">            Parzen window. (uses: :func:`scipy.signal.parzen`)</span>
<span class="sd">        ``&#39;slepian&#39;``</span>
<span class="sd">            Slepian window. (uses: :func:`scipy.signal.slepian`)</span>
<span class="sd">        ``&#39;triang&#39;``</span>
<span class="sd">            Triangular window. (uses: :func:`scipy.signal.triang`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">side</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">side_valid</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span>
        <span class="k">if</span> <span class="n">side</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">side_valid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;side&#39; has to be one of: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">side_valid</span><span class="p">)</span>
        <span class="c1"># retrieve function call from entry points</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_get_function_from_entry_point</span><span class="p">(</span><span class="s1">&#39;taper&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="c1"># store all constraints for maximum taper length</span>
        <span class="n">max_half_lenghts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">max_percentage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_half_lenghts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">max_percentage</span> <span class="o">*</span> <span class="n">npts</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">max_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_half_lenghts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">max_length</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mhl</span> <span class="o">&gt;</span> <span class="n">npts</span> <span class="k">for</span> <span class="n">mhl</span> <span class="ow">in</span> <span class="n">max_half_lenghts</span><span class="p">]):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The requested taper is longer than the trace. &quot;</span> \
                  <span class="s2">&quot;The taper will be shortened to trace length.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># add full trace length to constraints</span>
        <span class="n">max_half_lenghts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">npts</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># select shortest acceptable window half-length</span>
        <span class="n">wlen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_half_lenghts</span><span class="p">)</span>
        <span class="c1"># obspy.signal.cosine_taper has a default value for taper percentage,</span>
        <span class="c1"># we need to override is as we control percentage completely via npts</span>
        <span class="c1"># of taper function and insert ones in the middle afterwards</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;cosine&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="c1"># tapering. tapering functions are expected to accept the number of</span>
        <span class="c1"># samples as first argument and return an array of values between 0 and</span>
        <span class="c1"># 1 with the same length as the data</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">wlen</span> <span class="o">==</span> <span class="n">npts</span><span class="p">:</span>
            <span class="n">taper_sides</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">wlen</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">taper_sides</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">wlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="n">taper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">taper_sides</span><span class="p">[:</span><span class="n">wlen</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="n">wlen</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="n">taper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="n">wlen</span><span class="p">),</span>
                               <span class="n">taper_sides</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">taper_sides</span><span class="p">)</span> <span class="o">-</span> <span class="n">wlen</span><span class="p">:]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">taper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">taper_sides</span><span class="p">[:</span><span class="n">wlen</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">wlen</span><span class="p">),</span>
                               <span class="n">taper_sides</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">taper_sides</span><span class="p">)</span> <span class="o">-</span> <span class="n">wlen</span><span class="p">:]))</span>

        <span class="c1"># Convert data if it&#39;s not a floating point type.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">taper</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.normalize"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.normalize.html#obspy.core.trace.Trace.normalize">[docs]</a>    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize the trace to its absolute maximum.</span>

<span class="sd">        :type norm: ``None`` or float</span>
<span class="sd">        :param norm: If not ``None``, trace is normalized by dividing by</span>
<span class="sd">            specified value ``norm`` instead of dividing by its absolute</span>
<span class="sd">            maximum. If a negative value is specified then its absolute value</span>
<span class="sd">            is used. If it is zero (either through a zero array or by being</span>
<span class="sd">            passed), nothing will happen and the original array will not</span>
<span class="sd">            change.</span>

<span class="sd">        If ``trace.data.dtype`` was integer it is changing to float.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data is not accessible anymore afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~obspy.core.trace.Trace.copy` to create</span>
<span class="sd">            a copy of your trace object.</span>
<span class="sd">            This also makes an entry with information on the applied processing</span>
<span class="sd">            in ``stats.processing`` of this trace.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.array([0, -3, 9, 6]))</span>
<span class="sd">        &gt;&gt;&gt; tr.normalize()  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.data</span>
<span class="sd">        array([ 0.        , -0.33333333,  1.        ,  0.66666667])</span>
<span class="sd">        &gt;&gt;&gt; print(tr.stats.processing[0])  # doctest: +ELLIPSIS</span>
<span class="sd">        ObsPy ...: normalize(norm=None)</span>
<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.array([0.3, -3.5, -9.2, 6.4]))</span>
<span class="sd">        &gt;&gt;&gt; tr.normalize()  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.data</span>
<span class="sd">        array([ 0.0326087 , -0.38043478, -1.        ,  0.69565217])</span>
<span class="sd">        &gt;&gt;&gt; print(tr.stats.processing[0])  # doctest: +ELLIPSIS</span>
<span class="sd">        ObsPy ...: normalize(norm=None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># normalize, use norm-kwarg otherwise normalize to 1</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Normalizing with negative values is forbidden. &quot;</span> <span class="o">+</span> \
                      <span class="s2">&quot;Using absolute value.&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1"># Don&#39;t do anything for zero norm but raise a warning.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Attempting to normalize by dividing through zero. This &quot;</span>
                   <span class="s2">&quot;is not allowed and the data will thus not be changed.&quot;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Convert data if it&#39;s not a floating point type.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.copy"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.copy.html#obspy.core.trace.Trace.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deepcopy of the trace.</span>

<span class="sd">        :return: Copy of trace.</span>

<span class="sd">        This actually copies all data in the trace and does not only provide</span>
<span class="sd">        another pointer to the same data. At any processing step if the</span>
<span class="sd">        original data has to be available afterwards, this is the method to</span>
<span class="sd">        use to make a copy of the trace.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        Make a Trace and copy it:</span>

<span class="sd">        &gt;&gt;&gt; tr = Trace(data=np.random.rand(10))</span>
<span class="sd">        &gt;&gt;&gt; tr2 = tr.copy()</span>

<span class="sd">        The two objects are not the same:</span>

<span class="sd">        &gt;&gt;&gt; tr2 is tr</span>
<span class="sd">        False</span>

<span class="sd">        But they have equal data (before applying further processing):</span>

<span class="sd">        &gt;&gt;&gt; tr2 == tr</span>
<span class="sd">        True</span>

<span class="sd">        The following example shows how to make an alias but not copy the</span>
<span class="sd">        data. Any changes on ``tr3`` would also change the contents of ``tr``.</span>

<span class="sd">        &gt;&gt;&gt; tr3 = tr</span>
<span class="sd">        &gt;&gt;&gt; tr3 is tr</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; tr3 == tr</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace._internal_add_processing_info"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace._internal_add_processing_info.html#obspy.core.trace.Trace._internal_add_processing_info">[docs]</a>    <span class="k">def</span> <span class="nf">_internal_add_processing_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the given informational string to the `processing` field in the</span>
<span class="sd">        trace&#39;s :class:`~obspy.core.trace.Stats` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;processing&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">proc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.split"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.split.html#obspy.core.trace.Trace.split">[docs]</a>    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split Trace object containing gaps using a NumPy masked array into</span>
<span class="sd">        several traces.</span>

<span class="sd">        :rtype: :class:`~obspy.core.stream.Stream`</span>
<span class="sd">        :returns: Stream containing all split traces. A gapless trace will</span>
<span class="sd">            still be returned as Stream with only one entry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">Stream</span>

        <span class="c1"># Not a masked array.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">):</span>
            <span class="c1"># no gaps</span>
            <span class="k">return</span> <span class="n">Stream</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()])</span>
        <span class="c1"># Masked array but no actually masked values.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="n">_tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">_tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">_tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Stream</span><span class="p">([</span><span class="n">_tr</span><span class="p">])</span>

        <span class="n">slices</span> <span class="o">=</span> <span class="n">flat_not_masked_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">trace_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">slice</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">slice</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;step not supported&quot;</span><span class="p">)</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="n">Trace</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">stats</span><span class="p">)</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+=</span> <span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="nb">slice</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="c1"># return the underlying data not the masked array</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">slice</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="nb">slice</span><span class="o">.</span><span class="n">stop</span><span class="p">]</span>
            <span class="n">trace_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Stream</span><span class="p">(</span><span class="n">trace_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.interpolate"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.interpolate.html#obspy.core.trace.Trace.interpolate">[docs]</a>    <span class="nd">@skip_if_no_data</span>
    <span class="nd">@raise_if_masked</span>
    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;weighted_average_slopes&quot;</span><span class="p">,</span>
                    <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate the data using various interpolation techniques.</span>

<span class="sd">        Be careful when downsampling data and make sure to apply an appropriate</span>
<span class="sd">        anti-aliasing lowpass filter before interpolating in case it&#39;s</span>
<span class="sd">        necessary.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The :class:`~Trace` object has three different methods to change</span>
<span class="sd">            the sampling rate of its data: :meth:`~.resample`,</span>
<span class="sd">            :meth:`~.decimate`, and :meth:`~.interpolate`.</span>

<span class="sd">            Make sure to choose the most appropriate one for the problem at</span>
<span class="sd">            hand.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This operation is performed in place on the actual data arrays. The</span>
<span class="sd">            raw data will no longer be accessible afterwards. To keep your</span>
<span class="sd">            original data, use :meth:`~.copy` to create a copy of your Trace</span>
<span class="sd">            object.</span>

<span class="sd">        .. rubric:: _`Interpolation Methods:`</span>

<span class="sd">        The chosen method is crucial and we will elaborate a bit about the</span>
<span class="sd">        choices here:</span>

<span class="sd">        * ``&quot;lanczos&quot;``: This offers the highest quality interpolation and</span>
<span class="sd">          should be chosen whenever possible. It is only due to legacy</span>
<span class="sd">          reasons that this is not the default method. The one downside it</span>
<span class="sd">          has is that it can be fairly expensive. See the</span>
<span class="sd">          :func:`~obspy.signal.interpolation.lanczos_interpolation` function</span>
<span class="sd">          for more details.</span>
<span class="sd">        * ``&quot;weighted_average_slopes&quot;``: This is the interpolation method used</span>
<span class="sd">          by SAC. Refer to</span>
<span class="sd">          :func:`~obspy.signal.interpolation.weighted_average_slopes` for</span>
<span class="sd">          more details.</span>
<span class="sd">        * ``&quot;slinear&quot;``, ``&quot;quadratic&quot;`` and ``&quot;cubic&quot;``: spline interpolation</span>
<span class="sd">          of first, second or third order.</span>
<span class="sd">        * ``&quot;linear&quot;``: Linear interpolation.</span>
<span class="sd">        * ``&quot;nearest&quot;``: Nearest neighbour interpolation.</span>
<span class="sd">        * ``&quot;zero&quot;``: Last encountered value interpolation.</span>

<span class="sd">        .. rubric:: _`Parameters:`</span>

<span class="sd">        :param sampling_rate: The new sampling rate in ``Hz``.</span>
<span class="sd">        :param method: The kind of interpolation to perform as a string. One of</span>
<span class="sd">            ``&quot;linear&quot;``, ``&quot;nearest&quot;``, ``&quot;zero&quot;``, ``&quot;slinear&quot;``,</span>
<span class="sd">            ``&quot;quadratic&quot;``, ``&quot;cubic&quot;``, ``&quot;lanczos&quot;``, or</span>
<span class="sd">            ``&quot;weighted_average_slopes&quot;``. Alternatively an integer</span>
<span class="sd">            specifying the order of the spline interpolator to use also works.</span>
<span class="sd">            Defaults to ``&quot;weighted_average_slopes&quot;``.</span>
<span class="sd">        :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime` or int</span>
<span class="sd">        :param starttime: The start time (or timestamp) for the new</span>
<span class="sd">            interpolated stream. Will be set to current start time of the</span>
<span class="sd">            trace if not given.</span>
<span class="sd">        :type npts: int</span>
<span class="sd">        :param npts: The new number of samples. Will be set to the best</span>
<span class="sd">            fitting  number to retain the current end time of the trace if</span>
<span class="sd">            not given.</span>
<span class="sd">        :type time_shift: float</span>
<span class="sd">        :param time_shift: Interpolation can also shift the data with</span>
<span class="sd">            subsample accuracy. The time shift is always given in seconds. A</span>
<span class="sd">            positive shift means the data is shifted towards the future,</span>
<span class="sd">            e.g. a positive time delta. Please note that a time shift in</span>
<span class="sd">            the Fourier domain is always more accurate than this. When using</span>
<span class="sd">            Lanczos interpolation with large values of ``a`` and away from the</span>
<span class="sd">            boundaries this is nonetheless pretty good.</span>

<span class="sd">        .. rubric:: _`New in version 0.11:`</span>

<span class="sd">        * New parameter ``time_shift``.</span>
<span class="sd">        * New interpolation method ``lanczos``.</span>


<span class="sd">        .. rubric:: _`Usage Examples`</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read</span>
<span class="sd">        &gt;&gt;&gt; tr = read()[0]</span>
<span class="sd">        &gt;&gt;&gt; print(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03... - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; tr.interpolate(sampling_rate=111.1)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;obspy.core.trace.Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03... - ... | 111.1 Hz, 3332 samples</span>

<span class="sd">        Setting ``starttime`` and/or ``npts`` will interpolate to sampling</span>
<span class="sd">        points with the given start time and/or number of samples.</span>
<span class="sd">        Extrapolation will not be performed.</span>

<span class="sd">        &gt;&gt;&gt; tr = read()[0]</span>
<span class="sd">        &gt;&gt;&gt; print(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:03... - ... | 100.0 Hz, 3000 samples</span>
<span class="sd">        &gt;&gt;&gt; tr.interpolate(sampling_rate=111.1,</span>
<span class="sd">        ...                starttime=tr.stats.starttime + 10) \</span>
<span class="sd">        # doctest:  +ELLIPSIS</span>
<span class="sd">        &lt;obspy.core.trace.Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(tr)  # doctest: +ELLIPSIS</span>
<span class="sd">        BW.RJOB..EHZ | 2009-08-24T00:20:13... - ... | 111.1 Hz, 2221 samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sampling_rate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The time step must be positive.&quot;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sampling_rate</span>

        <span class="c1"># We just shift the old start time. The interpolation will take care</span>
        <span class="c1"># of the rest.</span>
        <span class="k">if</span> <span class="n">time_shift</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+=</span> <span class="n">time_shift</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;zero&quot;</span><span class="p">,</span> <span class="s2">&quot;slinear&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;quadratic&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">]:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">_get_function_from_entry_point</span><span class="p">(</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span>
                                                      <span class="s1">&#39;interpolate_1d&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">_get_function_from_entry_point</span><span class="p">(</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="n">old_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="n">old_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>

            <span class="k">if</span> <span class="n">starttime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">starttime</span> <span class="o">=</span> <span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="k">if</span> <span class="n">npts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">npts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">endtime</span> <span class="o">-</span> <span class="n">starttime</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">func</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">old_start</span><span class="p">,</span> <span class="n">old_dt</span><span class="p">,</span>
                <span class="n">starttime</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">starttime</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># Revert the start time change if something went wrong.</span>
            <span class="k">if</span> <span class="n">time_shift</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-=</span> <span class="n">time_shift</span>
            <span class="c1"># re-raise last exception.</span>
            <span class="k">raise</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.times"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.times.html#obspy.core.trace.Trace.times">[docs]</a>    <span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For convenient plotting compute a NumPy array of seconds since</span>
<span class="sd">        starttime corresponding to the samples in Trace.</span>

<span class="sd">        :rtype: :class:`~numpy.ndarray` or :class:`~numpy.ma.MaskedArray`</span>
<span class="sd">        :returns: An array of time samples in an :class:`~numpy.ndarray` if</span>
<span class="sd">            the trace doesn&#39;t have any gaps or a :class:`~numpy.ma.MaskedArray`</span>
<span class="sd">            otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
        <span class="n">time_array</span> <span class="o">=</span> <span class="n">time_array</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="c1"># Check if the data is a ma.maskedarray</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">):</span>
            <span class="n">time_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time_array</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_array</span></div>

<div class="viewcode-block" id="Trace._get_response"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace._get_response.html#obspy.core.trace.Trace._get_response">[docs]</a>    <span class="k">def</span> <span class="nf">_get_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inventories</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for and return channel response for the trace.</span>

<span class="sd">        :type inventories: :class:`~obspy.core.inventory.inventory.Inventory`</span>
<span class="sd">            or :class:`~obspy.core.inventory.network.Network` or a list</span>
<span class="sd">            containing objects of these types or a string with a filename of</span>
<span class="sd">            a StationXML file.</span>
<span class="sd">        :param inventories: Station metadata to use in search for response for</span>
<span class="sd">            each trace in the stream.</span>
<span class="sd">        :returns: :class:`obspy.core.inventory.response.Response` object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">obspy.core.inventory</span> <span class="k">import</span> <span class="n">Response</span>
        <span class="k">if</span> <span class="n">inventories</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;response&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">response</span><span class="p">,</span> <span class="n">Response</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Response attached to Trace.stats must be of type &quot;</span>
                       <span class="s2">&quot;obspy.core.inventory.response.Response &quot;</span>
                       <span class="s2">&quot;(but is of type </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">response</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">response</span>
        <span class="k">elif</span> <span class="n">inventories</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;No response information found. Use `inventory` &#39;</span>
                   <span class="s1">&#39;parameter to specify an inventory with response &#39;</span>
                   <span class="s1">&#39;information.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">obspy.core.inventory</span> <span class="k">import</span> <span class="n">Inventory</span><span class="p">,</span> <span class="n">Network</span><span class="p">,</span> <span class="n">read_inventory</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inventories</span><span class="p">,</span> <span class="n">Inventory</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="nb">isinstance</span><span class="p">(</span><span class="n">inventories</span><span class="p">,</span> <span class="n">Network</span><span class="p">):</span>
            <span class="n">inventories</span> <span class="o">=</span> <span class="p">[</span><span class="n">inventories</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inventories</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">native_str</span><span class="p">)):</span>
            <span class="n">inventories</span> <span class="o">=</span> <span class="p">[</span><span class="n">read_inventory</span><span class="p">(</span><span class="n">inventories</span><span class="p">)]</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">inv</span> <span class="ow">in</span> <span class="n">inventories</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">responses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv</span><span class="o">.</span><span class="n">get_response</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">responses</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Found more than one matching response. Using first.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">responses</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No matching response information found.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">responses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Trace.attach_response"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.attach_response.html#obspy.core.trace.Trace.attach_response">[docs]</a>    <span class="k">def</span> <span class="nf">attach_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inventories</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for and attach channel response to the trace as</span>
<span class="sd">        :class:`Trace`.stats.response. Raises an exception if no matching</span>
<span class="sd">        response can be found.</span>
<span class="sd">        To subsequently deconvolve the instrument response use</span>
<span class="sd">        :meth:`Trace.remove_response`.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, read_inventory</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; tr = st[0]</span>
<span class="sd">        &gt;&gt;&gt; inv = read_inventory()</span>
<span class="sd">        &gt;&gt;&gt; tr.attach_response(inv)</span>
<span class="sd">        &gt;&gt;&gt; print(tr.stats.response)  \</span>
<span class="sd">                # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE</span>
<span class="sd">        Channel Response</span>
<span class="sd">           From M/S (Velocity in Meters per Second) to COUNTS (Digital Counts)</span>
<span class="sd">           Overall Sensitivity: 2.5168e+09 defined at 0.020 Hz</span>
<span class="sd">           4 stages:</span>
<span class="sd">              Stage 1: PolesZerosResponseStage from M/S to V, gain: 1500</span>
<span class="sd">              Stage 2: CoefficientsTypeResponseStage from V to COUNTS, ...</span>
<span class="sd">              Stage 3: FIRResponseStage from COUNTS to COUNTS, gain: 1</span>
<span class="sd">              Stage 4: FIRResponseStage from COUNTS to COUNTS, gain: 1</span>

<span class="sd">        :type inventories: :class:`~obspy.core.inventory.inventory.Inventory`</span>
<span class="sd">            or :class:`~obspy.core.inventory.network.Network` or a list</span>
<span class="sd">            containing objects of these types or a string with a filename of</span>
<span class="sd">            a StationXML file.</span>
<span class="sd">        :param inventories: Station metadata to use in search for response for</span>
<span class="sd">            each trace in the stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_response</span><span class="p">(</span><span class="n">inventories</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trace.remove_response"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.remove_response.html#obspy.core.trace.Trace.remove_response">[docs]</a>    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">remove_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inventory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;VEL&quot;</span><span class="p">,</span> <span class="n">water_level</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
                        <span class="n">pre_filt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">taper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">taper_fraction</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deconvolve instrument response.</span>

<span class="sd">        Uses the adequate :class:`obspy.core.inventory.response.Response`</span>
<span class="sd">        from the provided</span>
<span class="sd">        :class:`obspy.core.inventory.inventory.Inventory` data. Raises an</span>
<span class="sd">        exception if the response is not present.</span>

<span class="sd">        Note that there are two ways to prevent overamplification</span>
<span class="sd">        while convolving the inverted instrument spectrum: One possibility is</span>
<span class="sd">        to specify a water level which represents a clipping of the inverse</span>
<span class="sd">        spectrum and limits amplification to a certain maximum cut-off value</span>
<span class="sd">        (`water_level` in dB). The other possibility is to taper the waveform</span>
<span class="sd">        data in the frequency domain prior to multiplying with the inverse</span>
<span class="sd">        spectrum, i.e. perform a pre-filtering in the frequency domain</span>
<span class="sd">        (specifying the four corner frequencies of the frequency taper as a</span>
<span class="sd">        tuple in `pre_filt`).</span>

<span class="sd">        .. note::</span>

<span class="sd">            Any additional kwargs will be passed on to</span>
<span class="sd">            :meth:`obspy.core.inventory.response.Response.get_evalresp_response`,</span>
<span class="sd">            see documentation of that method for further customization (e.g.</span>
<span class="sd">            start/stop stage).</span>

<span class="sd">        .. note::</span>

<span class="sd">            Using :meth:`~Trace.remove_response` is equivalent to using</span>
<span class="sd">            :meth:`~Trace.simulate` with the identical response provided as</span>
<span class="sd">            a (dataless) SEED or RESP file and when using the same</span>
<span class="sd">            `water_level` and `pre_filt` (and options `sacsim=True` and</span>
<span class="sd">            `pitsasim=False` which influence very minor details in detrending</span>
<span class="sd">            and tapering).</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, read_inventory</span>
<span class="sd">        &gt;&gt;&gt; st = read()</span>
<span class="sd">        &gt;&gt;&gt; tr = st[0].copy()</span>
<span class="sd">        &gt;&gt;&gt; inv = read_inventory()</span>
<span class="sd">        &gt;&gt;&gt; tr.remove_response(inventory=inv)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; tr.plot()  # doctest: +SKIP</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read, read_inventory</span>
<span class="sd">            st = read()</span>
<span class="sd">            tr = st[0]</span>
<span class="sd">            inv = read_inventory()</span>
<span class="sd">            tr.remove_response(inventory=inv)</span>
<span class="sd">            tr.plot()</span>

<span class="sd">        Using the `plot` option it is possible to visualize the individual</span>
<span class="sd">        steps during response removal in the frequency domain to check the</span>
<span class="sd">        chosen `pre_filt` and `water_level` options to stabilize the</span>
<span class="sd">        deconvolution of the inverted instrument response spectrum:</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, read_inventory</span>
<span class="sd">        &gt;&gt;&gt; st = read(&quot;/path/to/IU_ULN_00_LH1_2015-07-18T02.mseed&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tr = st[0]</span>
<span class="sd">        &gt;&gt;&gt; inv = read_inventory(&quot;/path/to/IU_ULN_00_LH1.xml&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pre_filt = [0.001, 0.005, 45, 50]</span>
<span class="sd">        &gt;&gt;&gt; tr.remove_response(inventory=inv, pre_filt=pre_filt, output=&quot;DISP&quot;,</span>
<span class="sd">        ...                    water_level=60, plot=True)  # doctest: +SKIP</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from obspy import read, read_inventory</span>
<span class="sd">            st = read(&quot;/path/to/IU_ULN_00_LH1_2015-07-18T02.mseed&quot;, &quot;MSEED&quot;)</span>
<span class="sd">            tr = st[0]</span>
<span class="sd">            inv = read_inventory(&quot;/path/to/IU_ULN_00_LH1.xml&quot;, &quot;STATIONXML&quot;)</span>
<span class="sd">            pre_filt = [0.001, 0.005, 45, 50]</span>
<span class="sd">            output = &quot;DISP&quot;</span>
<span class="sd">            tr.remove_response(inventory=inv, pre_filt=pre_filt, output=output,</span>
<span class="sd">                               water_level=60, plot=True)</span>

<span class="sd">        :type inventory: :class:`~obspy.core.inventory.inventory.Inventory`</span>
<span class="sd">            or None.</span>
<span class="sd">        :param inventory: Station metadata to use in search for adequate</span>
<span class="sd">            response. If inventory parameter is not supplied, the response</span>
<span class="sd">            has to be attached to the trace with :meth:`Trace.attach_response`</span>
<span class="sd">            beforehand.</span>
<span class="sd">        :type output: str</span>
<span class="sd">        :param output: Output units. One of:</span>

<span class="sd">            ``&quot;DISP&quot;``</span>
<span class="sd">                displacement, output unit is meters</span>
<span class="sd">            ``&quot;VEL&quot;``</span>
<span class="sd">                velocity, output unit is meters/second</span>
<span class="sd">            ``&quot;ACC&quot;``</span>
<span class="sd">                acceleration, output unit is meters/second**2</span>

<span class="sd">        :type water_level: float</span>
<span class="sd">        :param water_level: Water level for deconvolution.</span>
<span class="sd">        :type pre_filt: list or tuple of four float</span>
<span class="sd">        :param pre_filt: Apply a bandpass filter in frequency domain to the</span>
<span class="sd">            data before deconvolution. The list or tuple defines</span>
<span class="sd">            the four corner frequencies `(f1, f2, f3, f4)` of a cosine taper</span>
<span class="sd">            which is one between `f2` and `f3` and tapers to zero for</span>
<span class="sd">            `f1 &lt; f &lt; f2` and `f3 &lt; f &lt; f4`.</span>
<span class="sd">        :type zero_mean: bool</span>
<span class="sd">        :param zero_mean: If `True`, the mean of the waveform data is</span>
<span class="sd">            subtracted in time domain prior to deconvolution.</span>
<span class="sd">        :type taper: bool</span>
<span class="sd">        :param taper: If `True`, a cosine taper is applied to the waveform data</span>
<span class="sd">            in time domain prior to deconvolution.</span>
<span class="sd">        :type taper_fraction: float</span>
<span class="sd">        :param taper_fraction: Taper fraction of cosine taper to use.</span>
<span class="sd">        :type plot: bool or str</span>
<span class="sd">        :param plot: If `True`, brings up a plot that illustrates how the</span>
<span class="sd">            data are processed in the frequency domain in three steps. First by</span>
<span class="sd">            `pre_filt` frequency domain tapering, then by inverting the</span>
<span class="sd">            instrument response spectrum with or without `water_level` and</span>
<span class="sd">            finally showing data with inverted instrument response multiplied</span>
<span class="sd">            on it in frequency domain. It also shows the comparison of</span>
<span class="sd">            raw/corrected data in time domain. If a `str` is provided then the</span>
<span class="sd">            plot is saved to file (filename must have a valid image suffix</span>
<span class="sd">            recognizable by matplotlib e.g. &#39;.png&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">limit_numpy_fft_cache</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">obspy.core.inventory</span> <span class="k">import</span> <span class="n">PolynomialResponseStage</span>
        <span class="kn">from</span> <span class="nn">obspy.signal.invsim</span> <span class="k">import</span> <span class="p">(</span><span class="n">cosine_taper</span><span class="p">,</span> <span class="n">cosine_sac_taper</span><span class="p">,</span>
                                         <span class="n">invert_spectrum</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">inventory</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">native_str</span><span class="p">))</span> <span class="ow">and</span>
                <span class="n">inventory</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;DISP&quot;</span><span class="p">,</span> <span class="s2">&quot;VEL&quot;</span><span class="p">,</span> <span class="s2">&quot;ACC&quot;</span><span class="p">)):</span>
            <span class="kn">from</span> <span class="nn">obspy.core.util.deprecation_helpers</span> <span class="k">import</span> \
                <span class="n">ObsPyDeprecationWarning</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">inventory</span>
            <span class="n">inventory</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The order of optional parameters in method &quot;</span>
                   <span class="s2">&quot;remove_response has changed. &#39;output&#39; is not accepted &quot;</span>
                   <span class="s2">&quot;as first positional argument in the next release.&quot;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">ObsPyDeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_response</span><span class="p">(</span><span class="n">inventory</span><span class="p">)</span>
        <span class="c1"># polynomial response using blockette 62 stage 0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">response</span><span class="o">.</span><span class="n">response_stages</span> <span class="ow">and</span> <span class="n">response</span><span class="o">.</span><span class="n">instrument_polynomial</span><span class="p">:</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">instrument_polynomial</span><span class="o">.</span><span class="n">coefficients</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">coefficients</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># polynomial response using blockette 62 stage 1 and no other stages</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">response_stages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> \
           <span class="nb">isinstance</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">response_stages</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PolynomialResponseStage</span><span class="p">):</span>
            <span class="c1"># check for gain</span>
            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">response_stages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stage_gain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Stage gain not defined for </span><span class="si">%s</span><span class="s1"> - setting it to 1.0&#39;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">gain</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gain</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">response_stages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stage_gain</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">response_stages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[:]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)):</span>
                <span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">coefficients</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># use evalresp</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># time domain pre-processing</span>
        <span class="k">if</span> <span class="n">zero_mean</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">-=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">taper</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">*=</span> <span class="n">cosine_taper</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">taper_fraction</span><span class="p">,</span>
                                 <span class="n">sactaper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">halfcosine</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">color1</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
            <span class="n">color2</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
            <span class="n">bbox1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.15</span><span class="p">)</span>
            <span class="n">bbox2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.15</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">321</span><span class="p">)</span>
            <span class="n">ax1b</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
            <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">323</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>
            <span class="n">ax2b</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
            <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">325</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>
            <span class="n">ax3b</span> <span class="o">=</span> <span class="n">ax3</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
            <span class="n">ax4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">322</span><span class="p">)</span>
            <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">324</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax4</span><span class="p">)</span>
            <span class="n">ax6</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">326</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax4</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ax_</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ax3</span><span class="p">,</span> <span class="n">ax4</span><span class="p">,</span> <span class="n">ax5</span><span class="p">,</span> <span class="n">ax6</span><span class="p">):</span>
                <span class="n">ax_</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">zorder</span><span class="o">=-</span><span class="mi">10</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pre_filt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;pre_filt: None&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;pre_filt: [</span><span class="si">{:.3g}</span><span class="s1">, </span><span class="si">{:.3g}</span><span class="s1">, </span><span class="si">{:.3g}</span><span class="s1">, </span><span class="si">{:.3g}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">pre_filt</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span>
                     <span class="n">transform</span><span class="o">=</span><span class="n">ax1</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;large&quot;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span>
                     <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Data spectrum, raw&quot;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox1</span><span class="p">)</span>
            <span class="n">ax1b</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;&#39;pre_filt&#39; taper fraction&quot;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox2</span><span class="p">)</span>
            <span class="n">evalresp_info</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;output: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">output</span><span class="p">]</span> <span class="o">+</span>
                <span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">evalresp_info</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                     <span class="n">va</span><span class="o">=</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ax2</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span>
                     <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;large&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Data spectrum,</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;&#39;pre_filt&#39; applied&quot;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox1</span><span class="p">)</span>
            <span class="n">ax2b</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Instrument response&quot;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox2</span><span class="p">)</span>
            <span class="n">ax3</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s1">&#39;water_level: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">water_level</span><span class="p">,</span>
                     <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ax3</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span>
                     <span class="n">fontsize</span><span class="o">=</span><span class="s2">&quot;large&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">)</span>
            <span class="n">ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Data spectrum,</span><span class="se">\n</span><span class="s2">multiplied with inverted</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;instrument response&quot;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox1</span><span class="p">)</span>
            <span class="n">ax3b</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Inverted instrument response,</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;water level applied&quot;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox2</span><span class="p">)</span>
            <span class="n">ax3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [Hz]&quot;</span><span class="p">)</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">()</span>
            <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
            <span class="n">ax4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Raw&quot;</span><span class="p">)</span>
            <span class="n">ax4</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="n">ax4</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_position</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="n">ax5</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
            <span class="n">ax5</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Raw, after time</span><span class="se">\n</span><span class="s2">domain pre-processing&quot;</span><span class="p">)</span>
            <span class="n">ax5</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="n">ax5</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_position</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="n">ax6</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Response removed&quot;</span><span class="p">)</span>
            <span class="n">ax6</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time [s]&quot;</span><span class="p">)</span>
            <span class="n">ax6</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="n">ax6</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_position</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>

        <span class="c1"># smart calculation of nfft dodging large primes</span>
        <span class="kn">from</span> <span class="nn">obspy.signal.util</span> <span class="k">import</span> <span class="n">_npts2nfft</span>
        <span class="n">nfft</span> <span class="o">=</span> <span class="n">_npts2nfft</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span>
        <span class="c1"># Transform data to Frequency domain</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">nfft</span><span class="p">)</span>
        <span class="c1"># calculate and apply frequency response,</span>
        <span class="c1"># optionally prefilter in frequency domain and/or apply water level</span>
        <span class="n">freq_response</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> \
            <span class="n">response</span><span class="o">.</span><span class="n">get_evalresp_response</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">nfft</span><span class="p">,</span>
                                           <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>

        <span class="c1"># frequency domain pre-filtering of data spectrum</span>
        <span class="c1"># (apply cosine taper in frequency domain)</span>
        <span class="k">if</span> <span class="n">pre_filt</span><span class="p">:</span>
            <span class="n">freq_domain_taper</span> <span class="o">=</span> <span class="n">cosine_sac_taper</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">flimit</span><span class="o">=</span><span class="n">pre_filt</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">*=</span> <span class="n">freq_domain_taper</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">freq_domain_taper</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="n">freq_domain_taper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
            <span class="n">ax1b</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">freq_domain_taper</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color2</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">ax1b</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
            <span class="n">ax2b</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq_response</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color2</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">water_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No water level used, so just directly invert the response.</span>
            <span class="c1"># First entry is at zero frequency and value is zero, too.</span>
            <span class="c1"># Just do not invert the first value (and set to 0 to make sure).</span>
            <span class="n">freq_response</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">freq_response</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">freq_response</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Invert spectrum with specified water level.</span>
            <span class="n">invert_spectrum</span><span class="p">(</span><span class="n">freq_response</span><span class="p">,</span> <span class="n">water_level</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">*=</span> <span class="n">freq_response</span>
        <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mf">0.0</span><span class="n">j</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">ax3</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
            <span class="n">ax3b</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq_response</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color2</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="c1"># transform data back into the time domain</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="n">npts</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="c1"># Oftentimes raises NumPy warnings which we don&#39;t want to see.</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">ax6</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">plot</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">plot</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">fig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="c1"># assign processed data and store processing information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Trace.remove_sensitivity"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace.Trace.remove_sensitivity.html#obspy.core.trace.Trace.remove_sensitivity">[docs]</a>    <span class="nd">@_add_processing_info</span>
    <span class="k">def</span> <span class="nf">remove_sensitivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inventory</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove instrument sensitivity.</span>

<span class="sd">        :type inventory: :class:`~obspy.core.inventory.inventory.Inventory`</span>
<span class="sd">            or None.</span>
<span class="sd">        :param inventory: Station metadata to use in search for adequate</span>
<span class="sd">            response. If inventory parameter is not supplied, the response</span>
<span class="sd">            has to be attached to the trace with :meth:`Trace.attach_response`</span>
<span class="sd">            beforehand.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; from obspy import read, read_inventory</span>
<span class="sd">        &gt;&gt;&gt; tr = read()[0]</span>
<span class="sd">        &gt;&gt;&gt; inv = read_inventory()</span>
<span class="sd">        &gt;&gt;&gt; tr.remove_sensitivity(inv)  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;...Trace object at 0x...&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_response</span><span class="p">(</span><span class="n">inventory</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">response</span><span class="o">.</span><span class="n">instrument_sensitivity</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<div class="viewcode-block" id="_data_sanity_checks"><a class="viewcode-back" href="../../../packages/autogen/obspy.core.trace._data_sanity_checks.html#obspy.core.trace._data_sanity_checks">[docs]</a><span class="k">def</span> <span class="nf">_data_sanity_checks</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a given input is suitable to be used for Trace.data. Raises the</span>
<span class="sd">    corresponding exception if it is not, otherwise silently passes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Trace.data must be a NumPy array.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;NumPy array for Trace.data has bad shape (&#39;</span><span class="si">%s</span><span class="s2">&#39;). Only 1-d &quot;</span>
               <span class="s2">&quot;arrays are allowed for initialization.&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">exclude_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

</div>

<footer>
<p class="text-muted small">
By the <a href="https://github.com/orgs/obspy/people">ObsPy
Development Team</a> and many <a href="#contributers" role="button"
data-toggle="modal" data-target="#contributers">Awesome Contributors</a>™ &nbsp;|&nbsp; Built with
<a href="http://getbootstrap.com/">Bootstrap</a> and
<a href="http://glyphicons.com//">Glyphicons</a> &nbsp;|&nbsp; Copyright 2008-2016
</p>
</footer>
<div id="contributers" class="modal fade" tabindex="-1"
role="dialog" aria-labelledby="contributersLabel" aria-hidden="true">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<button type="button" class="close" data-dismiss="modal"
aria-hidden="true">&times;</button>
<h3 class="modal-title" id="contributersLabel">Thank you!</h3>
</div>
<div class="modal-body">
<p>We would like to thank our contributors, whose efforts make
this software what it is. These people have helped by writing code
and documentation, and by testing. They have created and
maintained this product, its associated libraries and
applications, our build tools and our web sites.</p>
<h4>Contributors</h4>
<div class="container-fluid">
<div class="row">
<div class="col-md-6">
<ul>
<li>Ammon, Charles J.</li>
<li>Arnarsson, Ólafur St.</li>
<li>Barsch, Robert</li>
<li>Bernardi, Fabrizio</li>
<li>Beyreuther, Moritz</li>
<li>Carothers, Lloyd</li>
<li>Egdorf, Sven</li>
<li>Ermert, Laura</li>
<li>Fabbri, Tommaso</li>
<li>Grunberg, Marc</li>
<li>Heimann, Sebastian</li>
<li>Hope, Gaute</li>
<li>Inza, Adolfo</li>
<li>Ketchum, David</li>
<li>Kremers, Simon</li>
<li>Krieger, Lars</li>
<li>Käufl, Paul</li>
<li>Lecocq, Thomas</li>
<li>Lesage, Philippe</li>
<li>Lopes, Rui L.</li>
<li>Maggi, Alessia</li>
<li>Megies, Tobias</li>
<li>Michelini, Alberto</li>
<li>Morgenstern, Bernhard</li>
<li>Panning, Mark P.</li>
<li>Reyes, Celso</li>
<li>Rothenhäusler, Nicolas</li>
<li>Sales de Andrade, Elliott</li>
<li>Saul, Joachim</li>
<li>Sippl, Christian</li>
<li>Stange, Stefan</li>
<li>Trabant, Chad</li>
<li>Walker, Andrew</li>
<li>Wassermann, Joachim</li>
<li>Winkelman, Andrew</li>
<li>van Driel, Martin</li>
</ul>
</div>
<div class="col-md-6">
<ul>
<li>Antunes, Emanuel</li>
<li>Bank, Markus</li>
<li>Behr, Yannik</li>
<li>Bernauer, Felix</li>
<li>Bonaimé, Sébastien</li>
<li>Danecek, Peter</li>
<li>Engels, Fabian</li>
<li>Eulenfeld, Tom</li>
<li>Grellier, Clément</li>
<li>Hammer, Conny</li>
<li>Heiniger, Lukas</li>
<li>Igel, Heiner</li>
<li>Isken, Marius</li>
<li>Koymans, Mathijs</li>
<li>Kress, Victor</li>
<li>Krischer, Lion</li>
<li>Köhler, Andreas</li>
<li>Leeman, John</li>
<li>Lomax, Anthony</li>
<li>MacCarthy, Jonathan</li>
<li>Martin, Henri</li>
<li>Meschede, Matthias</li>
<li>Miller, Nathaniel C.</li>
<li>Nof, Ran Novitsky</li>
<li>Rapagnani, Giovanni</li>
<li>Ringler, Adam</li>
<li>Russo, Emiliano</li>
<li>Satriano, Claudio</li>
<li>Scheingraber, Chris</li>
<li>Snoke, Arthur</li>
<li>Sullivan, Benjamin</li>
<li>Uieda, Leonardo</li>
<li>Walther, Marcus</li>
<li>Williams, Mark C.</li>
<li>Zad, Seyed Kasra Hosseini</li>
</ul>
</div>
</div>
</div>
<h4>Funds</h4>
<p>ObsPy was partially funded by the</p>
<ul>
<li>German Science Foundation (DFG) via grant DFG IG 16/9-1</li>
<li>German Ministry for Education and Research (BMBF), GEOTECHNOLOGIEN grant 03G0646H.</li>
<li>NERA project (Network of European Research Infrastructures for Earthquake Risk Assessment and Mitigation) under the European Community&#39;s Seventh Framework Programme (FP7/2007-2013) grant agreement n° 262330</li>
<li>Leibniz Institute for Applied Geophysics (LIAG)</li>
<li>VERCE EU-FP7 project (no. 283543)</li>
</ul>
</div>
<div class="modal-footer">
<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
</div>
</div>
</div>
</div>

</div>


  </body>
</html>