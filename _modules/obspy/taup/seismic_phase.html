<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>obspy.taup.seismic_phase &#8212; ObsPy Documentation (1.0.3)</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/font.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/base.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript">
  var shiftWindow = function() { scrollBy(0, -70) };
  if (location.hash) shiftWindow();
  window.addEventListener("hashchange", shiftWindow);
</script>

  </head>
  <body>
<div id="wrapper">
<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
<div class="container-fluid">
<div class="navbar-header">
<button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a href="/" class="navbar-brand" title="Home"><span class="icon-obspy"></span>&nbsp;ObsPy</a>
</div>
<div class="navbar-collapse collapse">
<form class="navbar-form navbar-right" role="search" method="get" action="http://docs.obspy.org/search.html">
<div class="form-group">
<input type="text" class="form-control" placeholder="Search Docs" name="q">
</div>
</form>
<ul class="nav navbar-nav navbar-right">
<li><a href="https://github.com/obspy/obspy/" title="GitHub"><span class="icon-github iconx2"></span><span class="hidden-sm">&nbsp;GitHub</span></a></li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Documentation"><span class="glyphicon glyphicon-book iconx2"></span><span class="hidden-sm">&nbsp;Documentation</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Getting&nbsp;Started</li>
<li><a href="https://github.com/obspy/obspy/wiki#installation">Installation</a></li>
<li><a href="https://tutorial.obspy.org/">Tutorial</a></li>
<li><a href="http://gallery.obspy.org/">Gallery</a></li>
<li><a href="https://docs.obspy.org/">API&nbsp;Documentation&nbsp;(latest&nbsp;release)</a></li>
<li><a href="https://docs.obspy.org/master/">API&nbsp;Documentation&nbsp;(current&nbsp;master)</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Mailing&nbsp;Lists"><span class="glyphicon glyphicon-envelope iconx2"></span><span class="hidden-sm">&nbsp;Mailing&nbsp;Lists</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Announcements&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-announcements"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-announcements/"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archive</a></li>
<li class="divider"></li>
<li class="dropdown-header">Users&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-users"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-users"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archives</a></li>
<li><a href="mailto:users@obspy.org"><span class="glyphicon glyphicon-envelope"></span>&nbsp;Post&nbsp;a&nbsp;message</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Developer&nbsp;Resources"><span class="glyphicon glyphicon-cog iconx2"></span><span class="hidden-sm">&nbsp;Developer&nbsp;Resources</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li><a href="https://gitter.im/obspy/obspy">Gitter</a></li>
<li><a href="https://github.com/obspy/obspy/blob/master/.github/CONTRIBUTING.md">How&nbsp;to&nbsp;contribute</a></li>
<li><a href="http://docs.obspy.org/coding_style.html">Coding&nbsp;Style&nbsp;Guide</a></li>
<li><a href="https://github.com/obspy/obspy/releases/">All&nbsp;Releases</a></li>
<li class="divider"></li>
<li class="dropdown-header">Code&nbsp;Analysis</li>
<li><a href="http://docs.obspy.org/master/pep8/index.html">PEP8</a></li>
<li><a href="http://docs.obspy.org/master/coverage/index.html">Python&nbsp;Coverage</a></li>
<li><a href="http://docs.obspy.org/master/c_coverage/index.html">C&nbsp;Coverage</a></li>
<li><a href="https://coveralls.io/r/obspy/obspy?branch=master">Coveralls</a></li>
<li class="divider"></li>
<li class="dropdown-header">Continuous&nbsp;Integration</li>
<li><a href="http://tests.obspy.org/">Test&nbsp;Reports</a></li>
<li><a href="https://travis-ci.org/obspy/obspy/"><span class="icon-travis"></span>&nbsp;Travis&nbsp;CI</a></li>
<li><a href="https://ci.appveyor.com/project/obspy/obspy"><span class="icon-appveyor"></span>&nbsp;AppVeyor</a></li>
</ul>
</li>
</ul>
</div>
</div>
</nav>

<div id="content" class="container">
  
    <div class="breadcrumb pull-right"><a href="../../../genindex.html" title="General Index"
         accesskey="I">index</a><span style="color: #ccc; padding: 0 5px;">| </span><a href="../../../py-modindex.html" title="Python Module Index"
         >modules</a>
    </div>
    <ol class="breadcrumb">
        <li><a href="../../../contents.html">ObsPy Documentation (1.0.3)</a></li>
        <li><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ol>
  
  <h1>Source code for obspy.taup.seismic_phase</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Objects and functions dealing with seismic phases.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">future.builtins</span> <span class="k">import</span> <span class="o">*</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">future.utils</span> <span class="k">import</span> <span class="n">raise_from</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">count</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">obspy.core.util.obspy_types</span> <span class="k">import</span> <span class="n">Enum</span>

<span class="kn">from</span> <span class="nn">.helper_classes</span> <span class="k">import</span> <span class="p">(</span><span class="n">Arrival</span><span class="p">,</span> <span class="n">SlownessModelError</span><span class="p">,</span> <span class="n">TauModelError</span><span class="p">,</span>
                             <span class="n">TimeDist</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.c_wrappers</span> <span class="k">import</span> <span class="n">clibtau</span>


<span class="n">REFINE_DIST_RADIAN_TOL</span> <span class="o">=</span> <span class="mf">0.0049</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>


<span class="n">_ACTIONS</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">([</span>
    <span class="c1"># Used by add_to_branch when the path turns within a segment. We assume</span>
    <span class="c1"># that no ray will turn downward so turning implies turning from downward</span>
    <span class="c1"># to upward, ie U.</span>
    <span class="s2">&quot;turn&quot;</span><span class="p">,</span>
    <span class="c1"># Used by add_to_branch when the path reflects off the top of the end of</span>
    <span class="c1"># a segment, ie ^.</span>
    <span class="s2">&quot;reflect_underside&quot;</span><span class="p">,</span>
    <span class="c1"># Used by add_to_branch when the path reflects off the bottom of the end</span>
    <span class="c1"># of a segment, ie v.</span>
    <span class="s2">&quot;reflect_topside&quot;</span><span class="p">,</span>
    <span class="c1"># Used by add_to_branch when the path transmits up through the end of a</span>
    <span class="c1"># segment.</span>
    <span class="s2">&quot;transup&quot;</span><span class="p">,</span>
    <span class="c1"># Used by add_to_branch when the path transmits down through the end of a</span>
    <span class="c1"># segment.</span>
    <span class="s2">&quot;transdown&quot;</span>
<span class="p">])</span>


<div class="viewcode-block" id="SeismicPhase"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.html#obspy.taup.seismic_phase.SeismicPhase">[docs]</a><span class="k">class</span> <span class="nc">SeismicPhase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stores and transforms seismic phase names to and from their</span>
<span class="sd">    corresponding sequence of branches. Will maybe contain &quot;expert&quot; mode</span>
<span class="sd">    wherein paths may start in the core. Principal use is to calculate leg</span>
<span class="sd">    contributions for scattered phases. Nomenclature: &quot;K&quot; - downgoing wave</span>
<span class="sd">    from source in core; &quot;k&quot; - upgoing wave from source in core.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SeismicPhase.__init__"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.__init__.html#obspy.taup.seismic_phase.SeismicPhase.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tau_model</span><span class="p">,</span> <span class="n">receiver_depth</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="c1"># The phase name, e.g. PKiKP.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1"># The receiver depth within the TauModel that was used to generate this</span>
        <span class="c1"># phase. Normally this is 0.0 for a surface station, but can be</span>
        <span class="c1"># different for borehole or scattering calculations.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span> <span class="o">=</span> <span class="n">receiver_depth</span>
        <span class="c1"># TauModel to generate phase for.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span> <span class="o">=</span> <span class="n">tau_model</span>

        <span class="c1"># The source depth within the TauModel that was used to generate</span>
        <span class="c1"># this phase.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">source_depth</span>

        <span class="c1"># List containing strings for each leg.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="n">leg_puller</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Name with depths corrected to be actual discontinuities in the model.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">purist_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_purist_name</span><span class="p">(</span><span class="n">tau_model</span><span class="p">)</span>

        <span class="c1"># Settings for this instance. Should eventually be configurable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1"># The maximum degrees that a Pn or Sn can refract along the moho.</span>
            <span class="c1"># Note this is not the total distance, only the segment along the</span>
            <span class="c1"># moho.</span>
            <span class="s2">&quot;max_refraction_in_radians&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">20.0</span><span class="p">),</span>
            <span class="c1"># The maximum degrees that a Pdiff or Sdiff can diffract along the</span>
            <span class="c1"># CMB. Note this is not the total distance, only the segment along</span>
            <span class="c1"># the CMB.</span>
            <span class="s2">&quot;max_diffraction_in_radians&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">60.0</span><span class="p">),</span>
            <span class="c1"># The maximum number of refinements to make to an Arrival.</span>
            <span class="s2">&quot;max_recursion&quot;</span><span class="p">:</span> <span class="mi">5</span>
        <span class="p">}</span>

        <span class="c1"># Enables phases originating in core.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expert</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Minimum/maximum ray parameters that exist for this phase.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Index within TauModel.ray_param that corresponds to max_ray_param.</span>
        <span class="c1"># Note that max_ray_param_index &lt; min_ray_param_index as ray parameter</span>
        <span class="c1"># decreases with increasing index.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># Index within TauModel.ray_param that corresponds to min_ray_param.</span>
        <span class="c1"># Note that max_ray_param_index &lt; min_ray_param_index as ray parameter</span>
        <span class="c1"># decreases with increasing index.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># Temporary branch numbers determining where to start adding to the</span>
        <span class="c1"># branch sequence.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Array of distances corresponding to the ray parameters stored in</span>
        <span class="c1"># ray_param.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Array of times corresponding to the ray parameters stored in</span>
        <span class="c1"># ray_param.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Array of possible ray parameters for this phase.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># The minimum distance that this phase can be theoretically observed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_distance</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># The maximum distance that this phase can be theoretically observed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_distance</span> <span class="o">=</span> <span class="mf">1e300</span>
        <span class="c1"># List (could make array!) of branch numbers for the given phase.</span>
        <span class="c1"># Note that this depends upon both the planet model and the source</span>
        <span class="c1"># depth.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># True if the current leg of the phase is down going. This allows a</span>
        <span class="c1"># check to make sure the path is correct.</span>
        <span class="c1"># Used in addToBranch() and parseName().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># ArrayList of wave types corresponding to each leg of the phase.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parse_name</span><span class="p">(</span><span class="n">tau_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_branches</span><span class="p">(</span><span class="n">tau_model</span><span class="p">)</span></div>

<div class="viewcode-block" id="SeismicPhase.create_purist_name"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.create_purist_name.html#obspy.taup.seismic_phase.SeismicPhase.create_purist_name">[docs]</a>    <span class="k">def</span> <span class="nf">create_purist_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau_model</span><span class="p">):</span>
        <span class="n">current_leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Deal with surface wave veocities first, since they are a special</span>
        <span class="c1"># case.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">current_leg</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;kmps&quot;</span><span class="p">):</span>
            <span class="n">purist_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="k">return</span> <span class="n">purist_name</span>
        <span class="n">purist_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># Only loop to penultimate element as last leg is always &quot;END&quot;.</span>
        <span class="k">for</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># Find out if the next leg represents a phase conversion or</span>
            <span class="c1"># reflection depth.</span>
            <span class="k">if</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;v^&quot;</span><span class="p">:</span>
                <span class="n">discon_branch</span> <span class="o">=</span> <span class="n">closest_branch_to_depth</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span>
                                                        <span class="n">current_leg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">leg_depth</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">discon_branch</span><span class="p">]</span><span class="o">.</span><span class="n">top_depth</span>
                <span class="n">purist_name</span> <span class="o">+=</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">purist_name</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">leg_depth</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">current_leg</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># If current_leg is just a string:</span>
                    <span class="n">purist_name</span> <span class="o">+=</span> <span class="n">current_leg</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If it is indeed a number:</span>
                    <span class="n">discon_branch</span> <span class="o">=</span> <span class="n">closest_branch_to_depth</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span>
                                                            <span class="n">current_leg</span><span class="p">)</span>
                    <span class="n">leg_depth</span> <span class="o">=</span> \
                        <span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">discon_branch</span><span class="p">]</span><span class="o">.</span><span class="n">top_depth</span>
                    <span class="n">purist_name</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">leg_depth</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">purist_name</span></div>

<div class="viewcode-block" id="SeismicPhase.parse_name"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.parse_name.html#obspy.taup.seismic_phase.SeismicPhase.parse_name">[docs]</a>    <span class="k">def</span> <span class="nf">parse_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau_model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a branch sequence from the given phase name and tau model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">next_leg</span> <span class="o">=</span> <span class="n">current_leg</span>

        <span class="c1"># Deal with surface wave velocities first, since they are a special</span>
        <span class="c1"># case.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">current_leg</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;kmps&quot;</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Make a check for J legs if the model doesn&#39;t allow J:</span>
        <span class="k">if</span> <span class="s2">&quot;J&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">allow_inner_core_s</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span><span class="s2">&quot;J phases are not created for this model: </span><span class="si">{}</span><span class="s2">&quot;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="c1"># Set currWave to be the wave type for this leg, P or S</span>
        <span class="k">if</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;P&quot;</span><span class="p">:</span>
            <span class="n">is_p_wave</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">is_p_wave_previous</span> <span class="o">=</span> <span class="n">is_p_wave</span>
        <span class="k">elif</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
            <span class="n">is_p_wave</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">is_p_wave_previous</span> <span class="o">=</span> <span class="n">is_p_wave</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span><span class="s1">&#39;Unknown starting phase: &#39;</span> <span class="o">+</span> <span class="n">current_leg</span><span class="p">)</span>

        <span class="c1"># First, decide whether the ray is upgoing or downgoing from the</span>
        <span class="c1"># source. If it is up going then the first branch number would be</span>
        <span class="c1"># model.source_branch-1 and downgoing would be model.source_branch.</span>
        <span class="n">upgoing_rec_branch</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">find_branch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span><span class="p">)</span>
        <span class="n">downgoing_rec_branch</span> <span class="o">=</span> <span class="n">upgoing_rec_branch</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># One branch shallower.</span>
        <span class="k">if</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;sS&quot;</span><span class="p">:</span>
            <span class="c1"># Exclude S sources in fluids.</span>
            <span class="n">sdep</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">source_depth</span>
            <span class="k">if</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_depth</span> <span class="o">&lt;</span> <span class="n">sdep</span> <span class="o">&lt;</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">iocb_depth</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">return</span>

        <span class="c1"># Set self.max_ray_param to be a horizontal ray leaving the source and</span>
        <span class="c1"># self.min_ray_param to be a vertical (p=0) ray.</span>
        <span class="k">if</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;PS&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expert</span> <span class="ow">and</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;KIJ&quot;</span><span class="p">):</span>
            <span class="c1"># Downgoing from source.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">source_branch</span>
            <span class="c1"># Treat initial downgoing as if it were an underside reflection.</span>
            <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">s_layer_num</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">layer_number_below</span><span class="p">(</span>
                    <span class="n">tau_model</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span> <span class="n">is_p_wave_previous</span><span class="p">)</span>
                <span class="n">layer</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">get_slowness_layer</span><span class="p">(</span>
                    <span class="n">s_layer_num</span><span class="p">,</span> <span class="n">is_p_wave_previous</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;top_p&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="n">SlownessModelError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">raise_from</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Please contact the developers. This &#39;</span>
                                        <span class="s1">&#39;error should not occur.&#39;</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">source_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">)</span><span class="o">.</span><span class="n">max_ray_param</span>
        <span class="k">elif</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expert</span> <span class="ow">and</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;k&quot;</span><span class="p">):</span>
            <span class="c1"># Upgoing from source: treat initial downgoing as if it were a</span>
            <span class="c1"># topside reflection.</span>
            <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_topside&quot;</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">s_layer_num</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">layer_number_above</span><span class="p">(</span>
                    <span class="n">tau_model</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span> <span class="n">is_p_wave_previous</span><span class="p">)</span>
                <span class="n">layer</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">get_slowness_layer</span><span class="p">(</span>
                    <span class="n">s_layer_num</span><span class="p">,</span> <span class="n">is_p_wave_previous</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="s1">&#39;bot_p&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="n">SlownessModelError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">raise_from</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Please contact the developers. This &#39;</span>
                                        <span class="s1">&#39;error should not occur.&#39;</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">source_branch</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">source_branch</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># p and s for zero source depth are only at zero distance</span>
                <span class="c1"># and then can be called P or S.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                <span class="s1">&#39;First phase not recognised </span><span class="si">{}</span><span class="s1">: Must be one of P, Pg, Pn, &#39;</span>
                <span class="s1">&#39;Pdiff, p, Ped or the S equivalents.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_leg</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Ped&#39;</span><span class="p">,</span> <span class="s1">&#39;Sed&#39;</span><span class="p">):</span>
                <span class="c1"># Downgoing at receiver</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span>
                        <span class="n">downgoing_rec_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">)</span><span class="o">.</span><span class="n">min_turn_ray_param</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># upgoing at receiver</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">upgoing_rec_branch</span><span class="p">,</span>
                                             <span class="n">is_p_wave</span><span class="p">)</span><span class="o">.</span><span class="n">min_turn_ray_param</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">is_leg_depth</span><span class="p">,</span> <span class="n">is_next_leg_depth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>

        <span class="c1"># Now loop over all the phase legs and construct the proper branch</span>
        <span class="c1"># sequence.</span>
        <span class="n">current_leg</span> <span class="o">=</span> <span class="s2">&quot;START&quot;</span>  <span class="c1"># So the prev_leg isn&#39;t wrong on the first pass.</span>
        <span class="k">for</span> <span class="n">leg_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">prev_leg</span> <span class="o">=</span> <span class="n">current_leg</span>
            <span class="n">current_leg</span> <span class="o">=</span> <span class="n">next_leg</span>
            <span class="n">next_leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">leg_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">is_leg_depth</span> <span class="o">=</span> <span class="n">is_next_leg_depth</span>

            <span class="c1"># Find out if the next leg represents a phase conversion depth.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">next_leg_depth</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">next_leg</span><span class="p">)</span>
                <span class="n">is_next_leg_depth</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">next_leg_depth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">is_next_leg_depth</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Set currWave to be the wave type for this leg, &quot;P&quot; or &quot;S&quot;.</span>
            <span class="n">is_p_wave_previous</span> <span class="o">=</span> <span class="n">is_p_wave</span>
            <span class="k">if</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;P&quot;</span><span class="p">:</span>
                <span class="n">is_p_wave</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                <span class="n">is_p_wave</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">current_leg</span> <span class="o">==</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
                <span class="c1"># Here we want to use whatever is_p_wave was on the last leg</span>
                <span class="c1"># so do nothing. This makes sure we use the correct</span>
                <span class="c1"># max_ray_param from the correct TauBranch within the outer</span>
                <span class="c1"># core. In other words K has a high slowness zone if it</span>
                <span class="c1"># entered the outer core as a mantle P wave, but doesn&#39;t if</span>
                <span class="c1"># it entered as a mantle S wave. It shouldn&#39;t matter for</span>
                <span class="c1"># inner core to outer core type legs.</span>
                <span class="k">pass</span>

            <span class="c1"># Check to see if there has been a phase conversion.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">is_p_wave_previous</span> <span class="o">!=</span> <span class="n">is_p_wave</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phase_conversion</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                      <span class="n">end_action</span><span class="p">,</span> <span class="n">is_p_wave_previous</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Ped&#39;</span><span class="p">,</span> <span class="s1">&#39;Sed&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s2">&quot;END&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                           <span class="n">downgoing_rec_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                           <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># This should be impossible except for 0 dist 0 source</span>
                        <span class="c1"># depth which can be called p or P.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                        <span class="s2">&quot;Phase not recognized: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">))</span>

            <span class="c1"># Deal with p and s case.</span>
            <span class="k">elif</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">next_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                        <span class="s2">&quot;p and s must always be upgoing and cannot come &quot;</span>
                        <span class="s2">&quot;immediately before a top-sided reflection.&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">next_leg</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;^&quot;</span><span class="p">):</span>
                    <span class="n">discon_branch</span> <span class="o">=</span> <span class="n">closest_branch_to_depth</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span> <span class="o">&gt;=</span> <span class="n">discon_branch</span><span class="p">:</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                            <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">discon_branch</span><span class="p">,</span>
                            <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                            <span class="s2">&quot;Phase not recognised: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2"> when &quot;</span>
                            <span class="s2">&quot;current_branch &gt; discon_branch&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span> <span class="ow">and</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span> <span class="o">&gt;=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span><span class="p">:</span>
                    <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span><span class="p">,</span>
                        <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">next_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">next_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="s2">&quot;END&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s1">&#39;END&#39;</span><span class="p">:</span>
                        <span class="n">discon_branch</span> <span class="o">=</span> <span class="n">upgoing_rec_branch</span>
                    <span class="k">elif</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span>
                        <span class="n">discon_branch</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">discon_branch</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">current_leg</span> <span class="o">==</span> <span class="s1">&#39;k&#39;</span> <span class="ow">and</span> <span class="n">next_leg</span> <span class="o">!=</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">discon_branch</span><span class="p">,</span>
                        <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">is_next_leg_depth</span><span class="p">:</span>
                    <span class="n">discon_branch</span> <span class="o">=</span> <span class="n">closest_branch_to_depth</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span>
                                                            <span class="n">next_leg</span><span class="p">)</span>
                    <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">discon_branch</span><span class="p">,</span>
                        <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                        <span class="s2">&quot;Phase not recognized: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">))</span>

            <span class="c1"># Now deal with P and S case.</span>
            <span class="k">elif</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">next_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Pn&quot;</span><span class="p">,</span> <span class="s2">&quot;Sn&quot;</span><span class="p">,</span> <span class="s2">&quot;END&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transdown&quot;</span><span class="p">]</span> <span class="ow">or</span> \
                            <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]:</span>
                        <span class="c1"># Was downgoing, so must first turn in mantle.</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                           <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                           <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s1">&#39;END&#39;</span><span class="p">:</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                           <span class="n">upgoing_rec_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                           <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                            <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                            <span class="n">end_action</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">next_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                    <span class="n">discon_branch</span> <span class="o">=</span> <span class="n">closest_branch_to_depth</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span>
                                                            <span class="n">next_leg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span> <span class="o">&lt;=</span> <span class="n">discon_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_topside&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                           <span class="n">discon_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                           <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                            <span class="s2">&quot;Phase not recognised: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2"> when &quot;</span>
                            <span class="s2">&quot;current_branch &gt; discon_branch&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">next_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span>
                    <span class="n">discon_branch</span> <span class="o">=</span> <span class="n">closest_branch_to_depth</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span>
                                                            <span class="n">next_leg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="k">if</span> <span class="n">prev_leg</span> <span class="o">==</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                           <span class="n">discon_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                           <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">prev_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span> <span class="ow">or</span> <span class="n">prev_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span>
                                                            <span class="s2">&quot;START&quot;</span><span class="p">):</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                           <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                           <span class="n">end_action</span><span class="p">)</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                            <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">discon_branch</span><span class="p">,</span>
                            <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">((</span><span class="n">prev_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span> <span class="ow">and</span>
                            <span class="n">discon_branch</span> <span class="o">&lt;</span> <span class="n">closest_branch_to_depth</span><span class="p">(</span>
                                <span class="n">tau_model</span><span class="p">,</span> <span class="n">prev_leg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="ow">or</span>
                           <span class="p">(</span><span class="n">prev_leg</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span> <span class="ow">and</span>
                               <span class="n">discon_branch</span> <span class="o">&lt;</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span><span class="p">)</span> <span class="ow">or</span>
                           <span class="p">(</span><span class="n">prev_leg</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span> <span class="ow">and</span>
                               <span class="n">discon_branch</span> <span class="o">&lt;</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span><span class="p">))):</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                            <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">discon_branch</span><span class="p">,</span>
                            <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                            <span class="s2">&quot;Phase not recognised: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2"> when &quot;</span>
                            <span class="s2">&quot;current_branch &gt; discon_branch&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
                    <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_topside&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                        <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
                    <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transdown&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                        <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_next_leg_depth</span> <span class="ow">and</span>
                                         <span class="n">next_leg_depth</span> <span class="o">&lt;</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_depth</span><span class="p">):</span>
                    <span class="c1"># Treat the Moho in the same way as 410 type</span>
                    <span class="c1"># discontinuities.</span>
                    <span class="n">discon_branch</span> <span class="o">=</span> <span class="n">closest_branch_to_depth</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span>
                                                            <span class="n">next_leg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]</span> \
                            <span class="ow">or</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_topside&quot;</span><span class="p">]</span> \
                            <span class="ow">or</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]:</span>
                        <span class="c1"># Upgoing section</span>
                        <span class="k">if</span> <span class="n">discon_branch</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">:</span>
                            <span class="c1"># Check the discontinuity below the current</span>
                            <span class="c1"># branch when the ray should be upgoing</span>
                            <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                                <span class="s2">&quot;Phase not recognised: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2"> when &quot;</span>
                                <span class="s2">&quot;current_branch &gt; discon_branch&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">))</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                            <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">discon_branch</span><span class="p">,</span>
                            <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Downgoing section, must look at leg after next to</span>
                        <span class="c1"># determine whether to convert on the downgoing or</span>
                        <span class="c1"># upgoing part of the path.</span>
                        <span class="n">next_next_leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">leg_num</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">next_next_leg</span> <span class="o">==</span> <span class="s2">&quot;p&quot;</span> <span class="ow">or</span> <span class="n">next_next_leg</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span>
                            <span class="c1"># Convert on upgoing section</span>
                            <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                                <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                <span class="n">end_action</span><span class="p">)</span>
                            <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                               <span class="n">discon_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                               <span class="n">end_action</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">next_next_leg</span> <span class="o">==</span> <span class="s2">&quot;P&quot;</span> <span class="ow">or</span> <span class="n">next_next_leg</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">discon_branch</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">:</span>
                                <span class="c1"># discon is below current loc</span>
                                <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transdown&quot;</span><span class="p">]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                                    <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                    <span class="n">discon_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Discontinuity is above current location,</span>
                                <span class="c1"># but we have a downgoing ray, so this is an</span>
                                <span class="c1"># illegal ray for this source depth.</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                                <span class="k">return</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                                <span class="s2">&quot;Phase not recognized: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2"> &quot;</span>
                                <span class="s2">&quot;followed by </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">,</span>
                                                        <span class="n">next_next_leg</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                        <span class="s2">&quot;Phase not recognized: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;PS&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">current_leg</span> <span class="o">==</span> <span class="s2">&quot;Pdiff&quot;</span> <span class="ow">or</span> <span class="n">current_leg</span> <span class="o">==</span> <span class="s2">&quot;Sdiff&quot;</span><span class="p">:</span>
                    <span class="c1"># In the diffracted case we trick addtoBranch into</span>
                    <span class="c1"># thinking we are turning, but then make max_ray_param</span>
                    <span class="c1"># equal to min_ray_param, which is the deepest turning ray.</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">&gt;=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span>
                            <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">is_p_wave</span><span class="p">)</span><span class="o">.</span><span class="n">min_turn_ray_param</span> <span class="o">&gt;=</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">):</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                           <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                           <span class="n">end_action</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span>
                        <span class="k">if</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s2">&quot;END&quot;</span><span class="p">:</span>
                            <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                               <span class="n">upgoing_rec_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                               <span class="n">end_action</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">next_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;PS&quot;</span><span class="p">:</span>
                            <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                                <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Can&#39;t have head wave as ray param is not within</span>
                        <span class="c1"># range.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">return</span>
                <span class="k">elif</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Pg&quot;</span><span class="p">,</span> <span class="s2">&quot;Sg&quot;</span><span class="p">,</span> <span class="s2">&quot;Pn&quot;</span><span class="p">,</span> <span class="s2">&quot;Sn&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span> <span class="o">&gt;=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span><span class="p">:</span>
                        <span class="c1"># Pg, Pn, Sg and Sn must be above the moho and so is</span>
                        <span class="c1"># not valid for rays coming upwards from below,</span>
                        <span class="c1"># possibly due to the source depth. Setting</span>
                        <span class="c1"># max_ray_param = -1 effectively disallows this phase.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">return</span>
                    <span class="k">if</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Pg&quot;</span><span class="p">,</span> <span class="s2">&quot;Sg&quot;</span><span class="p">):</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                           <span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                           <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                           <span class="n">upgoing_rec_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                                           <span class="n">end_action</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;Pn&quot;</span><span class="p">,</span> <span class="s2">&quot;Sn&quot;</span><span class="p">):</span>
                        <span class="c1"># In the diffracted case we trick addtoBranch into</span>
                        <span class="c1"># thinking we are turning below the Moho, but then</span>
                        <span class="c1"># make the min_ray_param equal to max_ray_param,</span>
                        <span class="c1"># which is the head wave ray.</span>
                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">&gt;=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span>
                                <span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span><span class="p">,</span>
                                <span class="n">is_p_wave</span><span class="p">)</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">&gt;=</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">):</span>
                            <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                                <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                <span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                            <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                                <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                <span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span>
                            <span class="k">if</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s2">&quot;END&quot;</span><span class="p">:</span>
                                <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                                    <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                                    <span class="n">upgoing_rec_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">next_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;PS&quot;</span><span class="p">:</span>
                                <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                                    <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                    <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Can&#39;t have head wave as ray param is not</span>
                            <span class="c1"># within range.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                        <span class="s2">&quot;Phase not recognized: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">current_leg</span> <span class="o">==</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">next_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">prev_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;START&quot;</span><span class="p">):</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                            <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                            <span class="n">tau_model</span><span class="o">.</span><span class="n">iocb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                    <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span><span class="p">,</span>
                        <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">prev_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;K&quot;</span><span class="p">):</span>
                        <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                            <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                            <span class="n">tau_model</span><span class="o">.</span><span class="n">iocb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                    <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span><span class="p">,</span>
                        <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">next_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">):</span>
                    <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transdown&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                        <span class="n">tau_model</span><span class="o">.</span><span class="n">iocb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
                    <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_topside&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                        <span class="n">tau_model</span><span class="o">.</span><span class="n">iocb_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                        <span class="s2">&quot;Phase not recognized: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">):</span>
                <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                    <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span>
                    <span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">next_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">):</span>
                    <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">iocb_branch</span><span class="p">,</span>
                        <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">next_leg</span> <span class="o">==</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
                    <span class="n">end_action</span> <span class="o">=</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_to_branch</span><span class="p">(</span>
                        <span class="n">tau_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span><span class="p">,</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">iocb_branch</span><span class="p">,</span>
                        <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">end_action</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">current_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">elif</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">closest_branch_to_depth</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="n">current_leg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                        <span class="s2">&quot;Phase not recognized: </span><span class="si">{}</span><span class="s2"> looks like a top side &quot;</span>
                        <span class="s2">&quot;reflection at the free surface.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_leg</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">is_leg_depth</span><span class="p">:</span>
                <span class="c1"># Check for phase like P0s, but could also be P2s if first</span>
                <span class="c1"># discontinuity is deeper.</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">closest_branch_to_depth</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="n">current_leg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">next_leg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                        <span class="s2">&quot;Phase not recognized: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2"> looks like &quot;</span>
                        <span class="s2">&quot;an upgoing wave from the free surface as closest &quot;</span>
                        <span class="s2">&quot;discontinuity to </span><span class="si">{}</span><span class="s2"> is zero depth.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">,</span> <span class="n">current_leg</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span>
                    <span class="s2">&quot;Phase not recognized: </span><span class="si">{}</span><span class="s2"> followed by </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">current_leg</span><span class="p">,</span> <span class="n">next_leg</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="n">downgoing_rec_branch</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># Last action was upgoing, so last branch should be</span>
                <span class="c1"># upgoing_rec_branch</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_topside&quot;</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="n">upgoing_rec_branch</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># Last action was downgoing, so last branch should be</span>
                <span class="c1"># downgoing_rec_branch</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="SeismicPhase.phase_conversion"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.phase_conversion.html#obspy.taup.seismic_phase.SeismicPhase.phase_conversion">[docs]</a>    <span class="k">def</span> <span class="nf">phase_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau_model</span><span class="p">,</span> <span class="n">from_branch</span><span class="p">,</span> <span class="n">end_action</span><span class="p">,</span> <span class="n">is_p_to_s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change max_ray_param and min_ray_param where there is a phase</span>
<span class="sd">        conversion.</span>

<span class="sd">        For instance, SKP needs to change the max_ray_param because there are</span>
<span class="sd">        SKS ray parameters that cannot propagate from the CMB into the mantle</span>
<span class="sd">        as a P wave.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]:</span>
            <span class="c1"># Can&#39;t phase convert for just a turn point</span>
            <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span><span class="s2">&quot;Bad end_action: phase conversion is not &quot;</span>
                                <span class="s2">&quot;allowed at turn points.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> \
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span>
                    <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">from_branch</span><span class="p">,</span>
                                             <span class="n">is_p_to_s</span><span class="p">)</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span>
                    <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">from_branch</span><span class="p">,</span>
                                             <span class="ow">not</span> <span class="n">is_p_to_s</span><span class="p">)</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_topside&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">from_branch</span><span class="p">,</span>
                                         <span class="n">is_p_to_s</span><span class="p">)</span><span class="o">.</span><span class="n">min_turn_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">from_branch</span><span class="p">,</span>
                                         <span class="ow">not</span> <span class="n">is_p_to_s</span><span class="p">)</span><span class="o">.</span><span class="n">min_turn_ray_param</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">from_branch</span><span class="p">,</span> <span class="n">is_p_to_s</span><span class="p">)</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">from_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                         <span class="ow">not</span> <span class="n">is_p_to_s</span><span class="p">)</span><span class="o">.</span><span class="n">min_turn_ray_param</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transdown&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">from_branch</span><span class="p">,</span> <span class="n">is_p_to_s</span><span class="p">)</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">from_branch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                         <span class="ow">not</span> <span class="n">is_p_to_s</span><span class="p">)</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span><span class="s2">&quot;Illegal end_action = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end_action</span><span class="p">))</span></div>

<div class="viewcode-block" id="SeismicPhase.add_to_branch"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.add_to_branch.html#obspy.taup.seismic_phase.SeismicPhase.add_to_branch">[docs]</a>    <span class="k">def</span> <span class="nf">add_to_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau_model</span><span class="p">,</span> <span class="n">start_branch</span><span class="p">,</span> <span class="n">end_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span>
                      <span class="n">end_action</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add branch numbers to branch_seq.</span>

<span class="sd">        Branches from start_branch to end_branch, inclusive, are added in</span>
<span class="sd">        order. Also, current_branch is set correctly based on the value of</span>
<span class="sd">        end_action. end_action can be one of transup, transdown,</span>
<span class="sd">        reflect_underside, reflect_topside, or turn.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">end_branch</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">end_branch</span> <span class="o">&gt;</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;End branch outside range: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">end_branch</span><span class="p">,</span> <span class="p">))</span>

        <span class="k">if</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;turn&quot;</span><span class="p">]:</span>
            <span class="n">end_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">is_down_going</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">end_branch</span><span class="p">,</span>
                                         <span class="n">is_p_wave</span><span class="p">)</span><span class="o">.</span><span class="n">min_turn_ray_param</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_underside&quot;</span><span class="p">]:</span>
            <span class="n">end_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">is_down_going</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">end_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">)</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;reflect_topside&quot;</span><span class="p">]:</span>
            <span class="n">end_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">is_down_going</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">end_branch</span><span class="p">,</span>
                                         <span class="n">is_p_wave</span><span class="p">)</span><span class="o">.</span><span class="n">min_turn_ray_param</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transup&quot;</span><span class="p">]:</span>
            <span class="n">end_offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">is_down_going</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">end_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">)</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">end_action</span> <span class="o">==</span> <span class="n">_ACTIONS</span><span class="p">[</span><span class="s2">&quot;transdown&quot;</span><span class="p">]:</span>
            <span class="n">end_offset</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">is_down_going</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">,</span>
                <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">end_branch</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">)</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span><span class="s2">&quot;Illegal end_action: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end_action</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">is_down_going</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start_branch</span> <span class="o">&gt;</span> <span class="n">end_branch</span><span class="p">:</span>
                <span class="c1"># Can&#39;t be downgoing as we are already below.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Must be downgoing, so increment i.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_branch</span><span class="p">,</span> <span class="n">end_branch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">is_down_going</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">is_p_wave</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start_branch</span> <span class="o">&lt;</span> <span class="n">end_branch</span><span class="p">:</span>
                <span class="c1"># Can&#39;t be upgoing as we are already above.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Upgoing, so decrement i.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_branch</span><span class="p">,</span> <span class="n">end_branch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">is_down_going</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">is_p_wave</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span> <span class="o">=</span> <span class="n">end_branch</span> <span class="o">+</span> <span class="n">end_offset</span></div>

<div class="viewcode-block" id="SeismicPhase.sum_branches"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.sum_branches.html#obspy.taup.seismic_phase.SeismicPhase.sum_branches">[docs]</a>    <span class="k">def</span> <span class="nf">sum_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau_model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sum the appropriate branches for this phase.&quot;&quot;&quot;</span>
        <span class="c1"># Special case for surface waves.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;kmps&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">tau_model</span><span class="o">.</span><span class="n">radius_of_planet</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> \
                <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">radius_of_planet</span> <span class="o">/</span> \
                <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">min_distance</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_distance</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">:</span>
            <span class="c1"># Phase has no arrivals, possibly due to source depth.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_distance</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span>

        <span class="c1"># Find the ray parameter index that corresponds to the min_ray_param</span>
        <span class="c1"># and max_ray_param.</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tau_model</span><span class="o">.</span><span class="n">ray_params</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tau_model</span><span class="o">.</span><span class="n">ray_params</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span> <span class="o">==</span> <span class="mi">0</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau_model</span><span class="o">.</span><span class="n">ray_params</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># All ray parameters are valid so just copy:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">ray_param</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param_index</span><span class="p">:</span>
            <span class="c1"># if &quot;Sdiff&quot; in self.name or &quot;Pdiff&quot; in self.name:</span>
            <span class="c1"># self.ray_param = [self.min_ray_param, self.min_ray_param]</span>
            <span class="c1"># elif &quot;Pn&quot; in self.name or &quot;Sn&quot; in self.name:</span>
            <span class="c1"># self.ray_param = [self.min_ray_param, self.min_ray_param]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;kmps&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only a subset of the ray parameters is valid so use these.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">=</span> \
                <span class="n">tau_model</span><span class="o">.</span><span class="n">ray_params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span><span class="p">:</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Counter for passes through each branch. 0 is P and 1 is S.</span>
        <span class="n">times_branches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_branch_mult</span><span class="p">(</span><span class="n">tau_model</span><span class="p">)</span>

        <span class="c1"># Sum the branches with the appropriate multiplier.</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param_index</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">tb</span> <span class="o">=</span> <span class="n">times_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">tbs</span> <span class="o">=</span> <span class="n">times_branches</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">taub</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">taubs</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">tb</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tb</span> <span class="o">*</span> <span class="n">taub</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tb</span> <span class="o">*</span> <span class="n">taub</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">tbs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tbs</span> <span class="o">*</span> <span class="n">taubs</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tbs</span> <span class="o">*</span> <span class="n">taubs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;Sdiff&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;Pdiff&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">depth_in_high_slowness</span><span class="p">(</span>
                    <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_depth</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;P&quot;</span><span class="p">):</span>
                <span class="c1"># No diffraction if there is a high slowness zone at the CMB.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_distance</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="s2">&quot;max_diffraction_in_radians&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="s2">&quot;max_diffraction_in_radians&quot;</span><span class="p">]</span> <span class="o">*</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">)</span>

        <span class="k">elif</span> <span class="s2">&quot;Pn&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;Sn&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="s2">&quot;max_refraction_in_radians&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="s2">&quot;max_refraction_in_radians&quot;</span><span class="p">]</span> <span class="o">*</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">)</span>

        <span class="c1"># Now check to see if our ray parameter range includes any ray</span>
        <span class="c1"># parameters that are associated with high slowness zones. If so,</span>
        <span class="c1"># then we will need to insert a &quot;shadow zone&quot; into our time and</span>
        <span class="c1"># distance arrays. It is represented by a repeated ray parameter.</span>
        <span class="k">for</span> <span class="n">isPwave</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
            <span class="n">hsz</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">high_slowness_layer_depths_p</span> \
                <span class="k">if</span> <span class="n">isPwave</span> \
                <span class="k">else</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">high_slowness_layer_depths_s</span>
            <span class="n">index_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">hszi</span> <span class="ow">in</span> <span class="n">hsz</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">&gt;</span> <span class="n">hszi</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">:</span>
                    <span class="c1"># There is a high slowness zone within our ray parameter</span>
                    <span class="c1"># range so might need to add a shadow zone. Need to</span>
                    <span class="c1"># check if the current wave type is part of the phase at</span>
                    <span class="c1"># this depth/ray parameter.</span>
                    <span class="n">branch_num</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">find_branch</span><span class="p">(</span><span class="n">hszi</span><span class="o">.</span><span class="n">top_depth</span><span class="p">)</span>
                    <span class="n">found_overlap</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">leg_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">)):</span>
                        <span class="c1"># Check for downgoing legs that cross the high</span>
                        <span class="c1"># slowness zone with the same wave type.</span>
                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">[</span><span class="n">leg_num</span><span class="p">]</span> <span class="o">==</span> <span class="n">branch_num</span> <span class="ow">and</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">[</span><span class="n">leg_num</span><span class="p">]</span> <span class="o">==</span> <span class="n">isPwave</span> <span class="ow">and</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="p">[</span><span class="n">leg_num</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">[</span><span class="n">leg_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span>
                                <span class="n">branch_num</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">[</span><span class="n">leg_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">isPwave</span> <span class="ow">and</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="p">[</span><span class="n">leg_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span>
                            <span class="n">found_overlap</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">found_overlap</span><span class="p">:</span>
                        <span class="n">hsz_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">==</span> <span class="n">hszi</span><span class="o">.</span><span class="n">ray_param</span><span class="p">)</span>
                        <span class="n">hsz_index</span> <span class="o">=</span> <span class="n">hsz_index</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                        <span class="n">newlen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">new_ray_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">newlen</span><span class="p">)</span>
                        <span class="n">newdist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">newlen</span><span class="p">)</span>
                        <span class="n">newtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">newlen</span><span class="p">)</span>

                        <span class="n">new_ray_params</span><span class="p">[:</span><span class="n">hsz_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[:</span><span class="n">hsz_index</span><span class="p">]</span>
                        <span class="n">newdist</span><span class="p">[:</span><span class="n">hsz_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[:</span><span class="n">hsz_index</span><span class="p">]</span>
                        <span class="n">newtime</span><span class="p">[:</span><span class="n">hsz_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[:</span><span class="n">hsz_index</span><span class="p">]</span>

                        <span class="c1"># Sum the branches with an appropriate multiplier.</span>
                        <span class="n">new_ray_params</span><span class="p">[</span><span class="n">hsz_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">hszi</span><span class="o">.</span><span class="n">ray_param</span>
                        <span class="n">newdist</span><span class="p">[</span><span class="n">hsz_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">newtime</span><span class="p">[</span><span class="n">hsz_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">tb</span><span class="p">,</span> <span class="n">tbs</span><span class="p">,</span> <span class="n">taub</span><span class="p">,</span> <span class="n">taubs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                                <span class="n">times_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times_branches</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                <span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">tb</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">taub</span><span class="o">.</span><span class="n">top_depth</span> <span class="o">&lt;</span> <span class="n">hszi</span><span class="o">.</span><span class="n">top_depth</span><span class="p">:</span>
                                <span class="n">newdist</span><span class="p">[</span><span class="n">hsz_index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tb</span> <span class="o">*</span> <span class="n">taub</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span> <span class="o">+</span> <span class="n">hsz_index</span> <span class="o">-</span>
                                    <span class="n">index_offset</span><span class="p">]</span>
                                <span class="n">newtime</span><span class="p">[</span><span class="n">hsz_index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tb</span> <span class="o">*</span> <span class="n">taub</span><span class="o">.</span><span class="n">time</span><span class="p">[</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span> <span class="o">+</span> <span class="n">hsz_index</span> <span class="o">-</span>
                                    <span class="n">index_offset</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">tbs</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">taubs</span><span class="o">.</span><span class="n">top_depth</span> <span class="o">&lt;</span> <span class="n">hszi</span><span class="o">.</span><span class="n">top_depth</span><span class="p">:</span>
                                <span class="n">newdist</span><span class="p">[</span><span class="n">hsz_index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tbs</span> <span class="o">*</span> <span class="n">taubs</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span> <span class="o">+</span> <span class="n">hsz_index</span> <span class="o">-</span>
                                    <span class="n">index_offset</span><span class="p">]</span>
                                <span class="n">newtime</span><span class="p">[</span><span class="n">hsz_index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tbs</span> <span class="o">*</span> <span class="n">taubs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param_index</span> <span class="o">+</span> <span class="n">hsz_index</span> <span class="o">-</span>
                                    <span class="n">index_offset</span><span class="p">]</span>

                        <span class="n">newdist</span><span class="p">[</span><span class="n">hsz_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">hsz_index</span><span class="p">:]</span>
                        <span class="n">newtime</span><span class="p">[</span><span class="n">hsz_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">hsz_index</span><span class="p">:]</span>
                        <span class="n">new_ray_params</span><span class="p">[</span><span class="n">hsz_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[</span><span class="n">hsz_index</span><span class="p">:]</span>

                        <span class="n">index_offset</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">newdist</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">newtime</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">=</span> <span class="n">new_ray_params</span></div>

<div class="viewcode-block" id="SeismicPhase.calc_branch_mult"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.calc_branch_mult.html#obspy.taup.seismic_phase.SeismicPhase.calc_branch_mult">[docs]</a>    <span class="k">def</span> <span class="nf">calc_branch_mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau_model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate how many times the phase passes through a branch, up or down.</span>

<span class="sd">        With this result, we can just multiply instead of doing the ray calc</span>
<span class="sd">        for each time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialise the counter for each branch to 0. 0 is P and 1 is S.</span>
        <span class="n">times_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># Count how many times each branch appears in the path.</span>
        <span class="c1"># wave_type is at least as long as branch_seq</span>
        <span class="k">for</span> <span class="n">wt</span><span class="p">,</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">wt</span><span class="p">:</span>
                <span class="n">times_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">bs</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">times_branches</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">bs</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">times_branches</span></div>

<div class="viewcode-block" id="SeismicPhase.calc_time"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.calc_time.html#obspy.taup.seismic_phase.SeismicPhase.calc_time">[docs]</a>    <span class="k">def</span> <span class="nf">calc_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate arrival times for this phase, sorted by time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 100 should finally be enough...this in only for one phase after</span>
        <span class="c1"># all..</span>
        <span class="n">r_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">r_ray_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># This saves around 17% runtime when calculating arrival times which</span>
        <span class="c1"># is probably the major use case.</span>
        <span class="n">phase_count</span> <span class="o">=</span> <span class="n">clibtau</span><span class="o">.</span><span class="n">seismic_phase_calc_time_inner_loop</span><span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">degrees</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_distance</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">,</span>
            <span class="n">r_dist</span><span class="p">,</span>
            <span class="n">r_ray_num</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">arrivals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">phase_count</span><span class="p">):</span>
            <span class="n">arrivals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refine_arrival</span><span class="p">(</span>
                <span class="n">degrees</span><span class="p">,</span> <span class="n">r_ray_num</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">r_dist</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">REFINE_DIST_RADIAN_TOL</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_settings</span><span class="p">[</span><span class="s2">&quot;max_recursion&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">arrivals</span></div>

<div class="viewcode-block" id="SeismicPhase.calc_pierce"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.calc_pierce.html#obspy.taup.seismic_phase.SeismicPhase.calc_pierce">[docs]</a>    <span class="k">def</span> <span class="nf">calc_pierce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate pierce points for this phase.</span>

<span class="sd">        First calculates arrivals, then the &quot;pierce points&quot; corresponding to</span>
<span class="sd">        the stored arrivals. The pierce points are stored within each arrival</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arrivals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_time</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arrival</span> <span class="ow">in</span> <span class="n">arrivals</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_pierce_from_arrival</span><span class="p">(</span><span class="n">arrival</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arrivals</span></div>

<div class="viewcode-block" id="SeismicPhase.calc_pierce_from_arrival"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.calc_pierce_from_arrival.html#obspy.taup.seismic_phase.SeismicPhase.calc_pierce_from_arrival">[docs]</a>    <span class="k">def</span> <span class="nf">calc_pierce_from_arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_arrival</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the pierce points for a particular arrival.</span>

<span class="sd">        The returned arrival is the same as the input argument but now has the</span>
<span class="sd">        pierce points filled in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find the ray parameter index that corresponds to the arrival ray</span>
        <span class="c1"># parameter in the TauModel, ie it is between ray_num and ray_num+1,</span>
        <span class="c1"># We know that it must be &lt;model.ray_param.length-1 since the last</span>
        <span class="c1"># ray parameter sample is 0 in a spherical model.</span>
        <span class="n">ray_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">ray_params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">rp</span> <span class="o">&gt;=</span> <span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param</span><span class="p">:</span>
                <span class="n">ray_num</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Here we use ray parameter and dist info stored within the</span>
        <span class="c1"># SeismicPhase so we can use curr_arrival.ray_param_index, which</span>
        <span class="c1"># may not correspond to ray_num (for model.ray_param).</span>
        <span class="n">ray_param_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param_index</span><span class="p">]</span>
        <span class="n">ray_param_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">dist_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param_index</span><span class="p">]</span>
        <span class="n">dist_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">dist_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">-</span> <span class="n">dist_a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dist_b</span> <span class="o">-</span> <span class="n">dist_a</span><span class="p">)</span>
        <span class="n">dist_ray_param</span> <span class="o">=</span> <span class="n">dist_ratio</span> <span class="o">*</span> <span class="p">(</span><span class="n">ray_param_b</span> <span class="o">-</span> <span class="n">ray_param_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">ray_param_a</span>

        <span class="c1"># + 2 for first point and kmps, if it exists.</span>
        <span class="n">pierce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">TimeDist</span><span class="p">)</span>
        <span class="c1"># First pierce point is always 0 distance at the source depth.</span>
        <span class="n">pierce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_ray_param</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">source_depth</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">branch_dist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">branch_time</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Loop from 0 but already done 0 [I just copy the comments, sorry!],</span>
        <span class="c1"># so the pierce point when the ray leaves branch i is stored in i + 1.</span>
        <span class="c1"># Use linear interpolation between rays that we know.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">)</span> <span class="o">==</span> \
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">branch_num</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">is_down_going</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="p">):</span>
            <span class="c1"># Save the turning depths for the ray parameter for both P and</span>
            <span class="c1"># S waves. This way we get the depth correct for any rays that</span>
            <span class="c1"># turn within a layer. We have to do this on a per branch basis</span>
            <span class="c1"># because of converted phases, e.g. SKS.</span>
            <span class="n">tau_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">branch_num</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dist_ray_param</span> <span class="o">&gt;</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">:</span>
                <span class="n">turn_depth</span> <span class="o">=</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">top_depth</span>
            <span class="k">elif</span> <span class="n">dist_ray_param</span> <span class="o">&lt;=</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">:</span>
                <span class="n">turn_depth</span> <span class="o">=</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">bot_depth</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_p_wave</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">depth_in_fluid</span><span class="p">((</span>
                        <span class="n">tau_branch</span><span class="o">.</span><span class="n">top_depth</span> <span class="o">+</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">bot_depth</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)):</span>
                    <span class="n">turn_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">find_depth_from_depths</span><span class="p">(</span>
                        <span class="n">dist_ray_param</span><span class="p">,</span>
                        <span class="n">tau_branch</span><span class="o">.</span><span class="n">top_depth</span><span class="p">,</span>
                        <span class="n">tau_branch</span><span class="o">.</span><span class="n">bot_depth</span><span class="p">,</span>
                        <span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">turn_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">find_depth_from_depths</span><span class="p">(</span>
                        <span class="n">dist_ray_param</span><span class="p">,</span>
                        <span class="n">tau_branch</span><span class="o">.</span><span class="n">top_depth</span><span class="p">,</span>
                        <span class="n">tau_branch</span><span class="o">.</span><span class="n">bot_depth</span><span class="p">,</span>
                        <span class="n">is_p_wave</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Pdiff&quot;</span><span class="p">,</span> <span class="s2">&quot;Pn&quot;</span><span class="p">,</span> <span class="s2">&quot;Sdiff&quot;</span><span class="p">,</span> <span class="s2">&quot;Sn&quot;</span><span class="p">]):</span>
                <span class="c1"># Head waves and diffracted waves are a special case.</span>
                <span class="n">dist_a</span> <span class="o">=</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">ray_num</span><span class="p">]</span>
                <span class="n">time_a</span> <span class="o">=</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">ray_num</span><span class="p">]</span>
                <span class="n">dist_b</span><span class="p">,</span> <span class="n">time_b</span> <span class="o">=</span> <span class="n">dist_a</span><span class="p">,</span> <span class="n">time_a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dist_a</span> <span class="o">=</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">ray_num</span><span class="p">]</span>
                <span class="n">time_a</span> <span class="o">=</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">ray_num</span><span class="p">]</span>
                <span class="n">dist_b</span> <span class="o">=</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">ray_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">time_b</span> <span class="o">=</span> <span class="n">tau_branch</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">ray_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">branch_dist</span> <span class="o">+=</span> <span class="n">dist_ratio</span> <span class="o">*</span> <span class="p">(</span><span class="n">dist_b</span> <span class="o">-</span> <span class="n">dist_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">dist_a</span>
            <span class="n">prev_branch_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branch_time</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">branch_time</span> <span class="o">+=</span> <span class="n">dist_ratio</span> <span class="o">*</span> <span class="p">(</span><span class="n">time_b</span> <span class="o">-</span> <span class="n">time_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">time_a</span>
            <span class="k">if</span> <span class="n">is_down_going</span><span class="p">:</span>
                <span class="n">branch_depth</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tau_branch</span><span class="o">.</span><span class="n">bot_depth</span><span class="p">,</span> <span class="n">turn_depth</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">branch_depth</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tau_branch</span><span class="o">.</span><span class="n">top_depth</span><span class="p">,</span> <span class="n">turn_depth</span><span class="p">)</span>

            <span class="c1"># Make sure ray actually propagates in this branch; leave a little</span>
            <span class="c1"># room for numerical chatter.</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">prev_branch_time</span> <span class="o">-</span> <span class="n">branch_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                <span class="n">pierce</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_ray_param</span><span class="p">,</span> <span class="n">branch_time</span><span class="p">,</span> <span class="n">branch_dist</span><span class="p">,</span>
                                 <span class="n">branch_depth</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Pdiff&quot;</span><span class="p">,</span> <span class="s2">&quot;Pn&quot;</span><span class="p">,</span> <span class="s2">&quot;Sdiff&quot;</span><span class="p">,</span> <span class="s2">&quot;Sn&quot;</span><span class="p">]):</span>
            <span class="n">pierce</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_special_waves</span><span class="p">(</span><span class="n">curr_arrival</span><span class="p">,</span>
                                                      <span class="n">pierce</span><span class="p">,</span>
                                                      <span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;kmps&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">pierce</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_ray_param</span><span class="p">,</span> <span class="n">curr_arrival</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                             <span class="n">curr_arrival</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">curr_arrival</span><span class="o">.</span><span class="n">pierce</span> <span class="o">=</span> <span class="n">pierce</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>
        <span class="c1"># The arrival is modified in place and must (?) thus be returned.</span>
        <span class="k">return</span> <span class="n">curr_arrival</span></div>

<div class="viewcode-block" id="SeismicPhase.calc_path"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.calc_path.html#obspy.taup.seismic_phase.SeismicPhase.calc_path">[docs]</a>    <span class="k">def</span> <span class="nf">calc_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the paths this phase takes through the planet model.</span>

<span class="sd">        Only calls :meth:`calc_path_from_arrival`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arrivals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_time</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arrival</span> <span class="ow">in</span> <span class="n">arrivals</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_path_from_arrival</span><span class="p">(</span><span class="n">arrival</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arrivals</span></div>

<div class="viewcode-block" id="SeismicPhase.calc_path_from_arrival"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.calc_path_from_arrival.html#obspy.taup.seismic_phase.SeismicPhase.calc_path_from_arrival">[docs]</a>    <span class="k">def</span> <span class="nf">calc_path_from_arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_arrival</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the paths this phase takes through the planet model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find the ray parameter index that corresponds to the arrival ray</span>
        <span class="c1"># parameter in the TauModel, i.e. it is between ray_num and</span>
        <span class="c1"># ray_num + 1.</span>
        <span class="n">temp_time_dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">source_depth</span><span class="p">)</span>
        <span class="c1"># path_list is a list of lists.</span>
        <span class="n">path_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">temp_time_dist</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">branch_num</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">,</span> <span class="n">is_down_going</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="p">):</span>
            <span class="n">br</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">branch_num</span><span class="p">,</span> <span class="n">is_p_wave</span><span class="p">)</span>
            <span class="n">temp_time_dist</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param</span><span class="p">,</span> <span class="n">is_down_going</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_time_dist</span><span class="p">):</span>
                <span class="n">path_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">temp_time_dist</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">temp_time_dist</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Path is backtracking, &quot;</span>
                                       <span class="s2">&quot;this is impossible.&quot;</span><span class="p">)</span>

            <span class="c1"># Special case for head and diffracted waves:</span>
            <span class="k">if</span><span class="p">(</span><span class="n">branch_num</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span>
               <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span>
               <span class="p">(</span><span class="s2">&quot;Pdiff&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;Sdiff&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)):</span>
                <span class="n">dist_diff</span> <span class="o">=</span> <span class="n">curr_arrival</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">diff_td</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param</span><span class="p">,</span>
                    <span class="n">dist_diff</span> <span class="o">*</span> <span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param</span><span class="p">,</span>
                    <span class="n">dist_diff</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_depth</span><span class="p">)</span>
                <span class="n">path_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diff_td</span><span class="p">)</span>

            <span class="k">elif</span><span class="p">(</span><span class="n">branch_num</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span> <span class="ow">and</span>
                 <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">branch_seq</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span> <span class="ow">and</span>
                 <span class="p">(</span><span class="s2">&quot;Pn&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;Sn&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)):</span>
                <span class="c1"># Can&#39;t have both Pn and Sn in a wave, so one of these is 0.</span>
                <span class="n">num_found</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;Pn&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;Sn&quot;</span><span class="p">))</span>
                <span class="n">dist_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">-</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">num_found</span>
                <span class="n">head_td</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param</span><span class="p">,</span>
                    <span class="n">dist_head</span> <span class="o">*</span> <span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param</span><span class="p">,</span>
                    <span class="n">dist_head</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">moho_depth</span><span class="p">)</span>
                <span class="n">path_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head_td</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;kmps&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="c1"># kmps phases have no branches, so need to end them at the arrival</span>
            <span class="c1"># distance.</span>
            <span class="n">head_td</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param</span><span class="p">,</span>
                <span class="n">curr_arrival</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">*</span> <span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param</span><span class="p">,</span>
                <span class="n">curr_arrival</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">)</span>
            <span class="n">path_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head_td</span><span class="p">)</span>

        <span class="n">curr_arrival</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">TimeDist</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">])</span>
        <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">curr_arrival</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">curr_arrival</span></div>

<div class="viewcode-block" id="SeismicPhase.handle_special_waves"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.handle_special_waves.html#obspy.taup.seismic_phase.SeismicPhase.handle_special_waves">[docs]</a>    <span class="k">def</span> <span class="nf">handle_special_waves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_arrival</span><span class="p">,</span> <span class="n">pierce</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handle head or diffracted waves.</span>

<span class="sd">        It is assumed that a phase can be a diffracted wave or a head wave, but</span>
<span class="sd">        not both. Nor can it be a head wave or diffracted wave for both P and</span>
<span class="sd">        S.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Pn&quot;</span><span class="p">,</span> <span class="s2">&quot;Sn&quot;</span><span class="p">,</span> <span class="s2">&quot;Pdiff&quot;</span><span class="p">,</span> <span class="s2">&quot;Sdiff&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">ps</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">phase_seg</span> <span class="o">=</span> <span class="n">ps</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TauModelError</span><span class="p">(</span><span class="s2">&quot;No head/diff segment in&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">phase_seg</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Pn&quot;</span><span class="p">,</span> <span class="s2">&quot;Sn&quot;</span><span class="p">]:</span>
            <span class="n">head_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">moho_depth</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_depth</span>

        <span class="n">num_found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">phase_seg</span><span class="p">)</span>
        <span class="n">refract_dist</span> <span class="o">=</span> <span class="n">curr_arrival</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">refract_time</span> <span class="o">=</span> <span class="n">refract_dist</span> <span class="o">*</span> <span class="n">curr_arrival</span><span class="o">.</span><span class="n">ray_param</span>

        <span class="c1"># This is a little weird as we are not checking where we are in</span>
        <span class="c1"># the phase name, but simply if the depth matches. This likely</span>
        <span class="c1"># works in most cases, but may not for head/diffracted waves that</span>
        <span class="c1"># undergo a phase change, if that type of phase can even exist.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">pierce</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">][:</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">head_depth</span>
        <span class="n">adjust</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">pierce</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][:</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">adjust</span> <span class="o">*</span> <span class="n">refract_time</span> <span class="o">/</span> <span class="n">num_found</span>
        <span class="n">pierce</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">][:</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">adjust</span> <span class="o">*</span> <span class="n">refract_dist</span> <span class="o">/</span> <span class="n">num_found</span>

        <span class="n">head_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">head_index</span><span class="p">):</span>
            <span class="n">head_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">td</span> <span class="o">=</span> <span class="n">pierce</span><span class="p">[</span><span class="n">head_index</span><span class="p">]</span>
            <span class="n">pierce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pierce</span><span class="p">,</span> <span class="n">head_index</span><span class="p">,</span> <span class="n">td</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">head_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pierce</span><span class="p">,</span> <span class="n">index</span></div>

<div class="viewcode-block" id="SeismicPhase.refine_arrival"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.refine_arrival.html#obspy.taup.seismic_phase.SeismicPhase.refine_arrival">[docs]</a>    <span class="k">def</span> <span class="nf">refine_arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">ray_index</span><span class="p">,</span> <span class="n">dist_radian</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                       <span class="n">recursion_limit</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">Arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">ray_index</span><span class="p">],</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">ray_index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[</span><span class="n">ray_index</span><span class="p">],</span>
                       <span class="n">ray_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">purist_name</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">Arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">ray_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">ray_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[</span><span class="n">ray_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="c1"># Use ray_index since dist is between ray_index and</span>
                        <span class="c1"># (ray_index + 1).</span>
                        <span class="n">ray_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">purist_name</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refine_arrival</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">dist_radian</span><span class="p">,</span>
                                    <span class="n">tolerance</span><span class="p">,</span> <span class="n">recursion_limit</span><span class="p">)</span></div>

<div class="viewcode-block" id="SeismicPhase._refine_arrival"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase._refine_arrival.html#obspy.taup.seismic_phase.SeismicPhase._refine_arrival">[docs]</a>    <span class="k">def</span> <span class="nf">_refine_arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">left_estimate</span><span class="p">,</span> <span class="n">right_estimate</span><span class="p">,</span>
                        <span class="n">search_dist</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">recursion_limit</span><span class="p">):</span>
        <span class="n">new_estimate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_interp_arrival</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">search_dist</span><span class="p">,</span>
                                                  <span class="n">left_estimate</span><span class="p">,</span>
                                                  <span class="n">right_estimate</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">recursion_limit</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;kmps&#39;</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Pdiff&#39;</span><span class="p">,</span> <span class="s1">&#39;Sdiff&#39;</span><span class="p">,</span> <span class="s1">&#39;Pn&#39;</span><span class="p">,</span> <span class="s1">&#39;Sn&#39;</span><span class="p">])):</span>
            <span class="c1"># can&#39;t shoot/refine for non-body waves</span>
            <span class="k">return</span> <span class="n">new_estimate</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">shoot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shoot_ray</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">new_estimate</span><span class="o">.</span><span class="n">ray_param</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">left_estimate</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">-</span> <span class="n">search_dist</span><span class="p">)</span> <span class="o">*</span>
                    <span class="p">(</span><span class="n">search_dist</span> <span class="o">-</span> <span class="n">shoot</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># search between left and shoot</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shoot</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">-</span>
                       <span class="n">new_estimate</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_interp_arrival</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">search_dist</span><span class="p">,</span>
                                                      <span class="n">left_estimate</span><span class="p">,</span> <span class="n">shoot</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refine_arrival</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">left_estimate</span><span class="p">,</span> <span class="n">shoot</span><span class="p">,</span>
                                                <span class="n">search_dist</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                                                <span class="n">recursion_limit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># search between shoot and right</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shoot</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">-</span>
                       <span class="n">new_estimate</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_interp_arrival</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">search_dist</span><span class="p">,</span>
                                                      <span class="n">shoot</span><span class="p">,</span> <span class="n">right_estimate</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refine_arrival</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">shoot</span><span class="p">,</span> <span class="n">right_estimate</span><span class="p">,</span>
                                                <span class="n">search_dist</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                                                <span class="n">recursion_limit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">LookupError</span><span class="p">,</span> <span class="n">SlownessModelError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">raise_from</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Please contact the developers. This &#39;</span>
                                    <span class="s1">&#39;error should not occur.&#39;</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span></div>

<div class="viewcode-block" id="SeismicPhase.shoot_ray"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.shoot_ray.html#obspy.taup.seismic_phase.SeismicPhase.shoot_ray">[docs]</a>    <span class="k">def</span> <span class="nf">shoot_ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">ray_param</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
                <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Pdiff&#39;</span><span class="p">,</span> <span class="s1">&#39;Sdiff&#39;</span><span class="p">,</span> <span class="s1">&#39;Pn&#39;</span><span class="p">,</span> <span class="s1">&#39;Sn&#39;</span><span class="p">])</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;kmps&#39;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">SlownessModelError</span><span class="p">(</span><span class="s1">&#39;Unable to shoot ray in non-body waves&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ray_param</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span> <span class="o">&lt;</span> <span class="n">ray_param</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Ray param </span><span class="si">%f</span><span class="s1"> is outside range for this phase: min=</span><span class="si">%f</span><span class="s1"> max=</span><span class="si">%f</span><span class="s1">&#39;</span>
            <span class="k">raise</span> <span class="n">SlownessModelError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">ray_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ray_param</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">max_ray_param</span><span class="p">))</span>

        <span class="c1"># looks like a body wave and ray param can propagate</span>
        <span class="k">for</span> <span class="n">ray_param_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[</span><span class="n">ray_param_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ray_param</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">tau_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span>
        <span class="n">s_mod</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span>

        <span class="c1"># counter for passes through each branch. 0 is P and 1 is S.</span>
        <span class="n">times_branches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_branch_mult</span><span class="p">(</span><span class="n">tau_model</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ray_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ray_param</span><span class="p">])</span>

        <span class="c1"># Sum the branches with the appropriate multiplier.</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">times_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">br</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">s_mod</span><span class="o">.</span><span class="n">p_wave</span><span class="p">)</span>
                <span class="n">top_layer</span> <span class="o">=</span> <span class="n">s_mod</span><span class="o">.</span><span class="n">layer_number_below</span><span class="p">(</span><span class="n">br</span><span class="o">.</span><span class="n">top_depth</span><span class="p">,</span>
                                                     <span class="n">s_mod</span><span class="o">.</span><span class="n">p_wave</span><span class="p">)</span>
                <span class="n">bot_layer</span> <span class="o">=</span> <span class="n">s_mod</span><span class="o">.</span><span class="n">layer_number_above</span><span class="p">(</span><span class="n">br</span><span class="o">.</span><span class="n">bot_depth</span><span class="p">,</span>
                                                     <span class="n">s_mod</span><span class="o">.</span><span class="n">p_wave</span><span class="p">)</span>
                <span class="n">td</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="n">calc_time_dist</span><span class="p">(</span><span class="n">s_mod</span><span class="p">,</span> <span class="n">top_layer</span><span class="p">,</span> <span class="n">bot_layer</span><span class="p">,</span> <span class="n">ray_param</span><span class="p">,</span>
                                       <span class="n">allow_turn_in_layer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">time</span> <span class="o">+=</span> <span class="n">times_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">td</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
                <span class="n">dist</span> <span class="o">+=</span> <span class="n">times_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">td</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">times_branches</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">br</span> <span class="o">=</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">get_tau_branch</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">s_mod</span><span class="o">.</span><span class="n">s_wave</span><span class="p">)</span>
                <span class="n">top_layer</span> <span class="o">=</span> <span class="n">s_mod</span><span class="o">.</span><span class="n">layer_number_below</span><span class="p">(</span><span class="n">br</span><span class="o">.</span><span class="n">top_depth</span><span class="p">,</span>
                                                     <span class="n">s_mod</span><span class="o">.</span><span class="n">s_wave</span><span class="p">)</span>
                <span class="n">bot_layer</span> <span class="o">=</span> <span class="n">s_mod</span><span class="o">.</span><span class="n">layer_number_above</span><span class="p">(</span><span class="n">br</span><span class="o">.</span><span class="n">bot_depth</span><span class="p">,</span>
                                                     <span class="n">s_mod</span><span class="o">.</span><span class="n">s_wave</span><span class="p">)</span>
                <span class="n">td</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="n">calc_time_dist</span><span class="p">(</span><span class="n">s_mod</span><span class="p">,</span> <span class="n">top_layer</span><span class="p">,</span> <span class="n">bot_layer</span><span class="p">,</span> <span class="n">ray_param</span><span class="p">,</span>
                                       <span class="n">allow_turn_in_layer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">time</span> <span class="o">+=</span> <span class="n">times_branches</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">td</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
                <span class="n">dist</span> <span class="o">+=</span> <span class="n">times_branches</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">td</span><span class="p">[</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ray_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                       <span class="n">ray_param_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">purist_name</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span><span class="p">)</span></div>

<div class="viewcode-block" id="SeismicPhase.linear_interp_arrival"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.linear_interp_arrival.html#obspy.taup.seismic_phase.SeismicPhase.linear_interp_arrival">[docs]</a>    <span class="k">def</span> <span class="nf">linear_interp_arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">search_dist</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">ray_param_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">search_dist</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># degenerate case</span>
            <span class="k">return</span> <span class="n">Arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">search_dist</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">ray_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">purist_name</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">==</span> <span class="n">search_dist</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left</span>

        <span class="n">arrival_time</span> <span class="o">=</span> <span class="p">((</span><span class="n">search_dist</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">)</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">)</span> <span class="o">*</span>
                        <span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="n">time</span><span class="p">))</span> <span class="o">+</span> <span class="n">left</span><span class="o">.</span><span class="n">time</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arrival_time</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Time is NaN, search=</span><span class="si">%f</span><span class="s1"> leftDist=</span><span class="si">%f</span><span class="s1"> leftTime=</span><span class="si">%f</span><span class="s1"> &#39;</span>
                   <span class="s1">&#39;rightDist=</span><span class="si">%f</span><span class="s1"> rightTime=</span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">search_dist</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                                      <span class="n">right</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>

        <span class="n">ray_param</span> <span class="o">=</span> <span class="p">((</span><span class="n">search_dist</span> <span class="o">-</span> <span class="n">right</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">)</span> <span class="o">/</span>
                     <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">purist_dist</span> <span class="o">-</span> <span class="n">right</span><span class="o">.</span><span class="n">purist_dist</span><span class="p">)</span> <span class="o">*</span>
                     <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">ray_param</span> <span class="o">-</span> <span class="n">right</span><span class="o">.</span><span class="n">ray_param</span><span class="p">))</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">ray_param</span>
        <span class="k">return</span> <span class="n">Arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">arrival_time</span><span class="p">,</span> <span class="n">search_dist</span><span class="p">,</span> <span class="n">ray_param</span><span class="p">,</span>
                       <span class="n">left</span><span class="o">.</span><span class="n">ray_param_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">purist_name</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span><span class="p">)</span></div>

<div class="viewcode-block" id="SeismicPhase.calc_ray_param_for_takeoff"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.calc_ray_param_for_takeoff.html#obspy.taup.seismic_phase.SeismicPhase.calc_ray_param_for_takeoff">[docs]</a>    <span class="k">def</span> <span class="nf">calc_ray_param_for_takeoff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">takeoff_degree</span><span class="p">):</span>
        <span class="n">v_mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">v_mod</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">takeoff_velocity</span> <span class="o">=</span> <span class="n">v_mod</span><span class="o">.</span><span class="n">evaluate_below</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">takeoff_velocity</span> <span class="o">=</span> <span class="n">v_mod</span><span class="o">.</span><span class="n">evaluate_above</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">LookupError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">raise_from</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Please contact the developers. This &#39;</span>
                                    <span class="s1">&#39;error should not occur.&#39;</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">radius_of_planet</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">)</span> <span class="o">*</span>
                <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">takeoff_degree</span><span class="p">))</span> <span class="o">/</span> <span class="n">takeoff_velocity</span><span class="p">)</span></div>

<div class="viewcode-block" id="SeismicPhase.calc_takeoff_angle"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.calc_takeoff_angle.html#obspy.taup.seismic_phase.SeismicPhase.calc_takeoff_angle">[docs]</a>    <span class="k">def</span> <span class="nf">calc_takeoff_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ray_param</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;kmps&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">v_mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">v_mod</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">takeoff_velocity</span> <span class="o">=</span> <span class="n">v_mod</span><span class="o">.</span><span class="n">evaluate_below</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">takeoff_velocity</span> <span class="o">=</span> <span class="n">v_mod</span><span class="o">.</span><span class="n">evaluate_above</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">LookupError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">raise_from</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Please contact the developers. This &#39;</span>
                                    <span class="s1">&#39;error should not occur.&#39;</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>

        <span class="n">takeoff_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
            <span class="n">takeoff_velocity</span> <span class="o">*</span> <span class="n">ray_param</span> <span class="o">/</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">radius_of_planet</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_depth</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># upgoing, so angle is in 90-180 range</span>
            <span class="n">takeoff_angle</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">-</span> <span class="n">takeoff_angle</span>

        <span class="k">return</span> <span class="n">takeoff_angle</span></div>

<div class="viewcode-block" id="SeismicPhase.calc_incident_angle"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.calc_incident_angle.html#obspy.taup.seismic_phase.SeismicPhase.calc_incident_angle">[docs]</a>    <span class="k">def</span> <span class="nf">calc_incident_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ray_param</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;kmps&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">v_mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">s_mod</span><span class="o">.</span><span class="n">v_mod</span>
        <span class="c1"># Very last item is &quot;END&quot;, assume first char is P or S</span>
        <span class="n">last_leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">incident_velocity</span> <span class="o">=</span> <span class="n">v_mod</span><span class="o">.</span><span class="n">evaluate_above</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span><span class="p">,</span>
                                                         <span class="n">last_leg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">incident_velocity</span> <span class="o">=</span> <span class="n">v_mod</span><span class="o">.</span><span class="n">evaluate_below</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span><span class="p">,</span>
                                                         <span class="n">last_leg</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">LookupError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">raise_from</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Please contact the developers. This &#39;</span>
                                    <span class="s1">&#39;error should not occur.&#39;</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>

        <span class="n">incident_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
            <span class="n">incident_velocity</span> <span class="o">*</span> <span class="n">ray_param</span> <span class="o">/</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_model</span><span class="o">.</span><span class="n">radius_of_planet</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">receiver_depth</span><span class="p">),</span>
            <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_going</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">incident_angle</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">-</span> <span class="n">incident_angle</span>

        <span class="k">return</span> <span class="n">incident_angle</span></div>

<div class="viewcode-block" id="SeismicPhase.get_earliest_arrival"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.SeismicPhase.get_earliest_arrival.html#obspy.taup.seismic_phase.SeismicPhase.get_earliest_arrival">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_earliest_arrival</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rel_phases</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;baaa&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="closest_branch_to_depth"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.closest_branch_to_depth.html#obspy.taup.seismic_phase.closest_branch_to_depth">[docs]</a><span class="k">def</span> <span class="nf">closest_branch_to_depth</span><span class="p">(</span><span class="n">tau_model</span><span class="p">,</span> <span class="n">depth_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the closest discontinuity to the given depth that can have</span>
<span class="sd">    reflections and phase transformations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">depth_string</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">moho_branch</span>
    <span class="k">elif</span> <span class="n">depth_string</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">cmb_branch</span>
    <span class="k">elif</span> <span class="n">depth_string</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">iocb_branch</span>
    <span class="c1"># Non-standard boundary, given by a number: must look for it.</span>
    <span class="n">discon_branch</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">discon_max</span> <span class="o">=</span> <span class="mf">1e300</span>
    <span class="n">discon_depth</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">depth_string</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tBranch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tau_model</span><span class="o">.</span><span class="n">tau_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">discon_depth</span> <span class="o">-</span> <span class="n">tBranch</span><span class="o">.</span><span class="n">top_depth</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">discon_max</span> <span class="ow">and</span> <span class="ow">not</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">ndc</span> <span class="o">==</span> <span class="n">tBranch</span><span class="o">.</span><span class="n">top_depth</span>
                    <span class="k">for</span> <span class="n">ndc</span> <span class="ow">in</span> <span class="n">tau_model</span><span class="o">.</span><span class="n">no_discon_depths</span><span class="p">)):</span>
            <span class="n">discon_branch</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">discon_max</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">discon_depth</span> <span class="o">-</span> <span class="n">tBranch</span><span class="o">.</span><span class="n">top_depth</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">discon_branch</span></div>


<div class="viewcode-block" id="self_tokenizer"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.self_tokenizer.html#obspy.taup.seismic_phase.self_tokenizer">[docs]</a><span class="k">def</span> <span class="nf">self_tokenizer</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">token</span></div>


<div class="viewcode-block" id="wrong_phase"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.wrong_phase.html#obspy.taup.seismic_phase.wrong_phase">[docs]</a><span class="k">def</span> <span class="nf">wrong_phase</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid phase name: </span><span class="si">%s</span><span class="s2"> cannot be followed by </span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">token</span><span class="p">))</span></div>


<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">Scanner</span><span class="p">([</span>
    <span class="c1"># Surface wave phase velocity &quot;phases&quot;</span>
    <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\.?\d+\.?\d*kmps&quot;</span><span class="p">,</span> <span class="n">self_tokenizer</span><span class="p">),</span>
    <span class="c1"># Composite legs.</span>
    <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Pn|Sn|Pg|Sg|Pb|Sb|Pdiff|Sdiff|Ped|Sed&quot;</span><span class="p">,</span> <span class="n">self_tokenizer</span><span class="p">),</span>
    <span class="c1"># Reflections.</span>
    <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;([\^v])([mci]|\.?\d+\.?\d*)&quot;</span><span class="p">,</span> <span class="n">self_tokenizer</span><span class="p">),</span>
    <span class="c1"># Invalid phases.</span>
    <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[PS][ps]&quot;</span><span class="p">,</span> <span class="n">wrong_phase</span><span class="p">),</span>
    <span class="c1"># Single legs.</span>
    <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[KkIiJmcPpSs]&quot;</span><span class="p">,</span> <span class="n">self_tokenizer</span><span class="p">),</span>
    <span class="c1"># Single numerical value</span>
    <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\.?\d+\.?\d*&quot;</span><span class="p">,</span> <span class="n">self_tokenizer</span><span class="p">)</span>
<span class="p">])</span>


<div class="viewcode-block" id="leg_puller"><a class="viewcode-back" href="../../../packages/autogen/obspy.taup.seismic_phase.leg_puller.html#obspy.taup.seismic_phase.leg_puller">[docs]</a><span class="k">def</span> <span class="nf">leg_puller</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tokenize a phase name into legs.</span>

<span class="sd">    For example, ``PcS`` becomes ``&#39;P&#39; + &#39;c&#39; + &#39;S&#39;`` while ``p^410P`` would</span>
<span class="sd">    become ``&#39;p&#39; + &#39;^410&#39; + &#39;P&#39;``. Once a phase name has been broken into</span>
<span class="sd">    tokens, we can begin to construct the sequence of branches to which it</span>
<span class="sd">    corresponds. Only minor error checking is done at this point, for instance</span>
<span class="sd">    ``PIP`` generates an exception but ``^410`` doesn&#39;t. It also appends</span>
<span class="sd">    ``&quot;END&quot;`` as the last leg.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">remainder</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid phase name: </span><span class="si">%s</span><span class="s2"> could not be parsed in </span><span class="si">%s</span><span class="s2">&quot;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">remainder</span><span class="p">),</span> <span class="n">name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">results</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;END&quot;</span><span class="p">]</span></div>
</pre></div>

</div>

<footer>
<p class="text-muted small">
By the <a href="https://github.com/orgs/obspy/people">ObsPy
Development Team</a> and many <a href="#contributers" role="button"
data-toggle="modal" data-target="#contributers">Awesome Contributors</a> &nbsp;|&nbsp; Built with
<a href="http://getbootstrap.com/">Bootstrap</a> and
<a href="http://glyphicons.com//">Glyphicons</a> &nbsp;|&nbsp; Copyright 2008-2016
</p>
</footer>
<div id="contributers" class="modal fade" tabindex="-1"
role="dialog" aria-labelledby="contributersLabel" aria-hidden="true">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<button type="button" class="close" data-dismiss="modal"
aria-hidden="true">&times;</button>
<h3 class="modal-title" id="contributersLabel">Thank you!</h3>
</div>
<div class="modal-body">
<p>We would like to thank our contributors, whose efforts make
this software what it is. These people have helped by writing code
and documentation, and by testing. They have created and
maintained this product, its associated libraries and
applications, our build tools and our web sites.</p>
<h4>Contributors</h4>
<div class="container-fluid">
<div class="row">
<div class="col-md-6">
<ul>
<li>Ammon, Charles J.</li>
<li>Arnarsson, lafur St.</li>
<li>Barsch, Robert</li>
<li>Bernardi, Fabrizio</li>
<li>Beyreuther, Moritz</li>
<li>Carothers, Lloyd</li>
<li>Egdorf, Sven</li>
<li>Ermert, Laura</li>
<li>Fabbri, Tommaso</li>
<li>Grunberg, Marc</li>
<li>Heimann, Sebastian</li>
<li>Hope, Gaute</li>
<li>Inza, Adolfo</li>
<li>Ketchum, David</li>
<li>Kremers, Simon</li>
<li>Krieger, Lars</li>
<li>Kufl, Paul</li>
<li>Lecocq, Thomas</li>
<li>Lesage, Philippe</li>
<li>Lopes, Rui L.</li>
<li>Maggi, Alessia</li>
<li>Megies, Tobias</li>
<li>Michelini, Alberto</li>
<li>Morgenstern, Bernhard</li>
<li>Panning, Mark P.</li>
<li>Reyes, Celso</li>
<li>Rothenhusler, Nicolas</li>
<li>Sales de Andrade, Elliott</li>
<li>Saul, Joachim</li>
<li>Sippl, Christian</li>
<li>Stange, Stefan</li>
<li>Trabant, Chad</li>
<li>Walker, Andrew</li>
<li>Wassermann, Joachim</li>
<li>Winkelman, Andrew</li>
<li>van Driel, Martin</li>
</ul>
</div>
<div class="col-md-6">
<ul>
<li>Antunes, Emanuel</li>
<li>Bank, Markus</li>
<li>Behr, Yannik</li>
<li>Bernauer, Felix</li>
<li>Bonaim, Sbastien</li>
<li>Danecek, Peter</li>
<li>Engels, Fabian</li>
<li>Eulenfeld, Tom</li>
<li>Grellier, Clment</li>
<li>Hammer, Conny</li>
<li>Heiniger, Lukas</li>
<li>Igel, Heiner</li>
<li>Isken, Marius</li>
<li>Koymans, Mathijs</li>
<li>Kress, Victor</li>
<li>Krischer, Lion</li>
<li>Khler, Andreas</li>
<li>Leeman, John</li>
<li>Lomax, Anthony</li>
<li>MacCarthy, Jonathan</li>
<li>Martin, Henri</li>
<li>Meschede, Matthias</li>
<li>Miller, Nathaniel C.</li>
<li>Nof, Ran Novitsky</li>
<li>Rapagnani, Giovanni</li>
<li>Ringler, Adam</li>
<li>Russo, Emiliano</li>
<li>Satriano, Claudio</li>
<li>Scheingraber, Chris</li>
<li>Snoke, Arthur</li>
<li>Sullivan, Benjamin</li>
<li>Uieda, Leonardo</li>
<li>Walther, Marcus</li>
<li>Williams, Mark C.</li>
<li>Zad, Seyed Kasra Hosseini</li>
</ul>
</div>
</div>
</div>
<h4>Funds</h4>
<p>ObsPy was partially funded by the</p>
<ul>
<li>German Science Foundation (DFG) via grant DFG IG 16/9-1</li>
<li>German Ministry for Education and Research (BMBF), GEOTECHNOLOGIEN grant 03G0646H.</li>
<li>NERA project (Network of European Research Infrastructures for Earthquake Risk Assessment and Mitigation) under the European Community&#39;s Seventh Framework Programme (FP7/2007-2013) grant agreement n 262330</li>
<li>Leibniz Institute for Applied Geophysics (LIAG)</li>
<li>VERCE EU-FP7 project (no. 283543)</li>
</ul>
</div>
<div class="modal-footer">
<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
</div>
</div>
</div>
</div>

</div>


  </body>
</html>