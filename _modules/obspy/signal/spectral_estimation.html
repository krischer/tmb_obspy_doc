<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>obspy.signal.spectral_estimation &#8212; ObsPy Documentation (1.0.3)</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/font.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/base.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript">
  var shiftWindow = function() { scrollBy(0, -70) };
  if (location.hash) shiftWindow();
  window.addEventListener("hashchange", shiftWindow);
</script>

  </head>
  <body>
<div id="wrapper">
<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
<div class="container-fluid">
<div class="navbar-header">
<button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a href="/" class="navbar-brand" title="Home"><span class="icon-obspy"></span>&nbsp;ObsPy</a>
</div>
<div class="navbar-collapse collapse">
<form class="navbar-form navbar-right" role="search" method="get" action="search.html">
<div class="form-group">
<input type="text" class="form-control" placeholder="Search Docs" name="q">
</div>
</form>
<ul class="nav navbar-nav navbar-right">
<li><a href="https://github.com/obspy/obspy/" title="GitHub"><span class="icon-github iconx2"></span><span class="hidden-sm">&nbsp;GitHub</span></a></li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Documentation"><span class="glyphicon glyphicon-book iconx2"></span><span class="hidden-sm">&nbsp;Documentation</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Getting&nbsp;Started</li>
<li><a href="https://github.com/obspy/obspy/wiki#installation">Installation</a></li>
<li><a href="https://tutorial.obspy.org/">Tutorial</a></li>
<li><a href="http://gallery.obspy.org/">Gallery</a></li>
<li><a href="https://docs.obspy.org/">API&nbsp;Documentation&nbsp;(latest&nbsp;release)</a></li>
<li><a href="https://docs.obspy.org/master/">API&nbsp;Documentation&nbsp;(current&nbsp;master)</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Mailing&nbsp;Lists"><span class="glyphicon glyphicon-envelope iconx2"></span><span class="hidden-sm">&nbsp;Mailing&nbsp;Lists</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Announcements&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-announcements"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-announcements/"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archive</a></li>
<li class="divider"></li>
<li class="dropdown-header">Users&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-users"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-users"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archives</a></li>
<li><a href="mailto:users@obspy.org"><span class="glyphicon glyphicon-envelope"></span>&nbsp;Post&nbsp;a&nbsp;message</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Developer&nbsp;Resources"><span class="glyphicon glyphicon-cog iconx2"></span><span class="hidden-sm">&nbsp;Developer&nbsp;Resources</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li><a href="https://gitter.im/obspy/obspy">Gitter</a></li>
<li><a href="https://github.com/obspy/obspy/blob/master/.github/CONTRIBUTING.md">How&nbsp;to&nbsp;contribute</a></li>
<li><a href="http://docs.obspy.org/coding_style.html">Coding&nbsp;Style&nbsp;Guide</a></li>
<li><a href="https://github.com/obspy/obspy/releases/">All&nbsp;Releases</a></li>
<li class="divider"></li>
<li class="dropdown-header">Code&nbsp;Analysis</li>
<li><a href="http://docs.obspy.org/master/pep8/index.html">PEP8</a></li>
<li><a href="http://docs.obspy.org/master/coverage/index.html">Python&nbsp;Coverage</a></li>
<li><a href="http://docs.obspy.org/master/c_coverage/index.html">C&nbsp;Coverage</a></li>
<li><a href="https://coveralls.io/r/obspy/obspy?branch=master">Coveralls</a></li>
<li class="divider"></li>
<li class="dropdown-header">Continuous&nbsp;Integration</li>
<li><a href="http://tests.obspy.org/">Test&nbsp;Reports</a></li>
<li><a href="https://travis-ci.org/obspy/obspy/"><span class="icon-travis"></span>&nbsp;Travis&nbsp;CI</a></li>
<li><a href="https://ci.appveyor.com/project/obspy/obspy"><span class="icon-appveyor"></span>&nbsp;AppVeyor</a></li>
</ul>
</li>
</ul>
</div>
</div>
</nav>

<div id="content" class="container">
  
    <div class="breadcrumb pull-right"><a href="../../../genindex.html" title="General Index"
         accesskey="I">index</a><span style="color: #ccc; padding: 0 5px;">| </span><a href="../../../py-modindex.html" title="Python Module Index"
         >modules</a>
    </div>
    <ol class="breadcrumb">
        <li><a href="../../../contents.html">ObsPy Documentation (1.0.3)</a></li>
        <li><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ol>
  
  <h1>Source code for obspy.signal.spectral_estimation</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Filename: spectral_estimation.py</span>
<span class="c1">#  Purpose: Various Routines Related to Spectral Estimation</span>
<span class="c1">#   Author: Tobias Megies</span>
<span class="c1">#    Email: tobias.megies@geophysik.uni-muenchen.de</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2011-2012 Tobias Megies</span>
<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Various Routines Related to Spectral Estimation</span>

<span class="sd">:copyright:</span>
<span class="sd">    The ObsPy Development Team (devs@obspy.org)</span>
<span class="sd">:license:</span>
<span class="sd">    GNU Lesser General Public License, Version 3</span>
<span class="sd">    (https://www.gnu.org/copyleft/lesser.html)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">future.builtins</span> <span class="k">import</span> <span class="o">*</span>  <span class="c1"># NOQA</span>
<span class="kn">from</span> <span class="nn">future.utils</span> <span class="k">import</span> <span class="n">native_str</span>

<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">mlab</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="k">import</span> <span class="n">LinearSegmentedColormap</span>
<span class="kn">from</span> <span class="nn">matplotlib.dates</span> <span class="k">import</span> <span class="n">date2num</span>
<span class="kn">from</span> <span class="nn">matplotlib.mlab</span> <span class="k">import</span> <span class="n">detrend_none</span><span class="p">,</span> <span class="n">window_hanning</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="k">import</span> <span class="n">FormatStrFormatter</span>

<span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">Trace</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">,</span> <span class="n">__version__</span>
<span class="kn">from</span> <span class="nn">obspy.core</span> <span class="k">import</span> <span class="n">Stats</span>
<span class="kn">from</span> <span class="nn">obspy.imaging.scripts.scan</span> <span class="k">import</span> <span class="n">compress_start_end</span>
<span class="kn">from</span> <span class="nn">obspy.core.inventory</span> <span class="k">import</span> <span class="n">Inventory</span>
<span class="kn">from</span> <span class="nn">obspy.core.util</span> <span class="k">import</span> <span class="n">get_matplotlib_version</span><span class="p">,</span> <span class="n">AttribDict</span>
<span class="kn">from</span> <span class="nn">obspy.core.util.decorator</span> <span class="k">import</span> <span class="n">deprecated_keywords</span><span class="p">,</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">obspy.core.util.deprecation_helpers</span> <span class="k">import</span> <span class="n">ObsPyDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">obspy.imaging.cm</span> <span class="k">import</span> <span class="n">obspy_sequential</span>
<span class="kn">from</span> <span class="nn">obspy.io.xseed</span> <span class="k">import</span> <span class="n">Parser</span>
<span class="kn">from</span> <span class="nn">obspy.signal.invsim</span> <span class="k">import</span> <span class="n">cosine_taper</span>
<span class="kn">from</span> <span class="nn">obspy.signal.util</span> <span class="k">import</span> <span class="n">prev_pow_2</span>
<span class="kn">from</span> <span class="nn">obspy.signal.invsim</span> <span class="k">import</span> <span class="n">paz_to_freq_resp</span><span class="p">,</span> <span class="n">evalresp</span>


<span class="n">MATPLOTLIB_VERSION</span> <span class="o">=</span> <span class="n">get_matplotlib_version</span><span class="p">()</span>

<span class="n">dtiny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>

<span class="n">NOISE_MODEL_FILE</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span>
                                <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_models.npz&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="psd"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.psd.html#obspy.signal.spectral_estimation.psd">[docs]</a><span class="k">def</span> <span class="nf">psd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window_hanning</span><span class="p">,</span>  <span class="c1"># noqa</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for :func:`matplotlib.mlab.psd`.</span>

<span class="sd">    Always returns a onesided psd (positive frequencies only), corrects for</span>
<span class="sd">    this fact by scaling with a factor of 2. Also, always normalizes to 1/Hz</span>
<span class="sd">    by dividing with sampling rate.</span>

<span class="sd">    .. deprecated:: 0.11.0</span>

<span class="sd">        This wrapper is no longer necessary. Please use the</span>
<span class="sd">        :func:`matplotlib.mlab.psd` function directly, specifying</span>
<span class="sd">        `sides=&quot;onesided&quot;` and `scale_by_freq=True`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        For details on all arguments see :func:`matplotlib.mlab.psd`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        When using `window=welch_taper`</span>
<span class="sd">        (:func:`obspy.signal.spectral_estimation.welch_taper`)</span>
<span class="sd">        and `detrend=detrend_linear` (:func:`matplotlib.mlab.detrend_linear`)</span>
<span class="sd">        the psd function delivers practically the same results as PITSA.</span>
<span class="sd">        Only DC and the first 3-4 lowest non-DC frequencies deviate very</span>
<span class="sd">        slightly. In contrast to PITSA, this routine also returns the psd value</span>
<span class="sd">        at the Nyquist frequency and therefore is one frequency sample longer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;This wrapper is no longer necessary. Please use the &#39;</span>
           <span class="s1">&#39;matplotlib.mlab.psd function directly, specifying &#39;</span>
           <span class="s1">&#39;`sides=&quot;onesided&quot;` and `scale_by_freq=True`.&#39;</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ObsPyDeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># build up kwargs</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;NFFT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NFFT</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;Fs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fs</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;detrend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detrend</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;window&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">window</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;noverlap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">noverlap</span>
    <span class="c1"># These settings make sure that the scaling is already done during the</span>
    <span class="c1"># following psd call for matplotlib versions newer than 0.98.4.</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;pad_to&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sides&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;onesided&#39;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;scale_by_freq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># do the actual call to mlab.psd</span>
    <span class="n">Pxx</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Pxx</span><span class="p">,</span> <span class="n">freqs</span></div>


<div class="viewcode-block" id="fft_taper"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.fft_taper.html#obspy.signal.spectral_estimation.fft_taper">[docs]</a><span class="k">def</span> <span class="nf">fft_taper</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cosine taper, 10 percent at each end (like done by [McNamara2004]_).</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Inplace operation, so data should be float.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">*=</span> <span class="n">cosine_taper</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mf">0.2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="welch_taper"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.welch_taper.html#obspy.signal.spectral_estimation.welch_taper">[docs]</a><span class="k">def</span> <span class="nf">welch_taper</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a welch window to data. See</span>
<span class="sd">    :func:`~obspy.signal.spectral_estimation.welch_window`.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Inplace operation, so data should be float.</span>

<span class="sd">    :type data: :class:`~numpy.ndarray`</span>
<span class="sd">    :param data: Data to apply the taper to. Inplace operation, but also</span>
<span class="sd">        returns data for convenience.</span>
<span class="sd">    :returns: Tapered data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">*=</span> <span class="n">welch_window</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="welch_window"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.welch_window.html#obspy.signal.spectral_estimation.welch_window">[docs]</a><span class="k">def</span> <span class="nf">welch_window</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a welch window for data of length n.</span>

<span class="sd">    Routine is checked against PITSA for both even and odd values, but not for</span>
<span class="sd">    strange values like n&lt;5.</span>

<span class="sd">    .. note::</span>
<span class="sd">        See e.g.:</span>
<span class="sd">        http://www.cescg.org/CESCG99/TTheussl/node7.html</span>

<span class="sd">    :type n: int</span>
<span class="sd">    :param n: Length of window function.</span>
<span class="sd">    :rtype: :class:`~numpy.ndarray`</span>
<span class="sd">    :returns: Window function for tapering data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">taper_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">taper_left</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">taper_left</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># first/last sample is zero by definition</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># even number of samples: two ones in the middle, perfectly symmetric</span>
        <span class="n">taper_right</span> <span class="o">=</span> <span class="n">taper_left</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># odd number of samples: still two ones in the middle, however, not</span>
        <span class="c1"># perfectly symmetric anymore. right side is shorter by one sample</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">taper_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">taper_right</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">taper_right</span> <span class="o">/</span> <span class="n">nn</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">taper_left</span> <span class="o">=</span> <span class="n">taper_left</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># first/last sample is zero by definition</span>
    <span class="n">taper_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">taper_right</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">taper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">taper_left</span><span class="p">,</span> <span class="n">taper_right</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">taper</span></div>


<div class="viewcode-block" id="PPSD"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.html#obspy.signal.spectral_estimation.PPSD">[docs]</a><span class="k">class</span> <span class="nc">PPSD</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to compile probabilistic power spectral densities for one combination</span>
<span class="sd">    of network/station/location/channel/sampling_rate.</span>

<span class="sd">    Calculations are based on the routine used by [McNamara2004]_.</span>
<span class="sd">    For information on New High/Low Noise Model see [Peterson1993]_.</span>

<span class="sd">    .. rubric:: Basic Usage</span>

<span class="sd">    &gt;&gt;&gt; from obspy import read</span>
<span class="sd">    &gt;&gt;&gt; from obspy.signal import PPSD</span>

<span class="sd">    &gt;&gt;&gt; st = read()</span>
<span class="sd">    &gt;&gt;&gt; tr = st.select(channel=&quot;EHZ&quot;)[0]</span>
<span class="sd">    &gt;&gt;&gt; paz = {&#39;gain&#39;: 60077000.0,</span>
<span class="sd">    ...        &#39;poles&#39;: [-0.037004+0.037016j, -0.037004-0.037016j,</span>
<span class="sd">    ...                  -251.33+0j, -131.04-467.29j, -131.04+467.29j],</span>
<span class="sd">    ...        &#39;sensitivity&#39;: 2516778400.0,</span>
<span class="sd">    ...        &#39;zeros&#39;: [0j, 0j]}</span>

<span class="sd">    &gt;&gt;&gt; ppsd = PPSD(tr.stats, paz)</span>
<span class="sd">    &gt;&gt;&gt; print(ppsd.id)</span>
<span class="sd">    BW.RJOB..EHZ</span>
<span class="sd">    &gt;&gt;&gt; print(ppsd.times_processed)</span>
<span class="sd">    []</span>

<span class="sd">    Now we could add data to the probabilistic psd (all processing like</span>
<span class="sd">    demeaning, tapering and so on is done internally) and plot it like ...</span>

<span class="sd">    &gt;&gt;&gt; ppsd.add(st) # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; print(ppsd.times) # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; ppsd.plot() # doctest: +SKIP</span>

<span class="sd">    ... but the example stream is too short and does not contain enough data.</span>

<span class="sd">    .. note::</span>

<span class="sd">        For a real world example see the `ObsPy Tutorial`_.</span>

<span class="sd">    .. rubric:: Saving and Loading</span>

<span class="sd">    The PPSD object supports saving to a numpy npz compressed binary file:</span>

<span class="sd">    &gt;&gt;&gt; ppsd.save_npz(&quot;myfile.npz&quot;) # doctest: +SKIP</span>

<span class="sd">    The saved PPSD can then be loaded again using the static method</span>
<span class="sd">    :func:`~obspy.signal.spectral_estimation.PPSD.load_npz`, e.g. to plot the</span>
<span class="sd">    results again. If additional data is to be processed (note that another</span>
<span class="sd">    option is to combine multiple npz files using</span>
<span class="sd">    :meth:`~obspy.signal.spectral_estimation.PPSD.add_npz`), metadata must be</span>
<span class="sd">    provided again, since they are not stored in the numpy npz file:</span>

<span class="sd">    &gt;&gt;&gt; ppsd = PPSD.load_npz(&quot;myfile.npz&quot;)  # doctest: +SKIP</span>

<span class="sd">    .. note::</span>

<span class="sd">        When using metadata from an</span>
<span class="sd">        :class:`~obspy.core.inventory.inventory.Inventory`,</span>
<span class="sd">        a :class:`~obspy.io.xseed.parser.Parser` instance or from a RESP file,</span>
<span class="sd">        information on metadata will be correctly picked for the respective</span>
<span class="sd">        starttime of the data trace. This means that instrument changes are</span>
<span class="sd">        correctly taken into account during response removal.</span>
<span class="sd">        This is obviously not the case for a static PAZ dictionary!</span>

<span class="sd">    .. _`ObsPy Tutorial`: https://docs.obspy.org/tutorial/</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NPZ_STORE_KEYS_LIST_TYPES</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># things related to processed data</span>
        <span class="s1">&#39;_times_data&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_times_gaps&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_times_processed&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_binned_psds&#39;</span><span class="p">]</span>
    <span class="n">NPZ_STORE_KEYS_VERSION_NUMBERS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># version numbers</span>
        <span class="s1">&#39;ppsd_version&#39;</span><span class="p">,</span>
        <span class="s1">&#39;obspy_version&#39;</span><span class="p">,</span>
        <span class="s1">&#39;numpy_version&#39;</span><span class="p">,</span>
        <span class="s1">&#39;matplotlib_version&#39;</span><span class="p">]</span>
    <span class="n">NPZ_STORE_KEYS_SIMPLE_TYPES</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># things related to Stats passed at __init__</span>
        <span class="s1">&#39;id&#39;</span><span class="p">,</span>
        <span class="s1">&#39;sampling_rate&#39;</span><span class="p">,</span>
        <span class="c1"># kwargs passed during __init__</span>
        <span class="s1">&#39;skip_on_gaps&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ppsd_length&#39;</span><span class="p">,</span>
        <span class="s1">&#39;overlap&#39;</span><span class="p">,</span>
        <span class="s1">&#39;special_handling&#39;</span><span class="p">,</span>
        <span class="c1"># attributes derived during __init__</span>
        <span class="s1">&#39;_len&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_nlap&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_nfft&#39;</span><span class="p">]</span>
    <span class="n">NPZ_STORE_KEYS_ARRAY_TYPES</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># attributes derived during __init__</span>
        <span class="s1">&#39;_db_bin_edges&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_psd_periods&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_period_binning&#39;</span><span class="p">]</span>
    <span class="n">NPZ_STORE_KEYS</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">NPZ_STORE_KEYS_ARRAY_TYPES</span> <span class="o">+</span>
        <span class="n">NPZ_STORE_KEYS_LIST_TYPES</span> <span class="o">+</span>
        <span class="n">NPZ_STORE_KEYS_SIMPLE_TYPES</span> <span class="o">+</span>
        <span class="n">NPZ_STORE_KEYS_VERSION_NUMBERS</span><span class="p">)</span>

<div class="viewcode-block" id="PPSD.__init__"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.__init__.html#obspy.signal.spectral_estimation.PPSD.__init__">[docs]</a>    <span class="nd">@deprecated_keywords</span><span class="p">({</span><span class="s1">&#39;paz&#39;</span><span class="p">:</span> <span class="s1">&#39;metadata&#39;</span><span class="p">,</span> <span class="s1">&#39;parser&#39;</span><span class="p">:</span> <span class="s1">&#39;metadata&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;water_level&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">skip_on_gaps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">db_bins</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="n">ppsd_length</span><span class="o">=</span><span class="mf">3600.0</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">special_handling</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">period_smoothing_width_octaves</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">period_step_octaves</span><span class="o">=</span><span class="mf">0.125</span><span class="p">,</span> <span class="n">period_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the PPSD object setting all fixed information on the station</span>
<span class="sd">        that should not change afterwards to guarantee consistent spectral</span>
<span class="sd">        estimates.</span>
<span class="sd">        The necessary instrument response information can be provided in</span>
<span class="sd">        several ways using the `metadata` keyword argument:</span>

<span class="sd">        * Providing an :class:`~obspy.core.inventory.inventory.Inventory`</span>
<span class="sd">          object (e.g. read from a StationXML file using</span>
<span class="sd">          :func:`~obspy.core.inventory.inventory.read_inventory` or fetched</span>
<span class="sd">          from a :mod:`FDSN &lt;obspy.clients.fdsn&gt;` webservice).</span>
<span class="sd">        * Providing an</span>
<span class="sd">          :class:`obspy.io.xseed Parser &lt;obspy.io.xseed.parser.Parser&gt;`,</span>
<span class="sd">          (e.g. containing metadata from a Dataless SEED file).</span>
<span class="sd">        * Providing the filename/path to a local RESP file.</span>
<span class="sd">        * Providing a dictionary containing poles and zeros information. Be</span>
<span class="sd">          aware that this leads to wrong results if the instrument&#39;s response</span>
<span class="sd">          is changing over the timespans that are added to the PPSD.</span>
<span class="sd">          Use with caution!</span>

<span class="sd">        :note: When using `special_handling=&quot;ringlaser&quot;` the applied processing</span>
<span class="sd">               steps are changed. Differentiation of data (converting velocity</span>
<span class="sd">               to acceleration data) will be omitted and a flat instrument</span>
<span class="sd">               response is assumed, leaving away response removal and only</span>
<span class="sd">               dividing by `metadata[&#39;sensitivity&#39;]` specified in the provided</span>
<span class="sd">               `metadata` dictionary (other keys do not have to be present</span>
<span class="sd">               then). For scaling factors that are usually multiplied to the</span>
<span class="sd">               data remember to use the inverse as `metadata[&#39;sensitivity&#39;]`.</span>

<span class="sd">        :type stats: :class:`~obspy.core.trace.Stats`</span>
<span class="sd">        :param stats: Stats of the station/instrument to process</span>
<span class="sd">        :type metadata: :class:`~obspy.core.inventory.inventory.Inventory` or</span>
<span class="sd">            :class:`~obspy.io.xseed Parser` or str or dict</span>
<span class="sd">        :param metadata: Response information of instrument. See above notes</span>
<span class="sd">            for details.</span>
<span class="sd">        :type skip_on_gaps: bool, optional</span>
<span class="sd">        :param skip_on_gaps: Determines whether time segments with gaps should</span>
<span class="sd">                be skipped entirely. [McNamara2004]_ merge gappy</span>
<span class="sd">                traces by filling with zeros. This results in a clearly</span>
<span class="sd">                identifiable outlier psd line in the PPSD visualization. Select</span>
<span class="sd">                `skip_on_gaps=True` for not filling gaps with zeros which might</span>
<span class="sd">                result in some data segments shorter than `ppsd_length` not</span>
<span class="sd">                used in the PPSD.</span>
<span class="sd">        :type db_bins: tuple of three ints/floats</span>
<span class="sd">        :param db_bins: Specify the lower and upper boundary and the width of</span>
<span class="sd">                the db bins. The bin width might get adjusted to fit  a number</span>
<span class="sd">                of equally spaced bins in between the given boundaries.</span>
<span class="sd">        :type ppsd_length: float, optional</span>
<span class="sd">        :param ppsd_length: Length of data segments passed to psd in seconds.</span>
<span class="sd">                In the paper by [McNamara2004]_ a value of 3600 (1 hour) was</span>
<span class="sd">                chosen. Longer segments increase the upper limit of analyzed</span>
<span class="sd">                periods but decrease the number of analyzed segments.</span>
<span class="sd">        :type overlap: float, optional</span>
<span class="sd">        :param overlap: Overlap of segments passed to psd. Overlap may take</span>
<span class="sd">                values between 0 and 1 and is given as fraction of the length</span>
<span class="sd">                of one segment, e.g. `ppsd_length=3600` and `overlap=0.5`</span>
<span class="sd">                result in an overlap of 1800s of the segments.</span>
<span class="sd">        :type special_handling: str, optional</span>
<span class="sd">        :param special_handling: Switches on customized handling for</span>
<span class="sd">            data other than seismometer recordings. Can be one of: &#39;ringlaser&#39;</span>
<span class="sd">            (no instrument correction, just division by</span>
<span class="sd">            `metadata[&quot;sensitivity&quot;]` of provided metadata dictionary),</span>
<span class="sd">            &#39;hydrophone&#39; (no differentiation after instrument correction).</span>
<span class="sd">        :type period_smoothing_width_octaves: float</span>
<span class="sd">        :param period_smoothing_width_octaves: Determines over what</span>
<span class="sd">            period/frequency range the psd is smoothed around every central</span>
<span class="sd">            period/frequency. Given in fractions of octaves (default of ``1``</span>
<span class="sd">            means the psd is averaged over a full octave at each central</span>
<span class="sd">            frequency).</span>
<span class="sd">        :type period_step_octaves: float</span>
<span class="sd">        :param period_step_octaves: Step length on frequency axis in fraction</span>
<span class="sd">            of octaves (default of ``0.125`` means one smoothed psd value on</span>
<span class="sd">            the frequency axis is measured every 1/8 of an octave).</span>
<span class="sd">        :type period_limits: tuple/list of two float</span>
<span class="sd">        :param period_limits: Set custom lower and upper end of period range</span>
<span class="sd">            (e.g. ``(0.01, 100)``). The specified lower end of period range</span>
<span class="sd">            will be set as the central period of the first bin (geometric mean</span>
<span class="sd">            of left/right edges of smoothing interval). At the upper end of the</span>
<span class="sd">            specified period range, no more additional bins will be added after</span>
<span class="sd">            the bin whose center frequency exceeds the given upper end for the</span>
<span class="sd">            first time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># remove after release of 0.11.0</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;is_rotational_data&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Keyword &#39;is_rotational_data&#39; is deprecated. Please use &quot;</span>
                   <span class="s2">&quot;&#39;special_handling=</span><span class="se">\&quot;</span><span class="s2">ringlaser</span><span class="se">\&quot;</span><span class="s2">&#39; instead.&quot;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ObsPyDeprecationWarning</span><span class="p">)</span>
            <span class="n">special_handling</span> <span class="o">=</span> <span class="s2">&quot;ringlaser&quot;</span>

        <span class="c1"># save things related to args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%(network)s</span><span class="s2">.</span><span class="si">%(station)s</span><span class="s2">.</span><span class="si">%(location)s</span><span class="s2">.</span><span class="si">%(channel)s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">stats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>

        <span class="c1"># save things related to kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_on_gaps</span> <span class="o">=</span> <span class="n">skip_on_gaps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_bins</span> <span class="o">=</span> <span class="n">db_bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppsd_length</span> <span class="o">=</span> <span class="n">ppsd_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_handling</span> <span class="o">=</span> <span class="n">special_handling</span> <span class="ow">and</span> <span class="n">special_handling</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_handling</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;ringlaser&quot;</span><span class="p">,</span> <span class="s2">&quot;hydrophone&quot;</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unsupported value for &#39;special_handling&#39; parameter: </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_handling</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># save version numbers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppsd_version</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obspy_version</span> <span class="o">=</span> <span class="n">__version__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matplotlib_version</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">MATPLOTLIB_VERSION</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numpy_version</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">__version__</span>

        <span class="c1"># calculate derived attributes</span>
        <span class="c1"># nfft is determined mimicking the fft setup in McNamara&amp;Buland</span>
        <span class="c1"># paper:</span>
        <span class="c1"># (they take 13 segments overlapping 75% and truncate to next lower</span>
        <span class="c1">#  power of 2)</span>
        <span class="c1">#  - take number of points of whole ppsd segment (default 1 hour)</span>
        <span class="n">nfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppsd_length</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="c1">#  - make 13 single segments overlapping by 75%</span>
        <span class="c1">#    (1 full segment length + 25% * 12 full segment lengths)</span>
        <span class="n">nfft</span> <span class="o">=</span> <span class="n">nfft</span> <span class="o">/</span> <span class="mf">4.0</span>
        <span class="c1">#  - go to next smaller power of 2 for nfft</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nfft</span> <span class="o">=</span> <span class="n">prev_pow_2</span><span class="p">(</span><span class="n">nfft</span><span class="p">)</span>
        <span class="c1">#  - use 75% overlap</span>
        <span class="c1">#    (we end up with a little more than 13 segments..)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.75</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfft</span><span class="p">)</span>
        <span class="c1"># Trace length for one psd segment.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppsd_length</span><span class="p">)</span>
        <span class="c1"># make an initial dummy psd and to get the array of periods</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfft</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nlap</span><span class="p">)</span>
        <span class="c1"># leave out first entry (offset)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psd_periods</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">freq</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">period_limits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">period_limits</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psd_periods</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_periods</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_period_binning</span><span class="p">(</span>
            <span class="n">period_smoothing_width_octaves</span><span class="p">,</span> <span class="n">period_step_octaves</span><span class="p">,</span> <span class="n">period_limits</span><span class="p">)</span>
        <span class="c1"># setup db binning</span>
        <span class="c1"># Set up the binning for the db scale.</span>
        <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">db_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">db_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">db_bins</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_db_bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">db_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">db_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                         <span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># lists related to persistent processed data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times_gaps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binned_psds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># internal attributes for stacks on processed data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack_cumulative</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_used</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_all_details</span> <span class="o">=</span> <span class="p">[]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">station</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">location</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">channel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trace length for one psd segment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nfft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nfft</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nlap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nlap</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">merge_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_on_gaps</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;PPSD attribute &#39;spec_bins&#39; is deprecated, please use &quot;</span>
                <span class="s2">&quot;&#39;db_bin_edges&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">spec_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_bin_edges</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">db_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_db_bin_edges</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">db_bin_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">psd_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_periods</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">psd_periods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psd_periods</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;PPSD attribute &#39;per&#39; is deprecated, please use &quot;</span>
                <span class="s2">&quot;&#39;psd_periods&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">per</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_periods</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;PPSD attribute &#39;freq&#39; is deprecated, please use &quot;</span>
                <span class="s2">&quot;&#39;psd_frequencies&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_frequencies</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;PPSD attribute &#39;per_octaves_left&#39; is deprecated, please use &quot;</span>
                <span class="s2">&quot;&#39;period_bin_left_edges&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">per_octaves_left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">period_bin_left_edges</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;PPSD attribute &#39;per_octaves_right&#39; is deprecated, please use &quot;</span>
                <span class="s2">&quot;&#39;period_bin_right_edges&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">per_octaves_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">period_bin_right_edges</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;PPSD attribute &#39;per_octaves&#39; is deprecated, please use &quot;</span>
                <span class="s2">&quot;&#39;period_bin_centers&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">per_octaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">period_bin_centers</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;PPSD attribute &#39;period_bins&#39; is deprecated, please use &quot;</span>
                <span class="s2">&quot;&#39;period_bin_centers&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">period_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">period_bin_centers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">period_bin_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return centers of period bins (geometric mean of left and right edge of</span>
<span class="sd">        period smoothing ranges).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_period_binning</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">period_xedges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns edges of period histogram bins (one element longer than number</span>
<span class="sd">        of bins). These are the edges of the plotted histogram/pcolormesh, but</span>
<span class="sd">        not the edges used for smoothing along the period axis of the psd</span>
<span class="sd">        (before binning).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_period_binning</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_period_binning</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">period_bin_left_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns left edges of period bins (same length as number of bins).</span>
<span class="sd">        These are the edges used for smoothing along the period axis of the psd</span>
<span class="sd">        (before binning), not the edges of the histogram/pcolormesh in the</span>
<span class="sd">        plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_period_binning</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">period_bin_right_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns right edges of period bins (same length as number of bins).</span>
<span class="sd">        These are the edges used for smoothing along the period axis of the psd</span>
<span class="sd">        (before binning), not the edges of the histogram/pcolormesh in the</span>
<span class="sd">        plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_period_binning</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;PPSD attribute &#39;times&#39; is deprecated, please use &quot;</span>
                <span class="s2">&quot;&#39;times_processed&#39;, &#39;times_data&#39; and &#39;times_gaps&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">UTCDateTime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">times_processed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">UTCDateTime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;PPSD attribute &#39;times_used&#39; is deprecated, please use &quot;</span>
                <span class="s2">&quot;&#39;current_times_used&#39; or &#39;times_processed&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">times_used</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_times_used</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">times_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t1</span><span class="p">),</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t2</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_data</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">times_gaps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t1</span><span class="p">),</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t2</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_gaps</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_histogram</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_histogram_cumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_histogram</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack_cumulative</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_histogram_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_histogram</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_times_used</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_times_used</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_histogram</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">UTCDateTime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_used</span><span class="p">))</span>

<div class="viewcode-block" id="PPSD._setup_period_binning"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._setup_period_binning.html#obspy.signal.spectral_estimation.PPSD._setup_period_binning">[docs]</a>    <span class="k">def</span> <span class="nf">_setup_period_binning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">period_smoothing_width_octaves</span><span class="p">,</span>
                              <span class="n">period_step_octaves</span><span class="p">,</span> <span class="n">period_limits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up period binning.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we step through the period range at step width controlled by</span>
        <span class="c1"># period_step_octaves (default 1/8 octave)</span>
        <span class="n">period_step_factor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">period_step_octaves</span>
        <span class="c1"># the width of frequencies we average over for every bin is controlled</span>
        <span class="c1"># by period_smoothing_width_octaves (default one full octave)</span>
        <span class="n">period_smoothing_width_factor</span> <span class="o">=</span> \
            <span class="mi">2</span> <span class="o">**</span> <span class="n">period_smoothing_width_octaves</span>
        <span class="c1"># calculate left/right edge and center of first period bin</span>
        <span class="c1"># set first smoothing bin&#39;s left edge such that the center frequency is</span>
        <span class="c1"># the lower limit specified by the user (or the lowest period in the</span>
        <span class="c1"># psd)</span>
        <span class="n">per_left</span> <span class="o">=</span> <span class="p">(</span><span class="n">period_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span>
                    <span class="p">(</span><span class="n">period_smoothing_width_factor</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="n">per_right</span> <span class="o">=</span> <span class="n">per_left</span> <span class="o">*</span> <span class="n">period_smoothing_width_factor</span>
        <span class="n">per_center</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">per_left</span> <span class="o">*</span> <span class="n">per_right</span><span class="p">)</span>
        <span class="c1"># build up lists</span>
        <span class="n">per_octaves_left</span> <span class="o">=</span> <span class="p">[</span><span class="n">per_left</span><span class="p">]</span>
        <span class="n">per_octaves_right</span> <span class="o">=</span> <span class="p">[</span><span class="n">per_right</span><span class="p">]</span>
        <span class="n">per_octaves_center</span> <span class="o">=</span> <span class="p">[</span><span class="n">per_center</span><span class="p">]</span>
        <span class="c1"># do this for the whole period range and append the values to our lists</span>
        <span class="k">while</span> <span class="n">per_center</span> <span class="o">&lt;</span> <span class="n">period_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># move left edge of smoothing bin further</span>
            <span class="n">per_left</span> <span class="o">*=</span> <span class="n">period_step_factor</span>
            <span class="c1"># determine right edge of smoothing bin</span>
            <span class="n">per_right</span> <span class="o">=</span> <span class="n">per_left</span> <span class="o">*</span> <span class="n">period_smoothing_width_factor</span>
            <span class="c1"># determine center period of smoothing/binning</span>
            <span class="n">per_center</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">per_left</span> <span class="o">*</span> <span class="n">per_right</span><span class="p">)</span>
            <span class="c1"># append to lists</span>
            <span class="n">per_octaves_left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">per_left</span><span class="p">)</span>
            <span class="n">per_octaves_right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">per_right</span><span class="p">)</span>
            <span class="n">per_octaves_center</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">per_center</span><span class="p">)</span>
        <span class="n">per_octaves_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">per_octaves_left</span><span class="p">)</span>
        <span class="n">per_octaves_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">per_octaves_right</span><span class="p">)</span>
        <span class="n">per_octaves_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">per_octaves_center</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">per_octaves_right</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_periods</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">valid</span> <span class="o">&amp;=</span> <span class="n">per_octaves_left</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_periods</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">per_octaves_left</span> <span class="o">=</span> <span class="n">per_octaves_left</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">per_octaves_right</span> <span class="o">=</span> <span class="n">per_octaves_right</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="n">per_octaves_center</span> <span class="o">=</span> <span class="n">per_octaves_center</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_period_binning</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
            <span class="c1"># left edge of smoothing (for calculating the bin value from psd</span>
            <span class="n">per_octaves_left</span><span class="p">,</span>
            <span class="c1"># left xedge of bin (for plotting)</span>
            <span class="n">per_octaves_center</span> <span class="o">/</span> <span class="p">(</span><span class="n">period_step_factor</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">),</span>
            <span class="c1"># bin center (for plotting)</span>
            <span class="n">per_octaves_center</span><span class="p">,</span>
            <span class="c1"># right xedge of bin (for plotting)</span>
            <span class="n">per_octaves_center</span> <span class="o">*</span> <span class="p">(</span><span class="n">period_step_factor</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">),</span>
            <span class="c1"># right edge of smoothing (for calculating the bin value from psd</span>
            <span class="n">per_octaves_right</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">__sanity_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if trace is compatible for use in the current PPSD instance.</span>
<span class="sd">        Returns True if trace can be used or False if not.</span>

<span class="sd">        :type trace: :class:`~obspy.core.trace.Trace`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__insert_processed_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">utcdatetime</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts the given UTCDateTime and processed/octave-binned spectrum at</span>
<span class="sd">        the right position in the lists, keeping the order intact.</span>

<span class="sd">        Replaces old :meth:`PPSD.__insert_used_time()` private method and the</span>
<span class="sd">        addition ot the histogram stack that was performed directly in</span>
<span class="sd">        :meth:`PPSD.__process()`.</span>

<span class="sd">        :type utcdatetime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :type spectrum: :class:`numpy.ndarray`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">,</span> <span class="n">utcdatetime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">utcdatetime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binned_psds</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__insert_gap_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets gap information of stream and adds the encountered gaps to the gap</span>
<span class="sd">        list of the PPSD instance.</span>

<span class="sd">        :type stream: :class:`~obspy.core.stream.Stream`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times_gaps</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">gap</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">gap</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">gap</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">get_gaps</span><span class="p">()]</span>

    <span class="k">def</span> <span class="nf">__insert_data_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets gap information of stream and adds the encountered gaps to the gap</span>
<span class="sd">        list of the PPSD instance.</span>

<span class="sd">        :type stream: :class:`~obspy.core.stream.Stream`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times_data</span> <span class="o">+=</span> \
            <span class="p">[[</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">]</span>
             <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__check_time_present</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">utcdatetime</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the given UTCDateTime is already part of the current PPSD</span>
<span class="sd">        instance. That is, checks if from utcdatetime to utcdatetime plus</span>
<span class="sd">        ppsd_length there is already data in the PPSD.</span>
<span class="sd">        Returns True if adding ppsd_length starting at the given time</span>
<span class="sd">        would result in an overlap of the ppsd data base, False if it is OK to</span>
<span class="sd">        insert this piece of data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index1</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">,</span>
                                    <span class="n">utcdatetime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="n">index2</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">,</span>
                                     <span class="n">utcdatetime</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppsd_length</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index1</span> <span class="o">!=</span> <span class="n">index2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__check_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># check if any data has been added yet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_histogram</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;No data accumulated&#39;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__invalidate_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack_cumulative</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_used</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_all_details</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="PPSD.add"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.add.html#obspy.signal.spectral_estimation.PPSD.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process all traces with compatible information and add their spectral</span>
<span class="sd">        estimates to the histogram containing the probabilistic psd.</span>
<span class="sd">        Also ensures that no piece of data is inserted twice.</span>

<span class="sd">        :type stream: :class:`~obspy.core.stream.Stream` or</span>
<span class="sd">                :class:`~obspy.core.trace.Trace`</span>
<span class="sd">        :param stream: Stream or trace with data that should be added to the</span>
<span class="sd">                probabilistic psd histogram.</span>
<span class="sd">        :returns: True if appropriate data were found and the ppsd statistics</span>
<span class="sd">                were changed, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;PPSD instance has no metadata attached, which are needed &quot;</span>
                   <span class="s2">&quot;for processing the data. When using &#39;PPSD.load_npz()&#39; use &quot;</span>
                   <span class="s2">&quot;&#39;metadata&#39; kwarg to provide metadata.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># return later if any changes were applied to the ppsd statistics</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># prepare the list of traces to go through</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">([</span><span class="n">stream</span><span class="p">])</span>
        <span class="c1"># select appropriate traces</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                               <span class="n">sampling_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">)</span>
        <span class="c1"># save information on available data and gaps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__insert_data_times</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__insert_gap_times</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="c1"># merge depending on skip_on_gaps set during __init__</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merge_method</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
            <span class="c1"># the following check should not be necessary due to the select()..</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sanity_check</span><span class="p">(</span><span class="n">tr</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Skipping incompatible trace.&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span>
            <span class="k">while</span> <span class="n">t1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppsd_length</span> <span class="o">&lt;=</span> <span class="n">t2</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_time_present</span><span class="p">(</span><span class="n">t1</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Already covered time spans detected (e.g. </span><span class="si">%s</span><span class="s2">), &quot;</span> <span class="o">+</span> \
                          <span class="s2">&quot;skipping these slices.&quot;</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">%</span> <span class="n">t1</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># throw warnings if trace length is different</span>
                    <span class="c1"># than ppsd_length..!?!</span>
                    <span class="nb">slice</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppsd_length</span><span class="p">)</span>
                    <span class="c1"># XXX not good, should be working in place somehow</span>
                    <span class="c1"># XXX how to do it with the padding, though?</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__process</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">t1</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppsd_length</span>  <span class="c1"># advance</span>

            <span class="c1"># enforce time limits, pad zeros if gaps</span>
            <span class="c1"># tr.trim(t, t+PPSD_LENGTH, pad=True)</span>
        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__invalidate_histogram</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">changed</span></div>

    <span class="k">def</span> <span class="nf">__process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Processes a segment of data and save the psd information.</span>
<span class="sd">        Whether `Trace` is compatible (station, channel, ...) has to</span>
<span class="sd">        checked beforehand.</span>

<span class="sd">        :type tr: :class:`~obspy.core.trace.Trace`</span>
<span class="sd">        :param tr: Compatible Trace with data of one PPSD segment</span>
<span class="sd">        :returns: `True` if segment was successfully processed,</span>
<span class="sd">            `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX DIRTY HACK!!</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># one last check..</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Got a piece of data with wrong length. Skipping&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># being paranoid, only necessary if in-place operations would follow</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># if trace has a masked array we fill in zeros</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># if it is no masked array, we get an AttributeError</span>
        <span class="c1"># and have nothing to do</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># restitution:</span>
        <span class="c1"># mcnamara apply the correction at the end in freq-domain,</span>
        <span class="c1"># does it make a difference?</span>
        <span class="c1"># probably should be done earlier on bigger chunk of data?!</span>
        <span class="c1"># Yes, you should avoid removing the response until after you</span>
        <span class="c1"># have estimated the spectra to avoid elevated lp noise</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">_freq</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfft</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                               <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_linear</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">fft_taper</span><span class="p">,</span>
                               <span class="n">noverlap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nlap</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="s1">&#39;onesided&#39;</span><span class="p">,</span>
                               <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># leave out first entry (offset)</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># working with the periods not frequencies later so reverse spectrum</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Here we remove the response using the same conventions</span>
        <span class="c1"># since the power is squared we want to square the sensitivity</span>
        <span class="c1"># we can also convert to acceleration if we have non-rotational data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_handling</span> <span class="o">==</span> <span class="s2">&quot;ringlaser&quot;</span><span class="p">:</span>
            <span class="c1"># in case of rotational data just remove sensitivity</span>
            <span class="n">spec</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sensitivity&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># special_handling &quot;hydrophone&quot; does instrument correction same as</span>
        <span class="c1"># &quot;normal&quot; data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># determine instrument response from metadata</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_response</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Error getting response from provided metadata:</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Skipping time segment(s).&quot;</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">resp</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">resp</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Now get the amplitude response (squared)</span>
            <span class="n">respamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">resp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">resp</span><span class="p">))</span>
            <span class="c1"># Make omega with the same conventions as spec</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">_freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Here we do the response removal</span>
            <span class="c1"># Do not differentiate when `special_handling=&quot;hydrophone&quot;`</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_handling</span> <span class="o">==</span> <span class="s2">&quot;hydrophone&quot;</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span> <span class="o">/</span> <span class="n">respamp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">spec</span> <span class="o">/</span> <span class="n">respamp</span>
        <span class="c1"># avoid calculating log of zero</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">spec</span> <span class="o">&lt;</span> <span class="n">dtiny</span>
        <span class="n">spec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtiny</span>

        <span class="c1"># go to dB</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">spec</span> <span class="o">*=</span> <span class="mi">10</span>

        <span class="n">smoothed_psd</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># do this for the whole period range and append the values to our lists</span>
        <span class="k">for</span> <span class="n">per_left</span><span class="p">,</span> <span class="n">per_right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">period_bin_left_edges</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">period_bin_right_edges</span><span class="p">):</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[(</span><span class="n">per_left</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_periods</span><span class="p">)</span> <span class="o">&amp;</span>
                         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psd_periods</span> <span class="o">&lt;=</span> <span class="n">per_right</span><span class="p">)]</span>
            <span class="n">smoothed_psd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">specs</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        <span class="n">smoothed_psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">smoothed_psd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__insert_processed_data</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span> <span class="n">smoothed_psd</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;PPSD attribute &#39;hist_stack&#39; is deprecated, please use new &quot;</span>
                <span class="s2">&quot;&#39;calculate_histogram()&#39; method with improved functionality &quot;</span>
                <span class="s2">&quot;instead to compute a histogram stack dynamically and then &quot;</span>
                <span class="s2">&quot;&#39;current_histogram&#39; attribute to access the current &quot;</span>
                <span class="s2">&quot;histogram stack.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hist_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_histogram</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_histogram</span>

<div class="viewcode-block" id="PPSD._get_times_all_details"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._get_times_all_details.html#obspy.signal.spectral_estimation.PPSD._get_times_all_details">[docs]</a>    <span class="k">def</span> <span class="nf">_get_times_all_details</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># check if we can reuse a previously cached array of all times as</span>
        <span class="c1"># day of week as int and time of day in float hours</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_times_all_details</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_all_details</span>
        <span class="c1"># otherwise compute it and store it for subsequent stacks on the</span>
        <span class="c1"># same data (has to be recomputed when additional data gets added)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;time_of_day&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                              <span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;iso_weekday&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
                              <span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;iso_week&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
                              <span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;year&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span>
                              <span class="p">(</span><span class="n">native_str</span><span class="p">(</span><span class="s1">&#39;month&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)])</span>
            <span class="n">times_all_details</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">),</span>
                                         <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">utc_times_all</span> <span class="o">=</span> <span class="p">[</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">]</span>
            <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;time_of_day&#39;</span><span class="p">][:]</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">_get_hours_after_midnight</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">utc_times_all</span><span class="p">]</span>
            <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;iso_weekday&#39;</span><span class="p">][:]</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">isoweekday</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">utc_times_all</span><span class="p">]</span>
            <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;iso_week&#39;</span><span class="p">][:]</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">isocalendar</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">utc_times_all</span><span class="p">]</span>
            <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">][:]</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">year</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">utc_times_all</span><span class="p">]</span>
            <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;month&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">month</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">utc_times_all</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_all_details</span> <span class="o">=</span> <span class="n">times_all_details</span>
            <span class="k">return</span> <span class="n">times_all_details</span></div>

<div class="viewcode-block" id="PPSD._stack_selection"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._stack_selection.html#obspy.signal.spectral_estimation.PPSD._stack_selection">[docs]</a>    <span class="k">def</span> <span class="nf">_stack_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">time_of_weekday</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">isoweek</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For details on restrictions see :meth:`calculate_histogram`.</span>

<span class="sd">        :rtype: :class:`numpy.ndarray` of bool</span>
<span class="sd">        :returns: Boolean array of which psd pieces should be included in the</span>
<span class="sd">            stack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">)</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times_all</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">starttime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">&amp;=</span> <span class="n">times_all</span> <span class="o">&gt;</span> <span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="k">if</span> <span class="n">endtime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">&amp;=</span> <span class="n">times_all</span> <span class="o">&lt;</span> <span class="n">endtime</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="k">if</span> <span class="n">time_of_weekday</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">times_all_details</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_times_all_details</span><span class="p">()</span>
            <span class="c1"># we need to do a logical OR over all different user specified time</span>
            <span class="c1"># windows, so we start with an array of False and set all matching</span>
            <span class="c1"># pieces True for the final logical AND against the previous</span>
            <span class="c1"># restrictions</span>
            <span class="n">selected_time_of_weekday</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times_all</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">weekday</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">time_of_weekday</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weekday</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">selected_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times_all</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">selected_</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;iso_weekday&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">weekday</span><span class="p">)</span>
                <span class="n">selected_</span> <span class="o">&amp;=</span> <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;time_of_day&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">start</span>
                <span class="n">selected_</span> <span class="o">&amp;=</span> <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;time_of_day&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">end</span>
                <span class="n">selected_time_of_weekday</span> <span class="o">|=</span> <span class="n">selected_</span>
            <span class="n">selected</span> <span class="o">&amp;=</span> <span class="n">selected_time_of_weekday</span>
        <span class="k">if</span> <span class="n">year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">year</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">year</span> <span class="o">=</span> <span class="p">[</span><span class="n">year</span><span class="p">]</span>
            <span class="n">times_all_details</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_times_all_details</span><span class="p">()</span>
            <span class="n">selected_</span> <span class="o">=</span> <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">year</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">year_</span> <span class="ow">in</span> <span class="n">year</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">selected_</span> <span class="o">|=</span> <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">year_</span>
            <span class="n">selected</span> <span class="o">&amp;=</span> <span class="n">selected_</span>
        <span class="k">if</span> <span class="n">month</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">month</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">month</span> <span class="o">=</span> <span class="p">[</span><span class="n">month</span><span class="p">]</span>
            <span class="n">times_all_details</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_times_all_details</span><span class="p">()</span>
            <span class="n">selected_</span> <span class="o">=</span> <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;month&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">month</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">month_</span> <span class="ow">in</span> <span class="n">month</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">selected_</span> <span class="o">|=</span> <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;month&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">month_</span>
            <span class="n">selected</span> <span class="o">&amp;=</span> <span class="n">selected_</span>
        <span class="k">if</span> <span class="n">isoweek</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">times_all_details</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_times_all_details</span><span class="p">()</span>
            <span class="n">selected_</span> <span class="o">=</span> <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;iso_week&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">isoweek</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">isoweek_</span> <span class="ow">in</span> <span class="n">isoweek</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">selected_</span> <span class="o">|=</span> <span class="n">times_all_details</span><span class="p">[</span><span class="s1">&#39;iso_week&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">isoweek_</span>
            <span class="n">selected</span> <span class="o">&amp;=</span> <span class="n">selected_</span>
        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">&amp;=</span> <span class="n">callback</span><span class="p">(</span><span class="n">times_all</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">selected</span></div>

<div class="viewcode-block" id="PPSD.calculate_histogram"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.calculate_histogram.html#obspy.signal.spectral_estimation.PPSD.calculate_histogram">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">time_of_weekday</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">isoweek</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and set current 2D histogram stack, optionally with start-</span>
<span class="sd">        and endtime and time of day restrictions.</span>

<span class="sd">        .. note::</span>
<span class="sd">            All restrictions to the stack are evaluated as a logical AND, i.e.</span>
<span class="sd">            only individual psd pieces are included in the stack that match</span>
<span class="sd">            *all* of the specified restrictions (e.g. `isoweek=40, month=2` can</span>
<span class="sd">            never match any data).</span>

<span class="sd">        .. note::</span>
<span class="sd">            All time restrictions are specified in UTC, so actual time in local</span>
<span class="sd">            time zone might not be the same across start/end date of daylight</span>
<span class="sd">            saving time periods.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Time restrictions only check the starttime of the individual psd</span>
<span class="sd">            pieces.</span>

<span class="sd">        :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param starttime: If set, data before the specified time is excluded</span>
<span class="sd">            from the returned stack.</span>
<span class="sd">        :type endtime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param endtime: If set, data after the specified time is excluded</span>
<span class="sd">            from the returned stack.</span>
<span class="sd">        :type time_of_weekday: list of (int, float, float) 3-tuples</span>
<span class="sd">        :param time_of_weekday: If set, restricts the data that is included</span>
<span class="sd">            in the stack by time of day and weekday. Monday is `1`, Sunday is</span>
<span class="sd">            `7`, `-1` for any day of week. For example, using</span>
<span class="sd">            `time_of_weekday=[(-1, 0, 2), (-1, 22, 24)]` only individual</span>
<span class="sd">            spectra that have a starttime in between 10pm and 2am are used in</span>
<span class="sd">            the stack for all days of week, using</span>
<span class="sd">            `time_of_weekday=[(5, 22, 24), (6, 0, 2), (6, 22, 24), (7, 0, 2)]`</span>
<span class="sd">            only spectra with a starttime in between Friday 10pm to Saturdays</span>
<span class="sd">            2am and Saturday 10pm to Sunday 2am are used.</span>
<span class="sd">            Note that time of day is specified in UTC (time of day might have</span>
<span class="sd">            to be adapted to daylight saving time). Also note that this setting</span>
<span class="sd">            filters only by starttime of the used psd time slice, so the length</span>
<span class="sd">            of individual slices (set at initialization:</span>
<span class="sd">            :meth:`PPSD(..., ppsd_length=XXX, ...) &lt;PPSD.__init__&gt;` in seconds)</span>
<span class="sd">            has to be taken into consideration (e.g. with a `ppsd_length` of</span>
<span class="sd">            one hour and a `time_of_weekday` restriction to 10pm-2am</span>
<span class="sd">            actually includes data from 10pm-3am).</span>
<span class="sd">        :type year: list of int</span>
<span class="sd">        :param year: If set, restricts the data that is included in the stack</span>
<span class="sd">            by year. For example, using `year=[2015]` only individual spectra</span>
<span class="sd">            from year 2015 are used in the stack, using `year=[2013, 2015]`</span>
<span class="sd">            only spectra from exactly year 2013 or exactly year 2015 are used.</span>
<span class="sd">        :type month: list of int</span>
<span class="sd">        :param month: If set, restricts the data that is included in the stack</span>
<span class="sd">            by month of year. For example, using `month=[2]` only individual</span>
<span class="sd">            spectra from February are used in the stack, using `month=[4, 7]`</span>
<span class="sd">            only spectra from exactly April or exactly July are used.</span>
<span class="sd">        :type isoweek: list of int</span>
<span class="sd">        :param isoweek: If set, restricts the data that is included in the</span>
<span class="sd">            stack by ISO week number of year. For example, using `isoweek=[2]`</span>
<span class="sd">            only individual spectra from 2nd ISO week of any year are used in</span>
<span class="sd">            the stack, using `isoweek=[4, 7]` only spectra from exactly 4th ISO</span>
<span class="sd">            week or exactly 7th ISO week are used.</span>
<span class="sd">        :type callback: func</span>
<span class="sd">        :param callback: Custom user defined callback function that can be used</span>
<span class="sd">            for more complex scenarios to specify whether an individual psd</span>
<span class="sd">            piece should be included in the stack or not. The function will be</span>
<span class="sd">            passed an array with the starttimes of all psd pieces (as a POSIX</span>
<span class="sd">            timestamp that can be used as a single argument to initialize a</span>
<span class="sd">            :class:`~obspy.core.utcdatetime.UTCDateTime` object) and</span>
<span class="sd">            should return a boolean array specifying which psd pieces should be</span>
<span class="sd">            included in the stack (`True`) and which should be excluded</span>
<span class="sd">            (`False`). Note that even when callback returns `True` the psd</span>
<span class="sd">            piece will be excluded if it does not match all other criteria</span>
<span class="sd">            (e.g. `starttime`).</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># no data at all</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack_cumulative</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_used</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span>

        <span class="c1"># determine which psd pieces should be used in the stack,</span>
        <span class="c1"># based on all selection criteria specified by user</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stack_selection</span><span class="p">(</span>
            <span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span>
            <span class="n">time_of_weekday</span><span class="o">=</span><span class="n">time_of_weekday</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="n">month</span><span class="p">,</span>
            <span class="n">isoweek</span><span class="o">=</span><span class="n">isoweek</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>
        <span class="n">used_indices</span> <span class="o">=</span> <span class="n">selected</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">used_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">used_indices</span><span class="p">)</span>
        <span class="n">used_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">)[</span><span class="n">used_indices</span><span class="p">]</span>

        <span class="n">num_period_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">period_bin_centers</span><span class="p">)</span>
        <span class="n">num_db_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_bin_centers</span><span class="p">)</span>

        <span class="c1"># initial setup of 2D histogram</span>
        <span class="n">hist_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_period_bins</span><span class="p">,</span> <span class="n">num_db_bins</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>

        <span class="c1"># empty selection, set all histogram stacks to zeros</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">used_count</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack</span> <span class="o">=</span> <span class="n">hist_stack</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack_cumulative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                <span class="n">hist_stack</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_used</span> <span class="o">=</span> <span class="n">used_times</span>
            <span class="k">return</span>

        <span class="c1"># concatenate all used spectra, evaluate index of amplitude bin each</span>
        <span class="c1"># value belongs to</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_binned_psds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">used_indices</span><span class="p">])</span>
        <span class="c1"># for &quot;inds&quot; now a number of ..</span>
        <span class="c1">#   - 0 means below lowest bin (bin index 0)</span>
        <span class="c1">#   - 1 means, hit lowest bin (bin index 0)</span>
        <span class="c1">#   - ..</span>
        <span class="c1">#   - len(self.db_bin_edges) means above top bin</span>
        <span class="c1"># we need minus one because searchsorted returns the insertion index in</span>
        <span class="c1"># the array of bin edges which is the index of the corresponding bin</span>
        <span class="c1"># plus one</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_bin_edges</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># for &quot;inds&quot; now a number of ..</span>
        <span class="c1">#   - -1 means below lowest bin (bin index 0)</span>
        <span class="c1">#   - 0 means, hit lowest bin (bin index 0)</span>
        <span class="c1">#   - ..</span>
        <span class="c1">#   - (len(self.db_bin_edges)-1) means above top bin</span>
        <span class="c1"># values that are left of first bin edge have to be moved back into the</span>
        <span class="c1"># binning</span>
        <span class="n">inds</span><span class="p">[</span><span class="n">inds</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># same goes for values right of last bin edge</span>
        <span class="n">inds</span><span class="p">[</span><span class="n">inds</span> <span class="o">==</span> <span class="n">num_db_bins</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="c1"># reshape such that we can iterate over the array, extracting for</span>
        <span class="c1"># each period bin an array of all amplitude bins we have hit</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">inds</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">used_count</span><span class="p">,</span> <span class="n">num_period_bins</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inds_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">):</span>
            <span class="c1"># count how often each bin has been hit for this period bin,</span>
            <span class="c1"># set the current 2D histogram column accordingly</span>
            <span class="n">hist_stack</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">inds_</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">num_db_bins</span><span class="p">)</span>

        <span class="c1"># calculate and set the cumulative version (i.e. going from 0 to 1 from</span>
        <span class="c1"># low to high psd values for every period column) of the current</span>
        <span class="c1"># histogram stack.</span>
        <span class="c1"># sum up the columns to cumulative entries</span>
        <span class="n">hist_stack_cumul</span> <span class="o">=</span> <span class="n">hist_stack</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># normalize every column with its overall number of entries</span>
        <span class="c1"># (can vary from the number of self.times because of values outside</span>
        <span class="c1">#  the histogram db ranges)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">hist_stack_cumul</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># avoid zero division</span>
        <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">hist_stack_cumul</span> <span class="o">=</span> <span class="p">(</span><span class="n">hist_stack_cumul</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># set everything that was calculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack</span> <span class="o">=</span> <span class="n">hist_stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_hist_stack_cumulative</span> <span class="o">=</span> <span class="n">hist_stack_cumul</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_used</span> <span class="o">=</span> <span class="n">used_times</span></div>

<div class="viewcode-block" id="PPSD._get_response"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._get_response.html#obspy.signal.spectral_estimation.PPSD._get_response">[docs]</a>    <span class="k">def</span> <span class="nf">_get_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
        <span class="c1"># check type of metadata and use the correct subroutine</span>
        <span class="c1"># first, to save some time, tried to do this in __init__ like:</span>
        <span class="c1">#   self._get_response = self._get_response_from_inventory</span>
        <span class="c1"># but that makes the object non-picklable</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">Inventory</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_response_from_inventory</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">Parser</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_response_from_parser</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_response_from_paz_dict</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">native_str</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_response_from_resp</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unexpected type for `metadata`: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="PPSD._get_response_from_inventory"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._get_response_from_inventory.html#obspy.signal.spectral_estimation.PPSD._get_response_from_inventory">[docs]</a>    <span class="k">def</span> <span class="nf">_get_response_from_inventory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
        <span class="n">inventory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">inventory</span><span class="o">.</span><span class="n">get_response</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span>
        <span class="n">resp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">get_evalresp_response</span><span class="p">(</span>
            <span class="n">t_samp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nfft</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;VEL&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span></div>

<div class="viewcode-block" id="PPSD._get_response_from_parser"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._get_response_from_parser.html#obspy.signal.spectral_estimation.PPSD._get_response_from_parser">[docs]</a>    <span class="k">def</span> <span class="nf">_get_response_from_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span>
        <span class="n">resp_key</span> <span class="o">=</span> <span class="s2">&quot;RESP.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">resp_file</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_resp</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">resp_key</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Response for </span><span class="si">%s</span><span class="s2"> not found in Parser&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">resp_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">evalresp</span><span class="p">(</span><span class="n">t_samp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nfft</span><span class="p">,</span>
                        <span class="n">filename</span><span class="o">=</span><span class="n">resp_file</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
                        <span class="n">station</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">station</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
                        <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">locid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                        <span class="n">units</span><span class="o">=</span><span class="s2">&quot;VEL&quot;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span></div>

<div class="viewcode-block" id="PPSD._get_response_from_paz_dict"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._get_response_from_paz_dict.html#obspy.signal.spectral_estimation.PPSD._get_response_from_paz_dict">[docs]</a>    <span class="k">def</span> <span class="nf">_get_response_from_paz_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
        <span class="n">paz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">paz_to_freq_resp</span><span class="p">(</span><span class="n">paz</span><span class="p">[</span><span class="s1">&#39;poles&#39;</span><span class="p">],</span> <span class="n">paz</span><span class="p">[</span><span class="s1">&#39;zeros&#39;</span><span class="p">],</span>
                                <span class="n">paz</span><span class="p">[</span><span class="s1">&#39;gain&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">paz</span><span class="p">[</span><span class="s1">&#39;sensitivity&#39;</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nfft</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span></div>

<div class="viewcode-block" id="PPSD._get_response_from_resp"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._get_response_from_resp.html#obspy.signal.spectral_estimation.PPSD._get_response_from_resp">[docs]</a>    <span class="k">def</span> <span class="nf">_get_response_from_resp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">evalresp</span><span class="p">(</span><span class="n">t_samp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nfft</span><span class="p">,</span>
                        <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
                        <span class="n">station</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">station</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
                        <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">locid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                        <span class="n">units</span><span class="o">=</span><span class="s2">&quot;VEL&quot;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span></div>

<div class="viewcode-block" id="PPSD.get_percentile"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.get_percentile.html#obspy.signal.spectral_estimation.PPSD.get_percentile">[docs]</a>    <span class="k">def</span> <span class="nf">get_percentile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns periods and approximate psd values for given percentile value.</span>

<span class="sd">        :type percentile: int</span>
<span class="sd">        :param percentile: percentile for which to return approximate psd</span>
<span class="sd">                value. (e.g. a value of 50 is equal to the median.)</span>
<span class="sd">        :returns: (periods, percentile_values)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hist_cum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_histogram_cumulative</span>
        <span class="k">if</span> <span class="n">hist_cum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># go to percent</span>
        <span class="n">percentile</span> <span class="o">=</span> <span class="n">percentile</span> <span class="o">/</span> <span class="mf">100.0</span>
        <span class="k">if</span> <span class="n">percentile</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># only for this special case we have to search from the other side</span>
            <span class="c1"># (otherwise we always get index 0 in .searchsorted())</span>
            <span class="n">side</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">side</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span>
        <span class="n">percentile_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">percentile</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">hist_cum</span><span class="p">]</span>
        <span class="c1"># map to power db values</span>
        <span class="n">percentile_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_bin_edges</span><span class="p">[</span><span class="n">percentile_values</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">period_bin_centers</span><span class="p">,</span> <span class="n">percentile_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="PPSD.get_mode"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.get_mode.html#obspy.signal.spectral_estimation.PPSD.get_mode">[docs]</a>    <span class="k">def</span> <span class="nf">get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns periods and mode psd values (i.e. for each frequency the psd</span>
<span class="sd">        value with the highest probability is selected).</span>

<span class="sd">        :returns: (periods, psd mode values)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_histogram</span>
        <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_bin_centers</span><span class="p">[</span><span class="n">hist</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">period_bin_centers</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="PPSD.get_mean"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.get_mean.html#obspy.signal.spectral_estimation.PPSD.get_mean">[docs]</a>    <span class="k">def</span> <span class="nf">get_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns periods and mean psd values (i.e. for each frequency the mean</span>
<span class="sd">        psd value is selected).</span>

<span class="sd">        :returns: (periods, psd mean values)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_histogram</span>
        <span class="k">if</span> <span class="n">hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">hist_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_histogram_count</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">hist</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_bin_centers</span> <span class="o">/</span> <span class="n">hist_count</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">period_bin_centers</span><span class="p">,</span> <span class="n">mean</span><span class="p">)</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Old save/load mechanism based on pickle module is not &quot;</span>
                <span class="s2">&quot;working well across versions, so please use new &quot;</span>
                <span class="s2">&quot;&#39;save_npz&#39;/&#39;load_npz&#39; mechanism.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED! Use :meth:`~PPSD.save_npz` and :meth:`~PPSD.load_npz`</span>
<span class="sd">        instead!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">compress</span><span class="p">:</span>
            <span class="c1"># due to an bug in older python version we can&#39;t use with</span>
            <span class="c1"># https://bugs.python.org/issue8601</span>
            <span class="n">file_</span> <span class="o">=</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_</span><span class="p">)</span>
            <span class="n">file_</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Old save/load mechanism based on pickle module is not &quot;</span>
                <span class="s2">&quot;working well across versions, so please use new &quot;</span>
                <span class="s2">&quot;&#39;save_npz&#39;/&#39;load_npz&#39; mechanism.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED! Use :meth:`~PPSD.save_npz` and :meth:`~PPSD.load_npz`</span>
<span class="sd">        instead!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># identify bzip2 compressed file using bzip2&#39;s magic number</span>
        <span class="n">bz2_magic</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x42\x5a\x68</span><span class="s1">&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_</span><span class="p">:</span>
            <span class="n">file_start</span> <span class="o">=</span> <span class="n">file_</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bz2_magic</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">file_start</span> <span class="o">==</span> <span class="n">bz2_magic</span><span class="p">:</span>
            <span class="c1"># In theory a file containing random data could also start with the</span>
            <span class="c1"># bzip2 magic number. However, since save() (implicitly) uses</span>
            <span class="c1"># version &quot;0&quot; of the pickle protocol, the pickled data is</span>
            <span class="c1"># guaranteed to be ASCII encoded and hence cannot start with this</span>
            <span class="c1"># magic number.</span>
            <span class="c1"># cf. https://docs.python.org/3/library/pickle.html</span>
            <span class="c1">#</span>
            <span class="c1"># due to an bug in older python version we can&#39;t use with</span>
            <span class="c1"># https://bugs.python.org/issue8601</span>
            <span class="n">file_</span> <span class="o">=</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
            <span class="n">ppsd</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_</span><span class="p">)</span>
            <span class="n">file_</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_</span><span class="p">:</span>
                <span class="n">ppsd</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_</span><span class="p">)</span>

        <span class="c1"># some workarounds for older PPSD pickle files</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ppsd</span><span class="p">,</span> <span class="s2">&quot;is_rotational_data&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ppsd</span><span class="o">.</span><span class="n">is_rotational_data</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">ppsd</span><span class="o">.</span><span class="n">special_handling</span> <span class="o">=</span> <span class="s2">&quot;ringlaser&quot;</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="n">ppsd</span><span class="p">,</span> <span class="s2">&quot;is_rotational_data&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ppsd</span><span class="p">,</span> <span class="s2">&quot;special_handling&quot;</span><span class="p">):</span>
            <span class="n">ppsd</span><span class="o">.</span><span class="n">special_handling</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Adds ppsd_length and overlap attributes if not existing. This</span>
        <span class="c1"># ensures compatibility with pickled objects without these attributes.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ppsd</span><span class="o">.</span><span class="n">ppsd_length</span>
            <span class="n">ppsd</span><span class="o">.</span><span class="n">overlap</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">ppsd</span><span class="o">.</span><span class="n">ppsd_length</span> <span class="o">=</span> <span class="mf">3600.</span>
            <span class="n">ppsd</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="mf">0.5</span>

        <span class="k">return</span> <span class="n">ppsd</span>

<div class="viewcode-block" id="PPSD.save_npz"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.save_npz.html#obspy.signal.spectral_estimation.PPSD.save_npz">[docs]</a>    <span class="k">def</span> <span class="nf">save_npz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the PPSD as a compressed numpy binary (npz format).</span>

<span class="sd">        The resulting file can be restored using `my_ppsd.load_npz(filename)`.</span>

<span class="sd">        :type filename: str</span>
<span class="sd">        :param filename: Name of numpy .npz output file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NPZ_STORE_KEYS</span><span class="p">])</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="PPSD.load_npz"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.load_npz.html#obspy.signal.spectral_estimation.PPSD.load_npz">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load_npz</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load previously computed PPSD results.</span>

<span class="sd">        Load previously computed PPSD results from a</span>
<span class="sd">        compressed numpy binary in npz format, written with</span>
<span class="sd">        :meth:`~PPSD.write_npz`.</span>
<span class="sd">        If more data are to be added and processed, metadata have to be</span>
<span class="sd">        specified again during loading because they are not</span>
<span class="sd">        stored in the npz format.</span>

<span class="sd">        :type filename: str</span>
<span class="sd">        :param filename: Name of numpy .npz file with stored PPSD data</span>
<span class="sd">        :type metadata: :class:`~obspy.core.inventory.inventory.Inventory` or</span>
<span class="sd">            :class:`~obspy.io.xseed Parser` or str or dict</span>
<span class="sd">        :param metadata: Response information of instrument. See notes in</span>
<span class="sd">            :meth:`PPSD.__init__` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="c1"># the information regarding stats is set from the npz</span>
        <span class="n">ppsd</span> <span class="o">=</span> <span class="n">PPSD</span><span class="p">(</span><span class="n">Stats</span><span class="p">(),</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ppsd</span><span class="o">.</span><span class="n">NPZ_STORE_KEYS</span><span class="p">:</span>
            <span class="c1"># data is stored as arrays in the npz.</span>
            <span class="c1"># we have to convert those back to lists (or simple types), so that</span>
            <span class="c1"># additionally processed data can be appended/inserted later.</span>
            <span class="n">data_</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ppsd</span><span class="o">.</span><span class="n">NPZ_STORE_KEYS_LIST_TYPES</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;_times_data&#39;</span><span class="p">,</span> <span class="s1">&#39;_times_gaps&#39;</span><span class="p">]:</span>
                    <span class="n">data_</span> <span class="o">=</span> <span class="n">data_</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data_</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data_</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ppsd</span><span class="o">.</span><span class="n">NPZ_STORE_KEYS_SIMPLE_TYPES</span> <span class="o">+</span>
                         <span class="n">ppsd</span><span class="o">.</span><span class="n">NPZ_STORE_KEYS_VERSION_NUMBERS</span><span class="p">):</span>
                <span class="n">data_</span> <span class="o">=</span> <span class="n">data_</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ppsd</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ppsd</span></div>

<div class="viewcode-block" id="PPSD.add_npz"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.add_npz.html#obspy.signal.spectral_estimation.PPSD.add_npz">[docs]</a>    <span class="k">def</span> <span class="nf">add_npz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add previously computed PPSD results to current PPSD instance.</span>

<span class="sd">        Load previously computed PPSD results from a</span>
<span class="sd">        compressed numpy binary in npz format, written with</span>
<span class="sd">        :meth:`~PPSD.write_npz` and add the information to the current PPSD</span>
<span class="sd">        instance.</span>
<span class="sd">        Before adding the data it is checked if the data was computed with the</span>
<span class="sd">        same settings, then any time periods that are not yet covered are added</span>
<span class="sd">        to the current PPSD (a warning is emitted if any segments are omitted).</span>

<span class="sd">        :type filename: str</span>
<span class="sd">        :param filename: Name of numpy .npz file(s) with stored PPSD data.</span>
<span class="sd">            Wildcards are possible and will be expanded using</span>
<span class="sd">            :py:func:`glob.glob`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_npz</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="PPSD._add_npz"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._add_npz.html#obspy.signal.spectral_estimation.PPSD._add_npz">[docs]</a>    <span class="k">def</span> <span class="nf">_add_npz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See :meth:`PPSD.add_npz()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="c1"># check if all metadata agree</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NPZ_STORE_KEYS_SIMPLE_TYPES</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Mismatch in &#39;</span><span class="si">%s</span><span class="s2">&#39; attribute.</span><span class="se">\n\t</span><span class="s2">Current:</span><span class="se">\n\t</span><span class="si">%s</span><span class="se">\n\t</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Loaded:</span><span class="se">\n\t</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NPZ_STORE_KEYS_ARRAY_TYPES</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Mismatch in &#39;</span><span class="si">%s</span><span class="s2">&#39; attribute.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">key</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="c1"># load new psd data</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NPZ_STORE_KEYS_VERSION_NUMBERS</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Mismatch in version numbers (</span><span class="si">%s</span><span class="s2">) between current data &quot;</span>
                       <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">) and loaded data (</span><span class="si">%s</span><span class="s2">).&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span>
                           <span class="n">key</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">_times_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_times_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">_times_gaps</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_times_gaps&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">_times_processed</span> <span class="o">=</span> <span class="p">[</span><span class="n">d_</span> <span class="k">for</span> <span class="n">d_</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_times_processed&quot;</span><span class="p">]]</span>
        <span class="n">_binned_psds</span> <span class="o">=</span> <span class="p">[</span><span class="n">d_</span> <span class="k">for</span> <span class="n">d_</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_binned_psds&quot;</span><span class="p">]]</span>
        <span class="c1"># add new data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_times_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times_gaps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_times_gaps</span><span class="p">)</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">psd</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_times_processed</span><span class="p">,</span> <span class="n">_binned_psds</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_time_present</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="n">duplicates</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__insert_processed_data</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span>
        <span class="c1"># warn if some segments were omitted</span>
        <span class="k">if</span> <span class="n">duplicates</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> segments omitted in file &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                   <span class="s2">&quot;(time ranges already covered).&quot;</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">duplicates</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_times_processed</span><span class="p">),</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="PPSD.plot"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.plot.html#obspy.signal.spectral_estimation.PPSD.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_coverage</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_histogram</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">show_percentiles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">percentiles</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
             <span class="n">show_noise_models</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">max_percentage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">period_lim</span><span class="o">=</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">179</span><span class="p">),</span> <span class="n">show_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">show_mean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">obspy_sequential</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">cumulative_number_of_colors</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">xaxis_frequency</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the 2D histogram of the current PPSD.</span>
<span class="sd">        If a filename is specified the plot is saved to this file, otherwise</span>
<span class="sd">        a plot window is shown.</span>

<span class="sd">        :type filename: str, optional</span>
<span class="sd">        :param filename: Name of output file</span>
<span class="sd">        :type show_coverage: bool, optional</span>
<span class="sd">        :param show_coverage: Enable/disable second axes with representation of</span>
<span class="sd">                data coverage time intervals.</span>
<span class="sd">        :type show_percentiles: bool, optional</span>
<span class="sd">        :param show_percentiles: Enable/disable plotting of approximated</span>
<span class="sd">                percentiles. These are calculated from the binned histogram and</span>
<span class="sd">                are not the exact percentiles.</span>
<span class="sd">        :type show_histogram: bool, optional</span>
<span class="sd">        :param show_histogram: Enable/disable plotting of histogram. This</span>
<span class="sd">                can be set ``False`` e.g. to make a plot with only percentiles</span>
<span class="sd">                plotted. Defaults to ``True``.</span>
<span class="sd">        :type percentiles: list of ints</span>
<span class="sd">        :param percentiles: percentiles to show if plotting of percentiles is</span>
<span class="sd">                selected.</span>
<span class="sd">        :type show_noise_models: bool, optional</span>
<span class="sd">        :param show_noise_models: Enable/disable plotting of noise models.</span>
<span class="sd">        :type grid: bool, optional</span>
<span class="sd">        :param grid: Enable/disable grid in histogram plot.</span>
<span class="sd">        :type show: bool, optional</span>
<span class="sd">        :param show: Enable/disable immediately showing the plot.</span>
<span class="sd">        :type max_percentage: float, optional</span>
<span class="sd">        :param max_percentage: Maximum percentage to adjust the colormap. The</span>
<span class="sd">            default is 30% unless ``cumulative=True``, in which case this value</span>
<span class="sd">            is ignored.</span>
<span class="sd">        :type period_lim: tuple of 2 floats, optional</span>
<span class="sd">        :param period_lim: Period limits to show in histogram. When setting</span>
<span class="sd">            ``xaxis_frequency=True``, this is expected to be frequency range in</span>
<span class="sd">            Hz.</span>
<span class="sd">        :type show_mode: bool, optional</span>
<span class="sd">        :param show_mode: Enable/disable plotting of mode psd values.</span>
<span class="sd">        :type show_mean: bool, optional</span>
<span class="sd">        :param show_mean: Enable/disable plotting of mean psd values.</span>
<span class="sd">        :type cmap: :class:`matplotlib.colors.Colormap`</span>
<span class="sd">        :param cmap: Colormap to use for the plot. To use the color map like in</span>
<span class="sd">            PQLX, [McNamara2004]_ use :const:`obspy.imaging.cm.pqlx`.</span>
<span class="sd">        :type cumulative: bool</span>
<span class="sd">        :param cumulative: Can be set to `True` to show a cumulative</span>
<span class="sd">            representation of the histogram, i.e. showing color coded for each</span>
<span class="sd">            frequency/amplitude bin at what percentage in time the value is</span>
<span class="sd">            not exceeded by the data (similar to the `percentile` option but</span>
<span class="sd">            continuously and color coded over the whole area). `max_percentage`</span>
<span class="sd">            is ignored when this option is specified.</span>
<span class="sd">        :type cumulative_number_of_colors: int</span>
<span class="sd">        :param cumulative_number_of_colors: Number of discrete color shades to</span>
<span class="sd">            use, `None` for a continuous colormap.</span>
<span class="sd">        :type xaxis_frequency: bool</span>
<span class="sd">        :param xaxis_frequency: If set to `True`, the x axis will be frequency</span>
<span class="sd">            in Hertz as opposed to the default of period in seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_histogram</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span> <span class="o">=</span> <span class="n">AttribDict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">show_coverage</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.90</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>
            <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.17</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_percentiles</span><span class="p">:</span>
            <span class="c1"># for every period look up the approximate place of the percentiles</span>
            <span class="k">for</span> <span class="n">percentile</span> <span class="ow">in</span> <span class="n">percentiles</span><span class="p">:</span>
                <span class="n">periods</span><span class="p">,</span> <span class="n">percentile_values</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_percentile</span><span class="p">(</span><span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">xaxis_frequency</span><span class="p">:</span>
                    <span class="n">xdata</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">periods</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xdata</span> <span class="o">=</span> <span class="n">periods</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">percentile_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_mode</span><span class="p">:</span>
            <span class="n">periods</span><span class="p">,</span> <span class="n">mode_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xaxis_frequency</span><span class="p">:</span>
                <span class="n">xdata</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">periods</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xdata</span> <span class="o">=</span> <span class="n">periods</span>
            <span class="k">if</span> <span class="n">cmap</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;viridis&quot;</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;0.8&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">mode_</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_mean</span><span class="p">:</span>
            <span class="n">periods</span><span class="p">,</span> <span class="n">mean_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mean</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xaxis_frequency</span><span class="p">:</span>
                <span class="n">xdata</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">periods</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xdata</span> <span class="o">=</span> <span class="n">periods</span>
            <span class="k">if</span> <span class="n">cmap</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;viridis&quot;</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;0.8&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">mean_</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_noise_models</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">periods</span><span class="p">,</span> <span class="n">noise_model</span> <span class="ow">in</span> <span class="p">(</span><span class="n">get_nhnm</span><span class="p">(),</span> <span class="n">get_nlnm</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">xaxis_frequency</span><span class="p">:</span>
                    <span class="n">xdata</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">periods</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xdata</span> <span class="o">=</span> <span class="n">periods</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">noise_model</span><span class="p">,</span> <span class="s1">&#39;0.4&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_histogram</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;[%]&quot;</span>
            <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;non-exceedance (cumulative) [%]&quot;</span>
                <span class="k">if</span> <span class="n">max_percentage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Parameter &#39;max_percentage&#39; is ignored when &quot;</span>
                           <span class="s2">&quot;&#39;cumulative=True&#39;.&quot;</span><span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">max_percentage</span> <span class="o">=</span> <span class="mi">100</span>
                <span class="k">if</span> <span class="n">cumulative_number_of_colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cmap</span> <span class="o">=</span> <span class="n">LinearSegmentedColormap</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">cmap</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">segmentdata</span><span class="o">=</span><span class="n">cmap</span><span class="o">.</span><span class="n">_segmentdata</span><span class="p">,</span>
                        <span class="n">N</span><span class="o">=</span><span class="n">cumulative_number_of_colors</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">max_percentage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Set default only if cumulative is not True.</span>
                <span class="n">max_percentage</span> <span class="o">=</span> <span class="mi">30</span>

            <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">cumulative</span> <span class="o">=</span> <span class="n">cumulative</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">cmap</span> <span class="o">=</span> <span class="n">cmap</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">max_percentage</span> <span class="o">=</span> <span class="n">max_percentage</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">xaxis_frequency</span> <span class="o">=</span> <span class="n">xaxis_frequency</span>
            <span class="k">if</span> <span class="n">max_percentage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">color_limits</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_percentage</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">color_limits</span> <span class="o">=</span> <span class="n">color_limits</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_plot_histogram</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">semilogx</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">xaxis_frequency</span><span class="p">:</span>
            <span class="n">xlim</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">x</span><span class="p">,</span> <span class="n">period_lim</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">invert_xaxis</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xlim</span> <span class="o">=</span> <span class="n">period_lim</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Period [s]&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">xlim</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_handling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude [$m^2/s^4/Hz$] [dB]&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude [dB]&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">FormatStrFormatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_plot_title</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">show_coverage</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__plot_coverage</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span>
            <span class="c1"># emulating fig.autofmt_xdate():</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">ax2</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">():</span>
                <span class="n">label</span><span class="o">.</span><span class="n">set_ha</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
                <span class="n">label</span><span class="o">.</span><span class="n">set_rotation</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>

        <span class="c1"># Catch underflow warnings due to plotting on log-scale.</span>
        <span class="n">_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">show</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">fig</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">_t</span><span class="p">)</span></div>

<div class="viewcode-block" id="PPSD._plot_histogram"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._plot_histogram.html#obspy.signal.spectral_estimation.PPSD._plot_histogram">[docs]</a>    <span class="k">def</span> <span class="nf">_plot_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reuse a previously created figure returned by :meth:`plot(show=False)`</span>
<span class="sd">        and plot the current histogram stack (pre-computed using</span>
<span class="sd">        :meth:`calculate_histogram()`) into the figure. If a filename is</span>
<span class="sd">        provided, the figure will be saved to a local file.</span>
<span class="sd">        Note that many aspects of the plot are statically set during the first</span>
<span class="sd">        :meth:`plot()` call, so this routine can only be used to update with</span>
<span class="sd">        data from a new stack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;quadmesh&quot;</span> <span class="ow">in</span> <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;quadmesh&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">cumulative</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_histogram_cumulative</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># avoid divison with zero in case of empty stack</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_histogram</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">/</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_histogram_count</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">xedges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">period_xedges</span>
        <span class="k">if</span> <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">xaxis_frequency</span><span class="p">:</span>
            <span class="n">xedges</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">xedges</span>

        <span class="k">if</span> <span class="s2">&quot;meshgrid&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">meshgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xedges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_bin_edges</span><span class="p">)</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">meshgrid</span>
        <span class="n">ppsd</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">cmap</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">quadmesh</span> <span class="o">=</span> <span class="n">ppsd</span>

        <span class="k">if</span> <span class="s2">&quot;colorbar&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="p">:</span>
            <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ppsd</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">cb</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="o">*</span><span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">color_limits</span><span class="p">)</span>
            <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">colorbar</span> <span class="o">=</span> <span class="n">cb</span>

        <span class="k">if</span> <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">max_percentage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ppsd</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="o">*</span><span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">color_limits</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fig</span><span class="o">.</span><span class="n">ppsd</span><span class="o">.</span><span class="n">cmap</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;viridis&quot;</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;0.7&quot;</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;major&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">color</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">color</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">*</span><span class="n">xlim</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">draw</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">under</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="PPSD._get_plot_title"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD._get_plot_title.html#obspy.signal.spectral_estimation.PPSD._get_plot_title">[docs]</a>    <span class="k">def</span> <span class="nf">_get_plot_title</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">   </span><span class="si">%s</span><span class="s2"> -- </span><span class="si">%s</span><span class="s2">  (</span><span class="si">%i</span><span class="s2">/</span><span class="si">%i</span><span class="s2"> segments)&quot;</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">title</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                         <span class="n">UTCDateTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">date</span><span class="p">,</span>
                         <span class="n">UTCDateTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">date</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">current_histogram_count</span><span class="p">,</span>
                         <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">title</span></div>

<div class="viewcode-block" id="PPSD.plot_coverage"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.PPSD.plot_coverage.html#obspy.signal.spectral_estimation.PPSD.plot_coverage">[docs]</a>    <span class="k">def</span> <span class="nf">plot_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the data coverage of the histogram of the current PPSD.</span>
<span class="sd">        If a filename is specified the plot is saved to this file, otherwise</span>
<span class="sd">        a plot window is shown.</span>

<span class="sd">        :type filename: str, optional</span>
<span class="sd">        :param filename: Name of output file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__plot_coverage</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">autofmt_xdate</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_plot_title</span><span class="p">())</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__plot_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to plot coverage into given axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis_date</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="c1"># plot data used in histogram stack</span>
        <span class="n">used_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span>
                      <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_used</span><span class="p">]</span>
        <span class="n">unused_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_processed</span>
                        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_times_used</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">times</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="n">used_times</span><span class="p">,</span> <span class="n">unused_times</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;0.6&quot;</span><span class="p">)):</span>
            <span class="c1"># skip on empty lists (i.e. all data used, or none used in stack)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">times</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">starts</span> <span class="o">=</span> <span class="p">[</span><span class="n">date2num</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">]</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">[</span><span class="n">date2num</span><span class="p">((</span><span class="n">t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppsd_length</span><span class="p">)</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">]</span>
            <span class="n">startends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">])</span>
            <span class="n">startends</span> <span class="o">=</span> <span class="n">compress_start_end</span><span class="p">(</span><span class="n">startends</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
                                           <span class="n">merge_overlaps</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="n">startends</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">startends</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># plot data that was fed to PPSD</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">times_data</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">end</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># plot gaps in data fed to PPSD</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">times_gaps</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">end</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span></div>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;get_NLNM() has been renamed to get_nlnm().&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_NLNM</span><span class="p">():</span>  <span class="c1"># noqa</span>
    <span class="k">return</span> <span class="n">get_nlnm</span><span class="p">()</span>


<div class="viewcode-block" id="get_nlnm"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.get_nlnm.html#obspy.signal.spectral_estimation.get_nlnm">[docs]</a><span class="k">def</span> <span class="nf">get_nlnm</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns periods and psd values for the New Low Noise Model.</span>
<span class="sd">    For information on New High/Low Noise Model see [Peterson1993]_.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">NOISE_MODEL_FILE</span><span class="p">)</span>
    <span class="n">periods</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;model_periods&#39;</span><span class="p">]</span>
    <span class="n">nlnm</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;low_noise&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">nlnm</span><span class="p">)</span></div>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;get_NHNM() has been renamed to get_nhnm().&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_NHNM</span><span class="p">():</span>  <span class="c1"># noqa</span>
    <span class="k">return</span> <span class="n">get_nhnm</span><span class="p">()</span>


<div class="viewcode-block" id="get_nhnm"><a class="viewcode-back" href="../../../packages/autogen/obspy.signal.spectral_estimation.get_nhnm.html#obspy.signal.spectral_estimation.get_nhnm">[docs]</a><span class="k">def</span> <span class="nf">get_nhnm</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns periods and psd values for the New High Noise Model.</span>
<span class="sd">    For information on New High/Low Noise Model see [Peterson1993]_.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">NOISE_MODEL_FILE</span><span class="p">)</span>
    <span class="n">periods</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;model_periods&#39;</span><span class="p">]</span>
    <span class="n">nlnm</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;high_noise&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">nlnm</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">exclude_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

</div>

<footer>
<p class="text-muted small">
By the <a href="https://github.com/orgs/obspy/people">ObsPy
Development Team</a> and many <a href="#contributers" role="button"
data-toggle="modal" data-target="#contributers">Awesome Contributors</a>™ &nbsp;|&nbsp; Built with
<a href="http://getbootstrap.com/">Bootstrap</a> and
<a href="http://glyphicons.com//">Glyphicons</a> &nbsp;|&nbsp; Copyright 2008-2016
</p>
</footer>
<div id="contributers" class="modal fade" tabindex="-1"
role="dialog" aria-labelledby="contributersLabel" aria-hidden="true">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<button type="button" class="close" data-dismiss="modal"
aria-hidden="true">&times;</button>
<h3 class="modal-title" id="contributersLabel">Thank you!</h3>
</div>
<div class="modal-body">
<p>We would like to thank our contributors, whose efforts make
this software what it is. These people have helped by writing code
and documentation, and by testing. They have created and
maintained this product, its associated libraries and
applications, our build tools and our web sites.</p>
<h4>Contributors</h4>
<div class="container-fluid">
<div class="row">
<div class="col-md-6">
<ul>
<li>Ammon, Charles J.</li>
<li>Arnarsson, Ólafur St.</li>
<li>Barsch, Robert</li>
<li>Bernardi, Fabrizio</li>
<li>Beyreuther, Moritz</li>
<li>Carothers, Lloyd</li>
<li>Egdorf, Sven</li>
<li>Ermert, Laura</li>
<li>Fabbri, Tommaso</li>
<li>Grunberg, Marc</li>
<li>Heimann, Sebastian</li>
<li>Hope, Gaute</li>
<li>Inza, Adolfo</li>
<li>Ketchum, David</li>
<li>Kremers, Simon</li>
<li>Krieger, Lars</li>
<li>Käufl, Paul</li>
<li>Lecocq, Thomas</li>
<li>Lesage, Philippe</li>
<li>Lopes, Rui L.</li>
<li>Maggi, Alessia</li>
<li>Megies, Tobias</li>
<li>Michelini, Alberto</li>
<li>Morgenstern, Bernhard</li>
<li>Panning, Mark P.</li>
<li>Reyes, Celso</li>
<li>Rothenhäusler, Nicolas</li>
<li>Sales de Andrade, Elliott</li>
<li>Saul, Joachim</li>
<li>Sippl, Christian</li>
<li>Stange, Stefan</li>
<li>Trabant, Chad</li>
<li>Walker, Andrew</li>
<li>Wassermann, Joachim</li>
<li>Winkelman, Andrew</li>
<li>van Driel, Martin</li>
</ul>
</div>
<div class="col-md-6">
<ul>
<li>Antunes, Emanuel</li>
<li>Bank, Markus</li>
<li>Behr, Yannik</li>
<li>Bernauer, Felix</li>
<li>Bonaimé, Sébastien</li>
<li>Danecek, Peter</li>
<li>Engels, Fabian</li>
<li>Eulenfeld, Tom</li>
<li>Grellier, Clément</li>
<li>Hammer, Conny</li>
<li>Heiniger, Lukas</li>
<li>Igel, Heiner</li>
<li>Isken, Marius</li>
<li>Koymans, Mathijs</li>
<li>Kress, Victor</li>
<li>Krischer, Lion</li>
<li>Köhler, Andreas</li>
<li>Leeman, John</li>
<li>Lomax, Anthony</li>
<li>MacCarthy, Jonathan</li>
<li>Martin, Henri</li>
<li>Meschede, Matthias</li>
<li>Miller, Nathaniel C.</li>
<li>Nof, Ran Novitsky</li>
<li>Rapagnani, Giovanni</li>
<li>Ringler, Adam</li>
<li>Russo, Emiliano</li>
<li>Satriano, Claudio</li>
<li>Scheingraber, Chris</li>
<li>Snoke, Arthur</li>
<li>Sullivan, Benjamin</li>
<li>Uieda, Leonardo</li>
<li>Walther, Marcus</li>
<li>Williams, Mark C.</li>
<li>Zad, Seyed Kasra Hosseini</li>
</ul>
</div>
</div>
</div>
<h4>Funds</h4>
<p>ObsPy was partially funded by the</p>
<ul>
<li>German Science Foundation (DFG) via grant DFG IG 16/9-1</li>
<li>German Ministry for Education and Research (BMBF), GEOTECHNOLOGIEN grant 03G0646H.</li>
<li>NERA project (Network of European Research Infrastructures for Earthquake Risk Assessment and Mitigation) under the European Community&#39;s Seventh Framework Programme (FP7/2007-2013) grant agreement n° 262330</li>
<li>Leibniz Institute for Applied Geophysics (LIAG)</li>
<li>VERCE EU-FP7 project (no. 283543)</li>
</ul>
</div>
<div class="modal-footer">
<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
</div>
</div>
</div>
</div>

</div>


  </body>
</html>