<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>obspy.clients.filesystem.sds &#8212; ObsPy Documentation (1.0.3)</title>
    <link rel="stylesheet" href="../../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/font.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/css/base.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript">
  var shiftWindow = function() { scrollBy(0, -70) };
  if (location.hash) shiftWindow();
  window.addEventListener("hashchange", shiftWindow);
</script>

  </head>
  <body>
<div id="wrapper">
<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
<div class="container-fluid">
<div class="navbar-header">
<button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a href="/" class="navbar-brand" title="Home"><span class="icon-obspy"></span>&nbsp;ObsPy</a>
</div>
<div class="navbar-collapse collapse">
<form class="navbar-form navbar-right" role="search" method="get" action="search.html">
<div class="form-group">
<input type="text" class="form-control" placeholder="Search Docs" name="q">
</div>
</form>
<ul class="nav navbar-nav navbar-right">
<li><a href="https://github.com/obspy/obspy/" title="GitHub"><span class="icon-github iconx2"></span><span class="hidden-sm">&nbsp;GitHub</span></a></li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Documentation"><span class="glyphicon glyphicon-book iconx2"></span><span class="hidden-sm">&nbsp;Documentation</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Getting&nbsp;Started</li>
<li><a href="https://github.com/obspy/obspy/wiki#installation">Installation</a></li>
<li><a href="https://tutorial.obspy.org/">Tutorial</a></li>
<li><a href="http://gallery.obspy.org/">Gallery</a></li>
<li><a href="https://docs.obspy.org/">API&nbsp;Documentation&nbsp;(latest&nbsp;release)</a></li>
<li><a href="https://docs.obspy.org/master/">API&nbsp;Documentation&nbsp;(current&nbsp;master)</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Mailing&nbsp;Lists"><span class="glyphicon glyphicon-envelope iconx2"></span><span class="hidden-sm">&nbsp;Mailing&nbsp;Lists</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li class="dropdown-header">Announcements&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-announcements"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-announcements/"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archive</a></li>
<li class="divider"></li>
<li class="dropdown-header">Users&nbsp;Mailing&nbsp;List&nbsp;(public)</li>
<li><a href="http://lists.swapbytes.de/mailman/listinfo/obspy-users"><span class="glyphicon glyphicon-user"></span>&nbsp;Subscribe</a></li>
<li><a href="http://lists.swapbytes.de/archives/obspy-users"><span class="glyphicon glyphicon-inbox"></span>&nbsp;Archives</a></li>
<li><a href="mailto:users@obspy.org"><span class="glyphicon glyphicon-envelope"></span>&nbsp;Post&nbsp;a&nbsp;message</a></li>
</ul>
</li>
<li class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" title="Developer&nbsp;Resources"><span class="glyphicon glyphicon-cog iconx2"></span><span class="hidden-sm">&nbsp;Developer&nbsp;Resources</span>&nbsp;<b class="caret"></b></a>
<ul class="dropdown-menu">
<li><a href="https://gitter.im/obspy/obspy">Gitter</a></li>
<li><a href="https://github.com/obspy/obspy/blob/master/.github/CONTRIBUTING.md">How&nbsp;to&nbsp;contribute</a></li>
<li><a href="http://docs.obspy.org/coding_style.html">Coding&nbsp;Style&nbsp;Guide</a></li>
<li><a href="https://github.com/obspy/obspy/releases/">All&nbsp;Releases</a></li>
<li class="divider"></li>
<li class="dropdown-header">Code&nbsp;Analysis</li>
<li><a href="http://docs.obspy.org/master/pep8/index.html">PEP8</a></li>
<li><a href="http://docs.obspy.org/master/coverage/index.html">Python&nbsp;Coverage</a></li>
<li><a href="http://docs.obspy.org/master/c_coverage/index.html">C&nbsp;Coverage</a></li>
<li><a href="https://coveralls.io/r/obspy/obspy?branch=master">Coveralls</a></li>
<li class="divider"></li>
<li class="dropdown-header">Continuous&nbsp;Integration</li>
<li><a href="http://tests.obspy.org/">Test&nbsp;Reports</a></li>
<li><a href="https://travis-ci.org/obspy/obspy/"><span class="icon-travis"></span>&nbsp;Travis&nbsp;CI</a></li>
<li><a href="https://ci.appveyor.com/project/obspy/obspy"><span class="icon-appveyor"></span>&nbsp;AppVeyor</a></li>
</ul>
</li>
</ul>
</div>
</div>
</nav>

<div id="content" class="container">
  
    <div class="breadcrumb pull-right"><a href="../../../../genindex.html" title="General Index"
         accesskey="I">index</a><span style="color: #ccc; padding: 0 5px;">| </span><a href="../../../../py-modindex.html" title="Python Module Index"
         >modules</a>
    </div>
    <ol class="breadcrumb">
        <li><a href="../../../../contents.html">ObsPy Documentation (1.0.3)</a></li>
        <li><a href="../../../index.html" accesskey="U">Module code</a></li> 
    </ol>
  
  <h1>Source code for obspy.clients.filesystem.sds</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">obspy.clients.filesystem.sds - read support for SeisComP Data Structure</span>
<span class="sd">=======================================================================</span>
<span class="sd">This module provides read support for data stored locally in a SeisComP Data</span>
<span class="sd">Structure (SDS) directory structure.</span>

<span class="sd">The directory and file layout of SDS is defined as::</span>

<span class="sd">    &lt;SDSdir&gt;/YEAR/NET/STA/CHAN.TYPE/NET.STA.LOC.CHAN.TYPE.YEAR.DAY</span>

<span class="sd">These fields are defined by SDS as follows::</span>

<span class="sd">    SDSdir :  arbitrary base directory</span>
<span class="sd">    YEAR   :  4 digit year</span>
<span class="sd">    NET    :  Network code/identifier, up to 8 characters, no spaces</span>
<span class="sd">    STA    :  Station code/identifier, up to 8 characters, no spaces</span>
<span class="sd">    CHAN   :  Channel code/identifier, up to 8 characters, no spaces</span>
<span class="sd">    TYPE   :  1 characters indicating the data type, recommended types are:</span>
<span class="sd">               &#39;D&#39; - Waveform data</span>
<span class="sd">               &#39;E&#39; - Detection data</span>
<span class="sd">               &#39;L&#39; - Log data</span>
<span class="sd">               &#39;T&#39; - Timing data</span>
<span class="sd">               &#39;C&#39; - Calibration data</span>
<span class="sd">               &#39;R&#39; - Response data</span>
<span class="sd">               &#39;O&#39; - Opaque data</span>
<span class="sd">    LOC    :  Location identifier, up to 8 characters, no spaces</span>
<span class="sd">    DAY    :  3 digit day of year, padded with zeros</span>

<span class="sd">See https://www.seiscomp3.org/wiki/doc/applications/slarchive/SDS.</span>

<span class="sd">:copyright:</span>
<span class="sd">    The ObsPy Development Team (devs@obspy.org)</span>
<span class="sd">:license:</span>
<span class="sd">    GNU Lesser General Public License, Version 3</span>
<span class="sd">    (https://www.gnu.org/copyleft/lesser.html)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">future.builtins</span> <span class="k">import</span> <span class="o">*</span>  <span class="c1"># NOQA</span>

<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">timedelta</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="n">UTCDateTime</span>
<span class="kn">from</span> <span class="nn">obspy.core.stream</span> <span class="k">import</span> <span class="n">_headonly_warning_msg</span>
<span class="kn">from</span> <span class="nn">obspy.core.util.misc</span> <span class="k">import</span> <span class="n">BAND_CODE</span>


<span class="n">SDS_FMTSTR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
    <span class="s2">&quot;</span><span class="si">{year}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{network}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{station}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{channel}</span><span class="s2">.</span><span class="si">{sds_type}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="si">{network}</span><span class="s2">.</span><span class="si">{station}</span><span class="s2">.</span><span class="si">{location}</span><span class="s2">.</span><span class="si">{channel}</span><span class="s2">.</span><span class="si">{sds_type}</span><span class="s2">.</span><span class="si">{year}</span><span class="s2">.</span><span class="si">{doy:03d}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">FORMAT_STR_PLACEHOLDER_REGEX</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;{(\w+?)?([!:].*?)?}&quot;</span>


<div class="viewcode-block" id="Client"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client.html#obspy.clients.filesystem.sds.Client">[docs]</a><span class="k">class</span> <span class="nc">Client</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Request client for SeisComP Data Structure archive on local filesystem.</span>

<span class="sd">    For details see the :meth:`~obspy.clients.filesystem.sds.Client.__init__()`</span>
<span class="sd">    method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">FMTSTR</span> <span class="o">=</span> <span class="n">SDS_FMTSTR</span>

<div class="viewcode-block" id="Client.__init__"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client.__init__.html#obspy.clients.filesystem.sds.Client.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sds_root</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;MSEED&quot;</span><span class="p">,</span>
                 <span class="n">fileborder_seconds</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">fileborder_samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a SDS local filesystem client.</span>

<span class="sd">        &gt;&gt;&gt; from obspy.clients.filesystem.sds import Client</span>
<span class="sd">        &gt;&gt;&gt; client = Client(&quot;/my/SDS/archive/root&quot;)  # doctest: +SKIP</span>

<span class="sd">        :type sds_root: str</span>
<span class="sd">        :param sds_root: Root directory of SDS archive.</span>
<span class="sd">        :type sds_type: str</span>
<span class="sd">        :param sds_type: SDS data type identifier, one single character. Types</span>
<span class="sd">            recommended by the SDS definition are: &#39;D&#39; - Waveform data,</span>
<span class="sd">            &#39;E&#39; - Detection data, &#39;L&#39; - Log data, &#39;T&#39; - Timing data,</span>
<span class="sd">            &#39;C&#39; - Calibration data, &#39;R&#39; - Response data, &#39;O&#39; - Opaque data. Can</span>
<span class="sd">            also be wildcarded by setting to ``?`` or ``*``.</span>
<span class="sd">        :type format: str</span>
<span class="sd">        :param format: File format the data is stored in, see</span>
<span class="sd">            :func:`~obspy.core.stream.read()` for a list of file formats</span>
<span class="sd">            supported by ObsPy. Usually, SDS archives are stored in &quot;MSEED&quot;</span>
<span class="sd">            format. Can be set to ``None`` for file format autodetection</span>
<span class="sd">            (slowing down the reading).</span>
<span class="sd">        :type fileborder_seconds: float</span>
<span class="sd">        :param fileborder_seconds: Defines in which cases the client checks the</span>
<span class="sd">            previous/next daily file for the requested data (data in SDS</span>
<span class="sd">            archives usually spill over on the day break, at least for a few</span>
<span class="sd">            seconds). For example setting ``fileborder_seconds=30`` means that</span>
<span class="sd">            for a request with ``starttime`` at ``00:00:29`` UTC (or an</span>
<span class="sd">            ``endtime`` at ``23:59:31``), the previous daily file is also</span>
<span class="sd">            checked, if it contains matching data. The maximum of both</span>
<span class="sd">            ``fileborder_seconds`` and ``fileborder_samples`` is used when</span>
<span class="sd">            determining if previous/next day should be checked for data.</span>
<span class="sd">        :type fileborder_samples: int</span>
<span class="sd">        :param fileborder_samples: Similar to ``fileborder_seconds``. The given</span>
<span class="sd">            number of samples is converted to seconds by mapping the band</span>
<span class="sd">            code of the requested channel to sampling frequency. The maximum of</span>
<span class="sd">            both ``fileborder_seconds`` and ``fileborder_samples`` is used when</span>
<span class="sd">            determining if previous/next day should be checked for data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">sds_root</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;SDS root is not a local directory: &quot;</span> <span class="o">+</span> <span class="n">sds_root</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sds_root</span> <span class="o">=</span> <span class="n">sds_root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sds_type</span> <span class="o">=</span> <span class="n">sds_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="nb">format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileborder_seconds</span> <span class="o">=</span> <span class="n">fileborder_seconds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileborder_samples</span> <span class="o">=</span> <span class="n">fileborder_samples</span></div>

<div class="viewcode-block" id="Client.get_waveforms"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client.get_waveforms.html#obspy.clients.filesystem.sds.Client.get_waveforms">[docs]</a>    <span class="k">def</span> <span class="nf">get_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span>
                      <span class="n">endtime</span><span class="p">,</span> <span class="n">merge</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read data from a local SeisComP Data Structure (SDS) directory tree.</span>

<span class="sd">        &gt;&gt;&gt; from obspy import UTCDateTime</span>
<span class="sd">        &gt;&gt;&gt; t = UTCDateTime(&quot;2015-10-12T12&quot;)</span>
<span class="sd">        &gt;&gt;&gt; st = client.get_waveforms(&quot;IU&quot;, &quot;ANMO&quot;, &quot;*&quot;, &quot;HH?&quot;, t, t+30)</span>
<span class="sd">        ... # doctest: +SKIP</span>

<span class="sd">        :type network: str</span>
<span class="sd">        :param network: Network code of requested data (e.g. &quot;IU&quot;).</span>
<span class="sd">            Wildcards &#39;*&#39; and &#39;?&#39; are supported.</span>
<span class="sd">        :type station: str</span>
<span class="sd">        :param station: Station code of requested data (e.g. &quot;ANMO&quot;).</span>
<span class="sd">            Wildcards &#39;*&#39; and &#39;?&#39; are supported.</span>
<span class="sd">        :type location: str</span>
<span class="sd">        :param location: Location code of requested data (e.g. &quot;&quot;).</span>
<span class="sd">            Wildcards &#39;*&#39; and &#39;?&#39; are supported.</span>
<span class="sd">        :type channel: str</span>
<span class="sd">        :param channel: Channel code of requested data (e.g. &quot;HHZ&quot;).</span>
<span class="sd">            Wildcards &#39;*&#39; and &#39;?&#39; are supported.</span>
<span class="sd">        :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param starttime: Start of requested time window.</span>
<span class="sd">        :type endtime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param endtime: End of requested time window.</span>
<span class="sd">        :type merge: int or None</span>
<span class="sd">        :param merge: Specifies, which merge operation should be performed</span>
<span class="sd">            on the stream before returning the data. Default (``-1``) means</span>
<span class="sd">            only a conservative cleanup merge is performed to merge seamless</span>
<span class="sd">            traces (e.g. when reading across day boundaries). See</span>
<span class="sd">            :meth:`Stream.merge(...) &lt;obspy.core.stream.Stream.merge&gt;` for</span>
<span class="sd">            details. If set to ``None`` (or ``False``) no merge operation at</span>
<span class="sd">            all will be performed.</span>
<span class="sd">        :type sds_type: str</span>
<span class="sd">        :param sds_type: Override SDS data type identifier that was specified</span>
<span class="sd">            during client initialization.</span>
<span class="sd">        :param kwargs: Additional kwargs that get passed on to</span>
<span class="sd">            :func:`~obspy.core.stream.read` internally, mostly for internal</span>
<span class="sd">            low-level purposes used by other methods.</span>
<span class="sd">        :rtype: :class:`~obspy.core.stream.Stream`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">starttime</span> <span class="o">&gt;=</span> <span class="n">endtime</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;endtime&#39; must be after &#39;starttime&#39;.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">sds_type</span> <span class="o">=</span> <span class="n">sds_type</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sds_type</span>

        <span class="n">seed_pattern</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">))</span>

        <span class="n">st</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
        <span class="n">full_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_filenames</span><span class="p">(</span>
            <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span>
            <span class="n">sds_type</span><span class="o">=</span><span class="n">sds_type</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">full_path</span> <span class="ow">in</span> <span class="n">full_paths</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="n">read</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span><span class="p">,</span>
                       <span class="n">endtime</span><span class="o">=</span><span class="n">endtime</span><span class="p">,</span> <span class="n">sourcename</span><span class="o">=</span><span class="n">seed_pattern</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># make sure we only have the desired data, just in case the file</span>
        <span class="c1"># contents do not match the expected SEED id</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                       <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">)</span>

        <span class="c1"># avoid trim/merge operations when we do a headonly read for</span>
        <span class="c1"># `_get_availability_percentage()`</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_no_trim_or_merge&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">st</span>

        <span class="n">st</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">merge</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">merge</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">merge</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">st</span></div>

<div class="viewcode-block" id="Client._get_filenames"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client._get_filenames.html#obspy.clients.filesystem.sds.Client._get_filenames">[docs]</a>    <span class="k">def</span> <span class="nf">_get_filenames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span>
                       <span class="n">endtime</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get list of filenames for certain waveform and time span.</span>

<span class="sd">        :type network: str</span>
<span class="sd">        :param network: Network code of requested data (e.g. &quot;IU&quot;).</span>
<span class="sd">        :type station: str</span>
<span class="sd">        :param station: Station code of requested data (e.g. &quot;ANMO&quot;).</span>
<span class="sd">        :type location: str</span>
<span class="sd">        :param location: Location code of requested data (e.g. &quot;&quot;).</span>
<span class="sd">        :type channel: str</span>
<span class="sd">        :param channel: Channel code of requested data (e.g. &quot;HHZ&quot;).</span>
<span class="sd">        :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param starttime: Start of time span.</span>
<span class="sd">        :type endtime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param endtime: End of time span.</span>
<span class="sd">        :type sds_type: str</span>
<span class="sd">        :param sds_type: Override SDS data type identifier that was specified</span>
<span class="sd">            during client initialization.</span>
<span class="sd">        :rtype: list of str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sds_type</span> <span class="o">=</span> <span class="n">sds_type</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sds_type</span>
        <span class="c1"># SDS has data sometimes in adjacent days, so also try to read the</span>
        <span class="c1"># requested data from those files. Usually this is only a few seconds</span>
        <span class="c1"># of data after midnight, but for now we play safe here to catch all</span>
        <span class="c1"># requested data (and with MiniSEED - the usual SDS file format - we</span>
        <span class="c1"># can use starttime/endtime kwargs anyway to read only desired parts).</span>
        <span class="n">year_doy</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># determine how far before starttime/after endtime we should check</span>
        <span class="c1"># other dayfiles for the data</span>
        <span class="n">t_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileborder_samples</span> <span class="o">/</span> <span class="n">BAND_CODE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">channel</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="mf">20.0</span><span class="p">)</span>
        <span class="n">t_buffer</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t_buffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileborder_seconds</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">starttime</span> <span class="o">-</span> <span class="n">t_buffer</span>
        <span class="n">t_max</span> <span class="o">=</span> <span class="n">endtime</span> <span class="o">+</span> <span class="n">t_buffer</span>
        <span class="c1"># make a list of year/doy combinations that covers the whole requested</span>
        <span class="c1"># time window (plus day before and day after)</span>
        <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_max</span><span class="p">:</span>
            <span class="n">year_doy</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">julday</span><span class="p">))</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">year_doy</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">t_max</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">t_max</span><span class="o">.</span><span class="n">julday</span><span class="p">))</span>

        <span class="n">full_paths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">year</span><span class="p">,</span> <span class="n">doy</span> <span class="ow">in</span> <span class="n">year_doy</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FMTSTR</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="n">year</span><span class="p">,</span> <span class="n">doy</span><span class="o">=</span><span class="n">doy</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="n">sds_type</span><span class="p">)</span>
            <span class="n">full_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sds_root</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">full_paths</span> <span class="o">=</span> <span class="n">full_paths</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">full_path</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">full_paths</span></div>

<div class="viewcode-block" id="Client._get_filename"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client._get_filename.html#obspy.clients.filesystem.sds.Client._get_filename">[docs]</a>    <span class="k">def</span> <span class="nf">_get_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span>
                      <span class="n">sds_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get filename for certain waveform.</span>

<span class="sd">        :type network: str</span>
<span class="sd">        :param network: Network code of requested data (e.g. &quot;IU&quot;).</span>
<span class="sd">        :type station: str</span>
<span class="sd">        :param station: Station code of requested data (e.g. &quot;ANMO&quot;).</span>
<span class="sd">        :type location: str</span>
<span class="sd">        :param location: Location code of requested data (e.g. &quot;&quot;).</span>
<span class="sd">        :type channel: str</span>
<span class="sd">        :param channel: Channel code of requested data (e.g. &quot;HHZ&quot;).</span>
<span class="sd">        :type time: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param time: Time of interest.</span>
<span class="sd">        :type sds_type: str</span>
<span class="sd">        :param sds_type: Override SDS data type identifier that was specified</span>
<span class="sd">            during client initialization.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sds_type</span> <span class="o">=</span> <span class="n">sds_type</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sds_type</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FMTSTR</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">doy</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">julday</span><span class="p">,</span>
            <span class="n">sds_type</span><span class="o">=</span><span class="n">sds_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sds_root</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_availability_percentage"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client.get_availability_percentage.html#obspy.clients.filesystem.sds.Client.get_availability_percentage">[docs]</a>    <span class="k">def</span> <span class="nf">get_availability_percentage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
                                    <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get percentage of available data.</span>

<span class="sd">        :type network: str</span>
<span class="sd">        :param network: Network code of requested data (e.g. &quot;IU&quot;).</span>
<span class="sd">        :type station: str</span>
<span class="sd">        :param station: Station code of requested data (e.g. &quot;ANMO&quot;).</span>
<span class="sd">        :type location: str</span>
<span class="sd">        :param location: Location code of requested data (e.g. &quot;&quot;).</span>
<span class="sd">        :type channel: str</span>
<span class="sd">        :param channel: Channel code of requested data (e.g. &quot;HHZ&quot;).</span>
<span class="sd">        :type starttime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param starttime: Start of requested time window.</span>
<span class="sd">        :type endtime: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param endtime: End of requested time window.</span>
<span class="sd">        :type sds_type: str</span>
<span class="sd">        :param sds_type: Override SDS data type identifier that was specified</span>
<span class="sd">            during client initialization.</span>
<span class="sd">        :rtype: 2-tuple (float, int)</span>
<span class="sd">        :returns: 2-tuple of percentage of available data (``0.0`` to ``1.0``)</span>
<span class="sd">            and number of gaps/overlaps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">starttime</span> <span class="o">&gt;=</span> <span class="n">endtime</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;endtime&#39; must be after &#39;starttime&#39;.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">sds_type</span> <span class="o">=</span> <span class="n">sds_type</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sds_type</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span>
                <span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">_headonly_warning_msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="s2">&quot;obspy.core.stream&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_waveforms</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
                                    <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="n">sds_type</span><span class="p">,</span>
                                    <span class="n">headonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_no_trim_or_merge</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># even if the warning was silently caught and not shown it gets</span>
        <span class="c1"># registered in the __warningregistry__ and will not be shown</span>
        <span class="c1"># subsequently in a place were it&#39;s not caught</span>
        <span class="c1"># see https://bugs.python.org/issue4180</span>
        <span class="c1"># see e.g. http://blog.ionelmc.ro/2013/06/26/testing-python-warnings/</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">obspy.core.stream</span> <span class="k">import</span> <span class="n">__warningregistry__</span> <span class="k">as</span> \
                <span class="n">stream_warningregistry</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="c1"># import error means no warning has been issued from</span>
            <span class="c1"># obspy.core.stream before, so nothing to do.</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">stream_warningregistry</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">_headonly_warning_msg</span><span class="p">:</span>
                    <span class="n">stream_warningregistry</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">st</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;starttime&#39;</span><span class="p">,</span> <span class="s1">&#39;endtime&#39;</span><span class="p">])</span>
        <span class="n">st</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">tr</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span>
                     <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">&lt;</span> <span class="n">starttime</span> <span class="ow">or</span>
                             <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">&gt;</span> <span class="n">endtime</span><span class="p">)]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">total_duration</span> <span class="o">=</span> <span class="n">endtime</span> <span class="o">-</span> <span class="n">starttime</span>
        <span class="c1"># sum up gaps in the middle</span>
        <span class="n">gaps</span> <span class="o">=</span> <span class="p">[</span><span class="n">gap</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="k">for</span> <span class="n">gap</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">get_gaps</span><span class="p">()]</span>
        <span class="n">gap_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gaps</span><span class="p">)</span>
        <span class="n">gap_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gaps</span><span class="p">)</span>
        <span class="c1"># check if we have a gap at start or end</span>
        <span class="n">earliest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">])</span>
        <span class="n">latest</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">earliest</span> <span class="o">&gt;</span> <span class="n">starttime</span><span class="p">:</span>
            <span class="n">gap_sum</span> <span class="o">+=</span> <span class="n">earliest</span> <span class="o">-</span> <span class="n">starttime</span>
            <span class="n">gap_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">latest</span> <span class="o">&lt;</span> <span class="n">endtime</span><span class="p">:</span>
            <span class="n">gap_sum</span> <span class="o">+=</span> <span class="n">endtime</span> <span class="o">-</span> <span class="n">latest</span>
            <span class="n">gap_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">gap_sum</span> <span class="o">/</span> <span class="n">total_duration</span><span class="p">),</span> <span class="n">gap_count</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client._get_current_endtime"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client._get_current_endtime.html#obspy.clients.filesystem.sds.Client._get_current_endtime">[docs]</a>    <span class="k">def</span> <span class="nf">_get_current_endtime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
                             <span class="n">sds_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get time of last sample for given stream.</span>

<span class="sd">        ``None`` is returned if no data at all is encountered when going</span>
<span class="sd">        backwards until `stop_time` (defaults to Jan 1st 1950).</span>

<span class="sd">        :type network: str</span>
<span class="sd">        :param network: Network code of requested data (e.g. &quot;IU&quot;).</span>
<span class="sd">        :type station: str</span>
<span class="sd">        :param station: Station code of requested data (e.g. &quot;ANMO&quot;).</span>
<span class="sd">        :type location: str</span>
<span class="sd">        :param location: Location code of requested data (e.g. &quot;&quot;).</span>
<span class="sd">        :type channel: str</span>
<span class="sd">        :param channel: Channel code of requested data (e.g. &quot;HHZ&quot;).</span>
<span class="sd">        :type sds_type: str</span>
<span class="sd">        :param sds_type: Override SDS data type identifier that was specified</span>
<span class="sd">            during client initialization.</span>
<span class="sd">        :type stop_time: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param stop_time: Time at which the search for data is stopped and</span>
<span class="sd">            ``None`` is returned. If not specified, stops at ``1950-01-01T00``.</span>
<span class="sd">        :rtype: :class:`~obspy.core.utcdatetime.UTCDateTime` or ``None``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sds_type</span> <span class="o">=</span> <span class="n">sds_type</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sds_type</span>

        <span class="n">seed_pattern</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">(</span>
                <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="n">sds_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">stop_time</span> <span class="o">=</span> <span class="n">stop_time</span> <span class="ow">or</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">1950</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">()</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="n">stop_time</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_filename</span><span class="p">(</span>
                <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="n">sds_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">headonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">sourcename</span><span class="o">=</span><span class="n">seed_pattern</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">,</span>
                               <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">st</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">time</span> <span class="o">-=</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">3600</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">])</span></div>

<div class="viewcode-block" id="Client.get_latency"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client.get_latency.html#obspy.clients.filesystem.sds.Client.get_latency">[docs]</a>    <span class="k">def</span> <span class="nf">get_latency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span>
                    <span class="n">sds_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get latency for given stream, i.e. difference of current time and</span>
<span class="sd">        latest available data for stream in SDS archive. ``None`` is returned</span>
<span class="sd">        if no data at all is encountered when going backwards until</span>
<span class="sd">        `stop_time` (defaults to Jan 1st 1950).</span>

<span class="sd">        :type network: str</span>
<span class="sd">        :param network: Network code of requested data (e.g. &quot;IU&quot;).</span>
<span class="sd">        :type station: str</span>
<span class="sd">        :param station: Station code of requested data (e.g. &quot;ANMO&quot;).</span>
<span class="sd">        :type location: str</span>
<span class="sd">        :param location: Location code of requested data (e.g. &quot;&quot;).</span>
<span class="sd">        :type channel: str</span>
<span class="sd">        :param channel: Channel code of requested data (e.g. &quot;HHZ&quot;).</span>
<span class="sd">        :type sds_type: str</span>
<span class="sd">        :param sds_type: Override SDS data type identifier that was specified</span>
<span class="sd">            during client initialization.</span>
<span class="sd">        :type stop_time: :class:`~obspy.core.utcdatetime.UTCDateTime`</span>
<span class="sd">        :param stop_time: Time at which the search for data is stopped and</span>
<span class="sd">            ``None`` is returned. If not specified, stops at ``1950-01-01T00``.</span>
<span class="sd">        :rtype: float or ``None``</span>
<span class="sd">        :returns: Latency in seconds or ``None`` if no data was encountered</span>
<span class="sd">            from current time backwards until ``stop_time``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_current_endtime</span><span class="p">(</span>
            <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="n">sds_type</span><span class="p">,</span> <span class="n">stop_time</span><span class="o">=</span><span class="n">stop_time</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">endtime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">endtime</span>

        <span class="k">return</span> <span class="n">UTCDateTime</span><span class="p">()</span> <span class="o">-</span> <span class="n">endtime</span></div>

<div class="viewcode-block" id="Client.has_data"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client.has_data.html#obspy.clients.filesystem.sds.Client.has_data">[docs]</a>    <span class="k">def</span> <span class="nf">has_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if specified stream has any data.</span>

<span class="sd">        Actually just checks whether a file is encountered in a folder that is</span>
<span class="sd">        expected to contain data.</span>

<span class="sd">        :type network: str</span>
<span class="sd">        :param network: Network code of requested data (e.g. &quot;IU&quot;).</span>
<span class="sd">        :type station: str</span>
<span class="sd">        :param station: Station code of requested data (e.g. &quot;ANMO&quot;).</span>
<span class="sd">        :type location: str</span>
<span class="sd">        :param location: Location code of requested data (e.g. &quot;&quot;).</span>
<span class="sd">        :type channel: str</span>
<span class="sd">        :param channel: Channel code of requested data (e.g. &quot;HHZ&quot;).</span>
<span class="sd">        :type sds_type: str</span>
<span class="sd">        :param sds_type: Override SDS data type identifier that was specified</span>
<span class="sd">            during client initialization.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sds_type</span> <span class="o">=</span> <span class="n">sds_type</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sds_type</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
            <span class="n">FORMAT_STR_PLACEHOLDER_REGEX</span><span class="p">,</span>
            <span class="n">_wildcarded_except</span><span class="p">([</span><span class="s2">&quot;network&quot;</span><span class="p">,</span> <span class="s2">&quot;station&quot;</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;channel&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;sds_type&quot;</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FMTSTR</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="o">=</span><span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="n">sds_type</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sds_root</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Client.get_all_nslc"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client.get_all_nslc.html#obspy.clients.filesystem.sds.Client.get_all_nslc">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_nslc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return information on what streams are included in archive.</span>

<span class="sd">        Note that this can be very slow on network file systems because every</span>
<span class="sd">        single file has to be touched (because available location codes can not</span>
<span class="sd">        be discovered from folder structure alone).</span>

<span class="sd">        :type sds_type: str</span>
<span class="sd">        :param sds_type: Override SDS data type identifier that was specified</span>
<span class="sd">            during client initialization.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        :returns: List of (network, station, location, channel) 4-tuples of all</span>
<span class="sd">            available streams in archive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sds_type</span> <span class="o">=</span> <span class="n">sds_type</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sds_type</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># wildcarded pattern to match all files of interest</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
            <span class="n">FORMAT_STR_PLACEHOLDER_REGEX</span><span class="p">,</span>
            <span class="n">_wildcarded_except</span><span class="p">([</span><span class="s2">&quot;sds_type&quot;</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FMTSTR</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sds_type</span><span class="o">=</span><span class="n">sds_type</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sds_root</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
        <span class="n">all_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="c1"># set up inverse regex to extract kwargs/values from full paths</span>
        <span class="n">pattern_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sds_root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FMTSTR</span><span class="p">)</span>
        <span class="n">group_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">groups</span> <span class="ow">in</span>
                     <span class="nb">enumerate</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">FORMAT_STR_PLACEHOLDER_REGEX</span><span class="p">,</span>
                                          <span class="n">pattern_</span><span class="p">))}</span>
        <span class="k">for</span> <span class="n">file_</span> <span class="ow">in</span> <span class="n">all_files</span><span class="p">:</span>
            <span class="n">dict_</span> <span class="o">=</span> <span class="n">_parse_path_to_dict</span><span class="p">(</span><span class="n">file_</span><span class="p">,</span> <span class="n">pattern_</span><span class="p">,</span> <span class="n">group_map</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">network</span> <span class="o">=</span> <span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">]</span>
                <span class="n">station</span> <span class="o">=</span> <span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span>
                <span class="n">location</span> <span class="o">=</span> <span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span>
                <span class="n">channel</span> <span class="o">=</span> <span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Failed to extract key from pattern &#39;</span><span class="si">{}</span><span class="s2">&#39; in path &quot;</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">file_</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

<div class="viewcode-block" id="Client.get_all_stations"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds.Client.get_all_stations.html#obspy.clients.filesystem.sds.Client.get_all_stations">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_stations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sds_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return information on what stations are included in archive.</span>

<span class="sd">        This method assumes that network/station combinations can be discovered</span>
<span class="sd">        from the folder structure alone (as opposed to the filenames).</span>

<span class="sd">        :type sds_type: str</span>
<span class="sd">        :param sds_type: Override SDS data type identifier that was specified</span>
<span class="sd">            during client initialization.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        :returns: List of (network, station) 2-tuples of all available stations</span>
<span class="sd">            in archive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sds_type</span> <span class="o">=</span> <span class="n">sds_type</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sds_type</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># wildcarded pattern to match all files of interest</span>
        <span class="n">fmtstr</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FMTSTR</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
            <span class="n">FORMAT_STR_PLACEHOLDER_REGEX</span><span class="p">,</span>
            <span class="n">_wildcarded_except</span><span class="p">([</span><span class="s2">&quot;sds_type&quot;</span><span class="p">]),</span>
            <span class="n">fmtstr</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sds_type</span><span class="o">=</span><span class="n">sds_type</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sds_root</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
        <span class="n">all_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="c1"># set up inverse regex to extract kwargs/values from full paths</span>
        <span class="n">pattern_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sds_root</span><span class="p">,</span> <span class="n">fmtstr</span><span class="p">)</span>
        <span class="n">group_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">groups</span> <span class="ow">in</span>
                     <span class="nb">enumerate</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">FORMAT_STR_PLACEHOLDER_REGEX</span><span class="p">,</span>
                                          <span class="n">pattern_</span><span class="p">))}</span>
        <span class="k">for</span> <span class="n">file_</span> <span class="ow">in</span> <span class="n">all_files</span><span class="p">:</span>
            <span class="n">dict_</span> <span class="o">=</span> <span class="n">_parse_path_to_dict</span><span class="p">(</span><span class="n">file_</span><span class="p">,</span> <span class="n">pattern_</span><span class="p">,</span> <span class="n">group_map</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">network</span> <span class="o">=</span> <span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">]</span>
                <span class="n">station</span> <span class="o">=</span> <span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Failed to extract key from pattern &#39;</span><span class="si">{}</span><span class="s2">&#39; in path &quot;</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern_</span><span class="p">,</span> <span class="n">file_</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="_wildcarded_except"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds._wildcarded_except.html#obspy.clients.filesystem.sds._wildcarded_except">[docs]</a><span class="k">def</span> <span class="nf">_wildcarded_except</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function factory for :mod:`re` ``repl`` functions used in :func:`re.sub``,</span>
<span class="sd">    replacing all format string place holders with ``*`` wildcards, except</span>
<span class="sd">    named fields as specified in ``exclude``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_wildcarded</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;*&quot;</span>
    <span class="k">return</span> <span class="n">_wildcarded</span></div>


<div class="viewcode-block" id="_parse_path_to_dict"><a class="viewcode-back" href="../../../../packages/autogen/obspy.clients.filesystem.sds._parse_path_to_dict.html#obspy.clients.filesystem.sds._parse_path_to_dict">[docs]</a><span class="k">def</span> <span class="nf">_parse_path_to_dict</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">group_map</span><span class="p">):</span>
    <span class="c1"># escape special regex characters &quot;.&quot; and &quot;\&quot;</span>
    <span class="c1"># in principle we should escape all special characters in Python regex:</span>
    <span class="c1">#    . ^ $ * + ? { } [ ] \ | ( )</span>
    <span class="c1"># and also only replace them if outside of format string placeholders..</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([\.</span><span class="se">\\</span><span class="s1">])&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">\1&#39;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
    <span class="c1"># replace each format string placeholder with a regex group, matching</span>
    <span class="c1"># alphanumerics. append end-of-line otherwise the last non-greedy match</span>
    <span class="c1"># doesn&#39;t catch anything if it&#39;s at the end of the regex</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">FORMAT_STR_PLACEHOLDER_REGEX</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;(\w*?)&#39;</span><span class="p">,</span> <span class="n">regex</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">group_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Failed to parse path &#39;</span><span class="si">{}</span><span class="s2">&#39;: Mismatching information &quot;</span>
                    <span class="s2">&quot;for key &#39;</span><span class="si">{}</span><span class="s2">&#39; from pattern &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">path</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">exclude_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

</div>

<footer>
<p class="text-muted small">
By the <a href="https://github.com/orgs/obspy/people">ObsPy
Development Team</a> and many <a href="#contributers" role="button"
data-toggle="modal" data-target="#contributers">Awesome Contributors</a>™ &nbsp;|&nbsp; Built with
<a href="http://getbootstrap.com/">Bootstrap</a> and
<a href="http://glyphicons.com//">Glyphicons</a> &nbsp;|&nbsp; Copyright 2008-2016
</p>
</footer>
<div id="contributers" class="modal fade" tabindex="-1"
role="dialog" aria-labelledby="contributersLabel" aria-hidden="true">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<button type="button" class="close" data-dismiss="modal"
aria-hidden="true">&times;</button>
<h3 class="modal-title" id="contributersLabel">Thank you!</h3>
</div>
<div class="modal-body">
<p>We would like to thank our contributors, whose efforts make
this software what it is. These people have helped by writing code
and documentation, and by testing. They have created and
maintained this product, its associated libraries and
applications, our build tools and our web sites.</p>
<h4>Contributors</h4>
<div class="container-fluid">
<div class="row">
<div class="col-md-6">
<ul>
<li>Ammon, Charles J.</li>
<li>Arnarsson, Ólafur St.</li>
<li>Barsch, Robert</li>
<li>Bernardi, Fabrizio</li>
<li>Beyreuther, Moritz</li>
<li>Carothers, Lloyd</li>
<li>Egdorf, Sven</li>
<li>Ermert, Laura</li>
<li>Fabbri, Tommaso</li>
<li>Grunberg, Marc</li>
<li>Heimann, Sebastian</li>
<li>Hope, Gaute</li>
<li>Inza, Adolfo</li>
<li>Ketchum, David</li>
<li>Kremers, Simon</li>
<li>Krieger, Lars</li>
<li>Käufl, Paul</li>
<li>Lecocq, Thomas</li>
<li>Lesage, Philippe</li>
<li>Lopes, Rui L.</li>
<li>Maggi, Alessia</li>
<li>Megies, Tobias</li>
<li>Michelini, Alberto</li>
<li>Morgenstern, Bernhard</li>
<li>Panning, Mark P.</li>
<li>Reyes, Celso</li>
<li>Rothenhäusler, Nicolas</li>
<li>Sales de Andrade, Elliott</li>
<li>Saul, Joachim</li>
<li>Sippl, Christian</li>
<li>Stange, Stefan</li>
<li>Trabant, Chad</li>
<li>Walker, Andrew</li>
<li>Wassermann, Joachim</li>
<li>Winkelman, Andrew</li>
<li>van Driel, Martin</li>
</ul>
</div>
<div class="col-md-6">
<ul>
<li>Antunes, Emanuel</li>
<li>Bank, Markus</li>
<li>Behr, Yannik</li>
<li>Bernauer, Felix</li>
<li>Bonaimé, Sébastien</li>
<li>Danecek, Peter</li>
<li>Engels, Fabian</li>
<li>Eulenfeld, Tom</li>
<li>Grellier, Clément</li>
<li>Hammer, Conny</li>
<li>Heiniger, Lukas</li>
<li>Igel, Heiner</li>
<li>Isken, Marius</li>
<li>Koymans, Mathijs</li>
<li>Kress, Victor</li>
<li>Krischer, Lion</li>
<li>Köhler, Andreas</li>
<li>Leeman, John</li>
<li>Lomax, Anthony</li>
<li>MacCarthy, Jonathan</li>
<li>Martin, Henri</li>
<li>Meschede, Matthias</li>
<li>Miller, Nathaniel C.</li>
<li>Nof, Ran Novitsky</li>
<li>Rapagnani, Giovanni</li>
<li>Ringler, Adam</li>
<li>Russo, Emiliano</li>
<li>Satriano, Claudio</li>
<li>Scheingraber, Chris</li>
<li>Snoke, Arthur</li>
<li>Sullivan, Benjamin</li>
<li>Uieda, Leonardo</li>
<li>Walther, Marcus</li>
<li>Williams, Mark C.</li>
<li>Zad, Seyed Kasra Hosseini</li>
</ul>
</div>
</div>
</div>
<h4>Funds</h4>
<p>ObsPy was partially funded by the</p>
<ul>
<li>German Science Foundation (DFG) via grant DFG IG 16/9-1</li>
<li>German Ministry for Education and Research (BMBF), GEOTECHNOLOGIEN grant 03G0646H.</li>
<li>NERA project (Network of European Research Infrastructures for Earthquake Risk Assessment and Mitigation) under the European Community&#39;s Seventh Framework Programme (FP7/2007-2013) grant agreement n° 262330</li>
<li>Leibniz Institute for Applied Geophysics (LIAG)</li>
<li>VERCE EU-FP7 project (no. 283543)</li>
</ul>
</div>
<div class="modal-footer">
<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
</div>
</div>
</div>
</div>

</div>


  </body>
</html>